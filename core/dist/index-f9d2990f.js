import { chainNamespaceValidation, chainIdValidation, chainValidation, validate, weiToEth, ProviderRpcErrorCode, SofiaProRegular } from '@web3-onboard/common';
import { BehaviorSubject, Subject, defer, firstValueFrom, fromEventPattern, distinctUntilChanged, filter as filter$1, takeUntil as takeUntil$1, mapTo, take as take$1 } from 'rxjs';
import { distinctUntilKeyChanged, pluck, filter, shareReplay, withLatestFrom, take, takeUntil, share, switchMap, map, startWith } from 'rxjs/operators';
import bowser from 'bowser';
import { locale as locale$1, _, addMessages, init as init$2, getLocaleFromNavigator } from 'svelte-i18n';
import { nanoid } from 'nanoid';
import Joi from 'joi';
import BigNumber$1 from 'bignumber.js';
import {get as get$1 } from 'svelte/store';
import partition from 'lodash.partition';
import { utils as utils$o, providers, BigNumber as BigNumber$2 } from 'ethers';
import merge from 'lodash.merge';
import EventEmitter from 'eventemitter3';

var hourglass = `
<svg width="100%" height="100%" viewBox="0 0 12 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0L0.0100002 6L4 10L0.0100002 14.01L0 20H12V14L8 10L12 6.01V0H0ZM10 14.5V18H2V14.5L6 10.5L10 14.5Z" fill="#929BED"/>
</svg>
`;

var blocknative = `

`;

var ethereumIcon = `
  <svg height="100%" viewBox="0 0 10 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.99902 0.12619V5.20805L9.58065 7.12736L4.99902 0.12619Z" fill="white" fill-opacity="0.602"/>
    <path d="M4.99923 0.12619L0.416992 7.12736L4.99923 5.20805V0.12619Z" fill="white"/>
    <path d="M4.99902 10.4207V13.8737L9.58371 7.92728L4.99902 10.4207Z" fill="white" fill-opacity="0.602"/>
    <path d="M4.99923 13.8737V10.4201L0.416992 7.92728L4.99923 13.8737Z" fill="white"/>
    <path d="M4.99902 9.62134L9.58065 7.12739L4.99902 5.20923V9.62134Z" fill="white" fill-opacity="0.2"/>
    <path d="M0.416992 7.12739L4.99923 9.62134V5.20923L0.416992 7.12739Z" fill="white" fill-opacity="0.602"/>
  </svg>
`;

var polygonIcon = `
  <svg width="100%" viewBox="0 0 14 13" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M10.5091 4.05856C10.2585 3.91901 9.9362 3.91901 9.64974 4.05856L7.64453 5.20986L6.28385 5.94251L4.31445 7.09382C4.0638 7.23337 3.74154 7.23337 3.45508 7.09382L1.91536 6.18673C1.66471 6.04718 1.48568 5.76807 1.48568 5.45408V3.70968C1.48568 3.43057 1.62891 3.15147 1.91536 2.97703L3.45508 2.10483C3.70573 1.96527 4.02799 1.96527 4.31445 2.10483L5.85417 3.01192C6.10482 3.15147 6.28385 3.43057 6.28385 3.74457V4.89587L7.64453 4.12833V2.94214C7.64453 2.66304 7.5013 2.38393 7.21484 2.20949L4.35026 0.569752C4.09961 0.4302 3.77734 0.4302 3.49089 0.569752L0.554687 2.24438C0.268229 2.38393 0.125 2.66304 0.125 2.94214V6.22162C0.125 6.50072 0.268229 6.77983 0.554687 6.95427L3.45508 8.59401C3.70573 8.73356 4.02799 8.73356 4.31445 8.59401L6.28385 7.47759L7.64453 6.71005L9.61393 5.59363C9.86458 5.45408 10.1868 5.45408 10.4733 5.59363L12.013 6.46583C12.2637 6.60539 12.4427 6.88449 12.4427 7.19848V8.94289C12.4427 9.22199 12.2995 9.50109 12.013 9.67553L10.5091 10.5477C10.2585 10.6873 9.9362 10.6873 9.64974 10.5477L8.11002 9.67553C7.85937 9.53598 7.68034 9.25688 7.68034 8.94289V7.82647L6.31966 8.59401V9.74531C6.31966 10.0244 6.46289 10.3035 6.74935 10.478L9.64974 12.1177C9.90039 12.2572 10.2227 12.2572 10.5091 12.1177L13.4095 10.478C13.6602 10.3384 13.8392 10.0593 13.8392 9.74531V6.43095C13.8392 6.15184 13.696 5.87274 13.4095 5.6983L10.5091 4.05856Z" fill="white"/>
  </svg>
`;

var questionIcon = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M11.07 12.85C11.84 11.46 13.32 10.64 14.18 9.41C15.09 8.12 14.58 5.71 12 5.71C10.31 5.71 9.48 6.99 9.13 8.05L6.54 6.96C7.25 4.83 9.18 3 11.99 3C14.34 3 15.95 4.07 16.77 5.41C17.47 6.56 17.88 8.71 16.8 10.31C15.6 12.08 14.45 12.62 13.83 13.76C13.58 14.22 13.48 14.52 13.48 16H10.59C10.58 15.22 10.46 13.95 11.07 12.85ZM14 20C14 21.1 13.1 22 12 22C10.9 22 10 21.1 10 20C10 18.9 10.9 18 12 18C13.1 18 14 18.9 14 20Z" fill="currentColor"/>
  </svg>
`;

var binanceIcon = `
  <svg width="100%" height="100%" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.32975 5.90275L7 3.2325L9.67163 5.90413L11.2254 4.35038L7 0.125L2.776 4.349L4.32975 5.90275ZM0.125 7L1.67875 5.44625L3.2325 7L1.67875 8.55375L0.125 7ZM4.32975 8.09725L7 10.7675L9.67163 8.09587L11.2254 9.64894L7 13.875L2.776 9.651L2.77394 9.64894L4.32975 8.09725ZM10.7675 7L12.3212 5.44625L13.875 7L12.3212 8.55375L10.7675 7ZM8.57575 6.99863H8.57713V7L7 8.57713L5.42494 7.00275L5.42219 7L5.42494 6.99794L5.70062 6.72156L5.83469 6.5875L7 5.42288L8.57644 6.99931L8.57575 6.99863Z" fill="white"/>
  </svg>
`;

var fantomIcon = `
  <svg height="100%" viewBox="0 0 12 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M5.26613 0.133876C5.46683 0.0457135 5.68592 0 5.90775 0C6.12958 0 6.34867 0.0457135 6.54938 0.133876L10.2679 1.9598C10.3617 1.99893 10.4437 2.05898 10.5068 2.13465C10.5699 2.21033 10.6121 2.29932 10.6298 2.3938H10.6335V11.5637C10.6245 11.6667 10.5857 11.7654 10.5213 11.8495C10.457 11.9336 10.3694 11.9998 10.2679 12.0411L6.54938 13.8656C6.34867 13.9538 6.12958 13.9995 5.90775 13.9995C5.68592 13.9995 5.46683 13.9538 5.26613 13.8656L1.54762 12.0397C1.44724 11.9979 1.36095 11.9313 1.29799 11.8472C1.23504 11.7631 1.19779 11.6646 1.19025 11.5623C1.19025 11.5465 1.19025 11.5332 1.19025 11.522V2.39205C1.20579 2.29767 1.24673 2.20852 1.30923 2.13292C1.37173 2.05733 1.45375 1.99776 1.54762 1.9598L5.26613 0.133876ZM10.0478 7.50898L6.54938 9.22396C6.34872 9.31229 6.12961 9.35809 5.90775 9.35809C5.68589 9.35809 5.46678 9.31229 5.26613 9.22396L1.77525 7.51283V11.5455L5.26613 13.2493C5.43937 13.3471 5.62982 13.4154 5.82863 13.4512L5.9085 13.4558C6.12668 13.4357 6.3373 13.3704 6.525 13.2647L10.05 11.5301V7.50898H10.0478ZM0.585375 11.3642C0.568078 11.6186 0.612957 11.8734 0.716625 12.1093C0.805331 12.2602 0.936232 12.3857 1.09538 12.4726L1.10662 12.4796C1.1505 12.5069 1.1985 12.5356 1.25663 12.5692L1.32563 12.6081L1.53675 12.7267L1.23375 13.1922L0.9975 13.0592L0.95775 13.0365C0.889125 12.9973 0.8325 12.9637 0.779625 12.9315C0.214875 12.5769 0.004125 12.1912 0 11.3887V11.3642H0.585H0.585375ZM5.61412 5.05096C5.58845 5.05933 5.5634 5.06926 5.53912 5.08071L1.82137 6.90524L1.81013 6.91119H1.80675L1.81275 6.91469L1.82137 6.91889L5.53988 8.74341C5.56405 8.75505 5.58912 8.76499 5.61487 8.77316L5.61412 5.05096ZM6.201 5.05096V8.77456C6.22675 8.76639 6.25182 8.75645 6.276 8.74481L9.9945 6.92029L10.0057 6.91434H10.0091L10.0031 6.91154L9.9945 6.90699L6.276 5.08246C6.25182 5.07083 6.22675 5.06088 6.201 5.05271V5.05096ZM10.0478 3.04479L6.71025 4.68137L10.0478 6.31795V3.04304V3.04479ZM1.77525 3.04864V6.3141L5.103 4.68137L1.77525 3.04864ZM6.27525 0.61617C6.15894 0.569406 6.03364 0.545286 5.907 0.545286C5.78036 0.545286 5.65506 0.569406 5.53875 0.61617L1.821 2.4393L1.80975 2.4449L1.80638 2.44665L1.81238 2.4498L1.821 2.45365L5.5395 4.27817C5.65571 4.32526 5.78106 4.34956 5.90775 4.34956C6.03444 4.34956 6.15979 4.32526 6.276 4.27817L9.9945 2.45365L10.0057 2.4498L10.0091 2.44805L10.0031 2.4449L9.9945 2.4407L6.27525 0.61617ZM10.5968 0.816717L10.833 0.949365L10.875 0.970015C10.9432 1.00921 10.9999 1.04316 11.0528 1.07501C11.6179 1.42851 11.8282 1.81455 11.8328 2.61709V2.64159H11.2459C11.2632 2.38703 11.2183 2.13212 11.1146 1.8961C11.0258 1.74528 10.8948 1.61983 10.7355 1.53316L10.7242 1.52616C10.6807 1.49851 10.6327 1.47016 10.5743 1.43656L10.5056 1.39981L10.2945 1.28151L10.5975 0.816017L10.5968 0.816717Z" fill="white"/>
  </svg>
`;

var optimismIcon = `
  <svg width="100%" viewBox="0 0 17 10" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M3.33611 9.25254C2.38341 9.25254 1.60287 9.02834 0.99442 8.58002C0.393974 8.1237 0.09375 7.47526 0.09375 6.63462C0.09375 6.45849 0.113782 6.2423 0.153782 5.9861C0.257909 5.40972 0.406006 4.71718 0.598133 3.9086C1.14252 1.707 2.54757 0.606201 4.81323 0.606201C5.42967 0.606201 5.98206 0.710266 6.47044 0.918394C6.95882 1.11852 7.34308 1.42278 7.62327 1.8311C7.90346 2.23135 8.04362 2.71174 8.04362 3.27212C8.04362 3.44025 8.02359 3.65241 7.98352 3.9086C7.86346 4.62111 7.71933 5.31366 7.55121 5.9861C7.27101 7.08294 6.78666 7.90354 6.09815 8.44793C5.40964 8.98431 4.489 9.25254 3.33611 9.25254ZM3.50424 7.52326C3.95262 7.52326 4.33284 7.39116 4.6451 7.12697C4.96535 6.86278 5.19351 6.45849 5.32958 5.9141C5.51371 5.16153 5.65387 4.50502 5.74993 3.94463C5.78193 3.7765 5.79793 3.60441 5.79793 3.42822C5.79793 2.6997 5.41764 2.33542 4.65713 2.33542C4.20875 2.33542 3.82449 2.46751 3.50424 2.7317C3.19205 2.99596 2.96786 3.40025 2.83179 3.94463C2.68766 4.48102 2.54354 5.13753 2.39947 5.9141C2.36741 6.07417 2.35141 6.2423 2.35141 6.41842C2.35141 7.155 2.73573 7.52326 3.50424 7.52326Z" fill="white"/>
    <path d="M8.59569 9.13247C8.50762 9.13247 8.43953 9.10443 8.39153 9.04837C8.35146 8.98431 8.33949 8.9123 8.35549 8.83224L10.0127 1.02648C10.0287 0.938417 10.0727 0.866353 10.1448 0.810289C10.2169 0.754289 10.2929 0.726257 10.373 0.726257H13.5673C14.456 0.726257 15.1685 0.910385 15.7049 1.27864C16.2493 1.64696 16.5215 2.17931 16.5215 2.87582C16.5215 3.07595 16.4975 3.28415 16.4495 3.50027C16.2493 4.42098 15.845 5.10149 15.2366 5.54181C14.6361 5.98213 13.8115 6.20229 12.7627 6.20229H11.1415L10.5892 8.83224C10.5731 8.92031 10.5291 8.99231 10.4571 9.04837C10.385 9.10443 10.3089 9.13247 10.2289 9.13247H8.59569ZM12.8468 4.54507C13.183 4.54507 13.4752 4.45298 13.7234 4.26885C13.9796 4.08472 14.1478 3.82053 14.2278 3.47627C14.2518 3.34015 14.2639 3.22008 14.2639 3.11602C14.2639 2.88383 14.1958 2.7077 14.0597 2.58763C13.9236 2.45951 13.6914 2.3955 13.3632 2.3955H11.9221L11.4658 4.54507H12.8468Z" fill="white"/>
  </svg>
`;

var avalancheIcon = `
  <svg width="100%" viewBox="0 0 20 19" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M19.8682 0.489349H0.110352V18.4468H19.8682V0.489349Z" fill="white"/>
  </svg>
`;

var celoIcon = `
  <svg width="100%" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M19.1511 8.08001C19.1511 4.11201 15.9191 0.880005 11.9511 0.880005C8.94313 0.880005 6.38313 2.70401 5.29513 5.32801C2.73513 6.41601 0.911133 8.976 0.911133 11.952C0.911133 15.92 4.14313 19.152 8.11113 19.152C11.1191 19.152 13.6791 17.328 14.7671 14.704C17.2951 13.616 19.1511 11.056 19.1511 8.08001ZM8.11113 17.36C5.13513 17.36 2.70313 14.928 2.70313 11.952C2.70313 10.256 3.50313 8.72001 4.75113 7.72801C4.75113 7.85601 4.75113 7.98401 4.75113 8.08001C4.75113 12.048 7.98313 15.28 11.9511 15.28C12.1111 15.28 12.2391 15.28 12.3991 15.28C11.3751 16.56 9.83913 17.36 8.11113 17.36ZM13.3591 13.296C12.9111 13.424 12.4311 13.488 11.9511 13.488C8.97513 13.488 6.54313 11.056 6.54313 8.08001C6.54313 7.60001 6.60713 7.15201 6.73513 6.736C7.18313 6.60801 7.66313 6.54401 8.14313 6.54401C11.1191 6.54401 13.5511 8.976 13.5511 11.952C13.5191 12.432 13.4551 12.88 13.3591 13.296ZM15.3111 12.304C15.3111 12.176 15.3111 12.048 15.3111 11.952C15.3111 7.984 12.0791 4.752 8.11113 4.752C7.95113 4.752 7.82313 4.752 7.66313 4.752C8.65513 3.472 10.1911 2.67201 11.9191 2.67201C14.8951 2.67201 17.3271 5.10401 17.3271 8.08001C17.3271 9.80801 16.5271 11.312 15.3111 12.304Z" fill="white"/>
  </svg>
`;

var gnosisIcon = `
  <svg width="100%" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 24.8366 7.16344 32 16 32C24.8366 32 32 24.8366 32 16Z" fill="#04795B"/>
    <path d="M11.6529 17.4492C12.2831 17.4492 12.8648 17.2392 13.3334 16.8758L9.4877 13.0316C9.12413 13.4919 8.9141 14.0734 8.9141 14.7114C8.906 16.2216 10.134 17.4492 11.6529 17.4492Z" fill="#EFEFEF"/>
    <path d="M23.0931 14.7033C23.0931 14.0734 22.8831 13.4919 22.5195 13.0234L18.6738 16.8677C19.1343 17.2311 19.716 17.4411 20.3543 17.4411C21.8651 17.4492 23.0931 16.2216 23.0931 14.7033Z" fill="#EFEFEF"/>
    <path d="M25.0322 10.528L23.3275 12.2321C23.8931 12.9105 24.2324 13.7666 24.2324 14.7195C24.2324 16.8597 22.4954 18.5961 20.3544 18.5961C19.4092 18.5961 18.5447 18.2569 17.866 17.6915L15.9998 19.5571L14.1335 17.6915C13.4549 18.2569 12.5985 18.5961 11.6451 18.5961C9.50416 18.5961 7.7672 16.8597 7.7672 14.7195C7.7672 13.7746 8.10651 12.9105 8.67206 12.2321L7.79947 11.3599L6.96736 10.528C5.99787 12.1271 5.44043 13.9927 5.44043 15.9956C5.44043 21.8265 10.1667 26.543 15.9917 26.543C21.8167 26.543 26.543 21.8185 26.543 15.9956C26.5591 13.9846 26.0017 12.119 25.0322 10.528Z" fill="#EFEFEF"/>
    <path d="M23.6338 8.71084C21.7191 6.6999 19.0045 5.44 15.9991 5.44C12.9937 5.44 10.2872 6.6999 8.36435 8.71084C8.10584 8.98545 7.85539 9.27617 7.62109 9.575L15.991 17.9419L24.361 9.56695C24.1509 9.27617 23.9005 8.97734 23.6338 8.71084ZM15.9991 6.81297C18.4713 6.81297 20.7658 7.76593 22.4866 9.50231L15.9991 15.9874L9.5116 9.50231C11.2405 7.76593 13.5269 6.81297 15.9991 6.81297Z" fill="#EFEFEF"/>
  </svg>
`;

var harmonyOneIcon = `
  <svg width="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.5484 1.04102e-06C11.6346 -0.000708404 10.7578 0.361217 10.1105 1.00633C9.46322 1.65145 9.09835 2.52703 9.096 3.44089V7.256C8.74045 7.28 8.37689 7.29511 8 7.29511C7.62311 7.29511 7.26133 7.31022 6.904 7.33156V3.44089C6.88946 2.53496 6.51938 1.67105 5.87358 1.03553C5.22779 0.400017 4.35805 0.0438409 3.452 0.0438409C2.54595 0.0438409 1.67621 0.400017 1.03042 1.03553C0.384623 1.67105 0.0145378 2.53496 0 3.44089V12.5591C0.0145378 13.465 0.384623 14.329 1.03042 14.9645C1.67621 15.6 2.54595 15.9562 3.452 15.9562C4.35805 15.9562 5.22779 15.6 5.87358 14.9645C6.51938 14.329 6.88946 13.465 6.904 12.5591V8.744C7.25956 8.72 7.62311 8.70489 8 8.70489C8.37689 8.70489 8.73867 8.68978 9.096 8.66845V12.5591C9.11054 13.465 9.48062 14.329 10.1264 14.9645C10.7722 15.6 11.6419 15.9562 12.548 15.9562C13.4541 15.9562 14.3238 15.6 14.9696 14.9645C15.6154 14.329 15.9855 13.465 16 12.5591V3.44089C15.9976 2.52719 15.6329 1.65173 14.9858 1.00665C14.3387 0.361557 13.4622 -0.000472854 12.5484 1.04102e-06ZM3.45156 1.40978C3.99089 1.40954 4.50828 1.62326 4.89023 2.00404C5.27218 2.38482 5.48748 2.90156 5.48889 3.44089V7.48089C4.47892 7.62724 3.49264 7.90609 2.55556 8.31023C2.14954 8.48842 1.76733 8.71655 1.41778 8.98934V3.44089C1.41919 2.90218 1.634 2.38597 2.01518 2.00529C2.39636 1.62462 2.91284 1.41048 3.45156 1.40978ZM5.48889 12.5591C5.48889 13.0994 5.27424 13.6177 4.89217 13.9997C4.51009 14.3818 3.99189 14.5964 3.45156 14.5964C2.91122 14.5964 2.39302 14.3818 2.01094 13.9997C1.62887 13.6177 1.41422 13.0994 1.41422 12.5591V11.6444C1.41422 10.8364 2.05422 10.0711 3.12711 9.59467C3.88309 9.26852 4.6763 9.03656 5.48889 8.904V12.5591ZM12.5484 14.5902C12.0091 14.5905 11.4917 14.3767 11.1098 13.996C10.7278 13.6152 10.5125 13.0984 10.5111 12.5591V8.51911C11.5211 8.37276 12.5074 8.09392 13.4444 7.68978C13.8505 7.51159 14.2327 7.28345 14.5822 7.01067V12.5591C14.5808 13.0978 14.366 13.614 13.9848 13.9947C13.6036 14.3754 13.0872 14.5895 12.5484 14.5902ZM12.8729 6.4C12.1169 6.72615 11.3237 6.95811 10.5111 7.09067V3.44089C10.5111 2.90056 10.7258 2.38235 11.1078 2.00028C11.4899 1.6182 12.0081 1.40356 12.5484 1.40356C13.0888 1.40356 13.607 1.6182 13.9891 2.00028C14.3711 2.38235 14.5858 2.90056 14.5858 3.44089V4.35556C14.5858 5.16 13.9458 5.92534 12.8729 6.4Z" fill="url(#paint0_linear_10254_2422)"/>
    <defs>
      <linearGradient id="paint0_linear_10254_2422" x1="1.01333" y1="14.7674" x2="14.8954" y2="0.847434" gradientUnits="userSpaceOnUse">
        <stop stop-color="#00AEE9"/>
        <stop offset="1" stop-color="#69FABD"/>
      </linearGradient>
    </defs>
  </svg>
`;

var arbitrumIcon = `
  <svg height="100%" viewBox="0 0 22 25" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M13.7827 11.3172L15.5966 8.23933L20.4858 15.8545L20.4881 17.3159L20.4722 7.25942C20.4606 7.0136 20.3301 6.7887 20.1218 6.6561L11.3194 1.5928C11.1135 1.49162 10.8523 1.49269 10.6468 1.59594C10.6191 1.60989 10.593 1.62499 10.568 1.64147L10.5374 1.66079L1.99318 6.6121L1.95999 6.62712C1.91737 6.64674 1.8743 6.67165 1.83382 6.70063C1.67186 6.81683 1.56424 6.98861 1.52944 7.18131C1.52423 7.21052 1.52039 7.24026 1.51855 7.27023L1.53197 15.4653L6.08607 8.40666C6.65942 7.47067 7.90869 7.1692 9.06835 7.1856L10.4295 7.22155L2.40986 20.0827L3.3552 20.627L11.4709 7.23458L15.0581 7.22155L6.96327 20.9519L10.3366 22.8921L10.7396 23.1239C10.9101 23.1932 11.111 23.1967 11.283 23.1347L20.2091 17.9618L18.5026 18.9507L13.7827 11.3172ZM14.4747 21.2849L11.0677 15.9375L13.1474 12.4083L17.622 19.461L14.4747 21.2849Z" fill="#2D374B"/>
    <path d="M11.0684 15.9375L14.4754 21.2849L17.6228 19.4609L13.1482 12.4083L11.0684 15.9375Z" fill="#28A0F0"/>
    <path d="M20.4887 17.3159L20.4864 15.8545L15.5972 8.23932L13.7832 11.3172L18.5031 18.9507L20.2097 17.9618C20.3771 17.8259 20.4783 17.6264 20.489 17.4111L20.4887 17.3159Z" fill="#28A0F0"/>
    <path d="M7.71943e-05 18.694L2.41 20.0826L10.4296 7.22152L9.0685 7.18557C7.90883 7.16916 6.65964 7.47063 6.08621 8.40662L1.53211 15.4652L0 17.8193V18.694H7.71943e-05Z" fill="white"/>
    <path d="M15.0582 7.22156L11.4712 7.23459L3.35547 20.627L6.19211 22.2603L6.96354 20.9519L15.0582 7.22156Z" fill="white"/>
    <path d="M21.9999 7.20306C21.97 6.45287 21.5638 5.76608 20.9275 5.36626L12.0097 0.237888C11.3803 -0.079066 10.594 -0.0794494 9.96363 0.237658C9.88913 0.275218 1.2912 5.26171 1.2912 5.26171C1.17223 5.31874 1.05764 5.38673 0.949789 5.46384C0.381801 5.87094 0.0355663 6.50346 0 7.19846V17.8194L1.53211 15.4653L1.5187 7.27029C1.52054 7.24032 1.52429 7.21088 1.52958 7.18175C1.56415 6.9889 1.67185 6.81689 1.83397 6.70069C1.87444 6.67171 10.6192 1.60995 10.647 1.596C10.8526 1.49275 11.1137 1.49168 11.3195 1.59286L20.122 6.65616C20.3302 6.78876 20.4608 7.01366 20.4723 7.25948V17.4111C20.4617 17.6265 20.3766 17.8259 20.2092 17.9619L18.5026 18.9508L17.6221 19.461L14.4748 21.285L11.283 23.1347C11.1111 23.1968 10.9101 23.1933 10.7397 23.124L6.96334 20.952L6.19191 22.2603L9.58559 24.2142C9.6978 24.278 9.79784 24.3345 9.87985 24.3807C10.0069 24.452 10.0935 24.4996 10.1241 24.5144C10.3653 24.6315 10.7123 24.6997 11.025 24.6997C11.3118 24.6997 11.5913 24.647 11.8559 24.5434L21.1266 19.1745C21.6587 18.7623 21.9717 18.1406 21.9999 17.467V7.20306Z" fill="#96BEDC"/>
  </svg>
`;

var checkmark = `
<svg width="14" height="11" viewBox="0 0 14 11" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M4.48076 8.10881L1.33076 4.95881L0.280762 6.00881L4.48076 10.2088L13.4808 1.20881L12.4308 0.158813L4.48076 8.10881Z" fill="#A4F4C6"/>
</svg>
`;

var errorIcon = `<svg width="16" height="13" viewBox="0 0 16 13" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0.666992 13.0002H15.3337L8.00033 0.333496L0.666992 13.0002ZM8.66699 11.0002H7.33366V9.66683H8.66699V11.0002ZM8.66699 8.3335H7.33366V5.66683H8.66699V8.3335Z" fill="#FFB3B3"/>
</svg>
`;

var infoIcon = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM13 17H11V11H13V17ZM13 9H11V7H13V9Z" fill="currentColor"/>
  </svg>
`;

var successIcon = `
  <svg width="100%" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M6.74999 12.15L3.59999 9L2.54999 10.05L6.74999 14.25L15.75 5.25L14.7 4.2L6.74999 12.15Z" fill="currentColor"/>
  </svg>
`;

var pendingIcon = `
  <svg width="100%" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path d="M6 2L6.01 8L10 12L6.01 16.01L6 22H18V16L14 12L18 8.01V2H6ZM16 16.5V20H8V16.5L12 12.5L16 16.5Z" fill="currenColor"/>
  </svg>
`;

var poweredByBlocknativeIcon = `
<svg width="152" height="16" viewBox="0 0 152 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.03641 6.252C3.23241 6.252 2.41641 6.636 2.04441 7.272V6.396H1.00041V14.724H2.04441V11.124C2.41641 11.784 3.20841 12.144 4.04841 12.144C5.58441 12.144 6.84441 10.98 6.84441 9.204C6.84441 7.44 5.57241 6.252 4.03641 6.252ZM3.94041 11.16C3.02841 11.16 2.04441 10.428 2.04441 9.216C2.04441 8.016 2.94441 7.236 3.94041 7.236C4.97241 7.236 5.78841 8.1 5.78841 9.216C5.78841 10.344 4.97241 11.16 3.94041 11.16ZM10.8452 12.144C12.4412 12.144 13.7852 10.968 13.7852 9.192C13.7852 7.416 12.4412 6.252 10.8452 6.252C9.24919 6.252 7.91719 7.416 7.91719 9.192C7.91719 10.968 9.24919 12.144 10.8452 12.144ZM10.8452 11.16C9.82519 11.16 8.97319 10.356 8.97319 9.192C8.97319 8.04 9.82519 7.236 10.8452 7.236C11.8772 7.236 12.7412 8.04 12.7412 9.192C12.7412 10.356 11.8772 11.16 10.8452 11.16ZM22.2729 6.396L20.8449 10.38L19.4049 6.396H18.3849L16.9569 10.38L15.5289 6.396H14.4009L16.5369 12H17.4009L18.8889 7.836L20.4369 12H21.3129L23.4009 6.396H22.2729ZM29.6948 9.18C29.6948 7.404 28.5068 6.252 26.9108 6.252C25.3148 6.252 24.0308 7.404 24.0308 9.18C24.0308 10.956 25.3148 12.144 26.9108 12.144C27.9908 12.144 28.9988 11.616 29.4788 10.644L28.5788 10.284C28.2548 10.848 27.6308 11.16 26.9468 11.16C25.9868 11.16 25.2668 10.644 25.1108 9.648H29.6708C29.6828 9.492 29.6948 9.336 29.6948 9.18ZM25.1228 8.748C25.2908 7.74 25.9628 7.236 26.9108 7.236C27.8348 7.236 28.5188 7.788 28.6508 8.748H25.1228ZM33.7456 6.252C33.0016 6.252 32.4616 6.684 32.1736 7.668V6.396H31.1176V12H32.1736V9.948C32.1736 8.472 32.6176 7.26 33.7336 7.26C33.9496 7.26 34.2496 7.308 34.5496 7.452L34.7176 6.468C34.5496 6.36 34.1416 6.252 33.7456 6.252ZM40.8627 9.18C40.8627 7.404 39.6747 6.252 38.0787 6.252C36.4827 6.252 35.1987 7.404 35.1987 9.18C35.1987 10.956 36.4827 12.144 38.0787 12.144C39.1587 12.144 40.1667 11.616 40.6467 10.644L39.7467 10.284C39.4227 10.848 38.7987 11.16 38.1147 11.16C37.1547 11.16 36.4347 10.644 36.2787 9.648H40.8387C40.8507 9.492 40.8627 9.336 40.8627 9.18ZM36.2907 8.748C36.4587 7.74 37.1307 7.236 38.0787 7.236C39.0027 7.236 39.6867 7.788 39.8187 8.748H36.2907ZM46.7136 3.348V7.272C46.3416 6.612 45.5496 6.252 44.7096 6.252C43.1736 6.252 41.9136 7.416 41.9136 9.192C41.9136 10.956 43.1856 12.144 44.7216 12.144C45.5256 12.144 46.3416 11.76 46.7136 11.124V12H47.7576V3.348H46.7136ZM44.8056 11.16C43.7856 11.16 42.9696 10.296 42.9696 9.18C42.9696 8.052 43.7856 7.236 44.8056 7.236C45.7296 7.236 46.7136 7.968 46.7136 9.18C46.7136 10.38 45.8136 11.16 44.8056 11.16ZM55.6695 6.252C54.8295 6.252 54.0375 6.612 53.6655 7.272V3.348H52.6215V12H53.6655V11.124C54.0375 11.76 54.8535 12.144 55.6575 12.144C57.1935 12.144 58.4655 10.956 58.4655 9.192C58.4655 7.416 57.2055 6.252 55.6695 6.252ZM55.5615 11.16C54.5655 11.16 53.6655 10.38 53.6655 9.18C53.6655 7.968 54.6495 7.236 55.5615 7.236C56.5935 7.236 57.4095 8.052 57.4095 9.18C57.4095 10.296 56.5935 11.16 55.5615 11.16ZM63.6097 6.396L61.8937 10.524L60.2017 6.396H59.0737L61.3297 11.832L60.1537 14.724H61.2577L64.7377 6.396H63.6097Z" fill="#707481"/>
<g clip-path="url(#clip0_13558_103869)">
<path d="M143.502 11.0888L141.863 8.24889H145.142L146.782 11.0888H143.502Z" fill="#262A3D"/>
<path d="M145.142 8.24887H141.863L143.502 5.40895H146.782L145.142 8.24887Z" fill="url(#paint0_linear_13558_103869)"/>
<path d="M148.421 8.24888L146.782 5.40896H143.502L141.863 2.56903H148.421L151.701 8.24888H148.421Z" fill="#262A3D"/>
<path d="M148.421 13.9287H141.863L143.502 11.0888H146.782L148.421 8.24889H151.701L148.421 13.9287Z" fill="url(#paint1_linear_13558_103869)"/>
<path d="M76.4774 8.89232C76.4774 10.9327 74.9716 12.5077 73.1366 12.5077C72.1369 12.5077 71.4106 12.1378 70.9181 11.508V12.316H69.1513V2.71994L70.9181 2.17606V6.27771C71.4106 5.64894 72.1369 5.27797 73.1366 5.27797C74.9716 5.27797 76.4774 6.85198 76.4774 8.89232ZM74.7106 8.89232C74.7106 7.73959 73.9037 6.96201 72.8076 6.96201C71.7114 6.96201 70.9213 7.74273 70.9213 8.89232C70.9213 10.0419 71.7292 10.8237 72.8076 10.8237C73.8859 10.8237 74.7106 10.043 74.7106 8.89232Z" fill="#262A3D"/>
<path d="M77.2718 2.71994L79.0376 2.17606V12.316H77.2718V2.71994Z" fill="#262A3D"/>
<path d="M79.8183 8.89232C79.8171 8.17544 80.0286 7.47431 80.4261 6.87774C80.8236 6.28117 81.3893 5.816 82.0514 5.54113C82.7135 5.26627 83.4422 5.19408 84.1454 5.33371C84.8485 5.47333 85.4944 5.8185 86.0013 6.32549C86.5081 6.83247 86.8531 7.47847 86.9925 8.18166C87.1319 8.88486 87.0595 9.61361 86.7845 10.2756C86.5094 10.9376 86.0441 11.5031 85.4474 11.9005C84.8507 12.2978 84.1495 12.5092 83.4326 12.5077C82.9565 12.5128 82.4842 12.4227 82.0433 12.2428C81.6024 12.0629 81.2019 11.7967 80.8653 11.46C80.5286 11.1232 80.2626 10.7227 80.0828 10.2817C79.903 9.84083 79.8131 9.36845 79.8183 8.89232ZM85.2948 8.89232C85.2948 7.78359 84.4869 7.00602 83.4326 7.00602C82.3784 7.00602 81.5841 7.78674 81.5841 8.89232C81.5841 9.9979 82.392 10.7786 83.4326 10.7786C84.4733 10.7786 85.2948 10.0021 85.2948 8.89232Z" fill="#262A3D"/>
<path d="M87.7313 8.89233C87.7313 6.85198 89.2645 5.27797 91.3457 5.27797C92.6881 5.27797 93.8513 5.98952 94.413 7.04375L92.8935 7.93451C92.6189 7.37281 92.03 7.01651 91.3321 7.01651C90.2778 7.01651 89.4971 7.79723 89.4971 8.89233C89.4971 9.98743 90.2778 10.7545 91.3321 10.7545C92.0447 10.7545 92.6326 10.4129 92.904 9.8512L94.4371 10.7273C94.1281 11.2741 93.6779 11.7279 93.1335 12.0413C92.5891 12.3547 91.9706 12.5161 91.3425 12.5088C89.2645 12.5077 87.7313 10.9327 87.7313 8.89233Z" fill="#262A3D"/>
<path d="M99.5123 12.316L97.0203 9.20776V12.316H95.2534V2.71994L97.0203 2.17606V8.48153L99.374 5.46974H101.482L98.7316 8.85145L101.566 12.316H99.5123Z" fill="#262A3D"/>
<path d="M108.623 8.11161V12.316H106.856V8.33377C106.856 7.40215 106.296 6.92324 105.501 6.92324C104.639 6.92324 103.994 7.4294 103.994 8.62091V12.316H102.229V5.46974H103.994V6.23579C104.405 5.6196 105.118 5.27797 106.035 5.27797C107.486 5.27797 108.623 6.29657 108.623 8.11161Z" fill="#262A3D"/>
<path d="M116.74 5.46974V12.316H114.975V11.508C114.481 12.1242 113.742 12.5077 112.743 12.5077C110.921 12.5077 109.415 10.9358 109.415 8.89233C109.415 6.84884 110.921 5.27797 112.743 5.27797C113.742 5.27797 114.481 5.66152 114.975 6.27771V5.46974H116.74ZM114.975 8.89233C114.975 7.73959 114.167 6.96201 113.071 6.96201C111.974 6.96201 111.184 7.74273 111.184 8.89233C111.184 10.0419 111.992 10.8237 113.071 10.8237C114.149 10.8237 114.975 10.043 114.975 8.89233Z" fill="#262A3D"/>
<path d="M121.344 7.16742V5.46975H119.796V3.45665L118.027 4.00053V10.0157C118.027 11.8643 118.866 12.5895 121.342 12.3212V10.7137C120.329 10.7692 119.794 10.7545 119.794 10.0157V7.16742H121.344Z" fill="#262A3D"/>
<path d="M122.582 5.46974H124.347V12.316H122.582V5.46974Z" fill="#262A3D"/>
<path d="M132.293 5.46974L129.691 12.316H127.678L125.077 5.46974H127.021L128.678 10.262L130.348 5.46974H132.293Z" fill="#262A3D"/>
<path d="M136.073 10.9075C136.757 10.9075 137.305 10.6204 137.607 10.2232L139.03 11.0448C138.387 11.9754 137.36 12.5119 136.046 12.5119C133.74 12.5119 132.294 10.94 132.294 8.89652C132.294 6.85303 133.761 5.28217 135.908 5.28217C137.935 5.28217 139.373 6.88447 139.373 8.89652C139.37 9.13886 139.346 9.38049 139.301 9.61856H134.143C134.389 10.5219 135.142 10.9075 136.073 10.9075ZM137.607 8.25099C137.387 7.26487 136.648 6.8677 135.908 6.8677C134.965 6.8677 134.321 7.37491 134.114 8.25099H137.607Z" fill="#262A3D"/>
</g>
<defs>
<linearGradient id="paint0_linear_13558_103869" x1="141.863" y1="6.82891" x2="146.782" y2="6.82891" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<linearGradient id="paint1_linear_13558_103869" x1="6973.93" y1="500.862" x2="7897.53" y2="500.862" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<clipPath id="clip0_13558_103869">
<rect width="82.8232" height="12" fill="white" transform="translate(69.0884 2)"/>
</clipPath>
</defs>
</svg>
`;

function getDevice() {
    if (typeof window !== 'undefined') {
        const parsed = bowser.getParser(window.navigator.userAgent);
        const os = parsed.getOS();
        const browser = parsed.getBrowser();
        const { type } = parsed.getPlatform();
        return {
            type: type,
            os: os,
            browser: browser
        };
    } else {
        return {
            type: null,
            os: null,
            browser: null
        };
    }
}
const notNullish = (value) => value != null;

function validEnsChain(chainId) {
    switch (chainId) {
        case '0x1':
        case '0x3':
        case '0x4':
        case '0x5':
            return true;
        default:
            return false;
    }
}

function isSVG(str) {
    return str.includes('<svg');
}

function shortenAddress(add) {
    return `${add.slice(0, 6)}...${add.slice(-4)}`;
}

function shortenDomain(domain) {
    return domain.length > 11 ?
        `${domain.slice(0, 4)}...${domain.slice(-6)}` :
        domain;
}
async function copyWalletAddress(text) {
    try {
        const copy = await navigator.clipboard.writeText(text);
        return copy;
    } catch (err) {
        console.error('Failed to copy: ', err);
    }
}
const toHexString = (val) => typeof val === 'number' ? `0x${val.toString(16)}` : val;

function chainIdToHex(chains) {
    return chains.map(({ id, ...rest }) => {
        const hexId = toHexString(id);
        return { id: hexId, ...rest };
    });
}

function gweiToWeiHex(gwei) {
    return `0x${(gwei * 1e9).toString(16)}`;
}
const chainIdToLabel = {
    '0x1': 'Ethereum',
    '0x3': 'Ropsten',
    '0x4': 'Rinkeby',
    '0x5': 'Goerli',
    '0x2a': 'Kovan',
    '0x38': 'Binance',
    '0x89': 'Polygon',
    '0xfa': 'Fantom',
    '0xa': 'Optimism',
    '0x45': 'Optimism Kovan',
    '0xa86a': 'Avalanche',
    '0xa4ec': 'Celo',
    '0x64': 'Gnosis',
    '0x63564C40': 'Harmony One',
    '0xa4b1': 'Arbitrum'
};
const networkToChainId = {
    main: '0x1',
    ropsten: '0x3',
    rinkeby: '0x4',
    goerli: '0x5',
    kovan: '0x2a',
    xdai: '0x64',
    'bsc-main': '0x38',
    'matic-main': '0x89',
    'fantom-main': '0xfa',
    'matic-mumbai': '0x80001'
};
const chainStyles = {
    '0x1': {
        icon: ethereumIcon,
        color: '#627EEA'
    },
    '0x3': {
        icon: ethereumIcon,
        color: '#627EEA'
    },
    '0x4': {
        icon: ethereumIcon,
        color: '#627EEA'
    },
    '0x5': {
        icon: ethereumIcon,
        color: '#627EEA'
    },
    '0x2a': {
        icon: ethereumIcon,
        color: '#627EEA'
    },
    '0x38': {
        icon: binanceIcon,
        color: '#F3BA2F'
    },
    '0x89': {
        icon: polygonIcon,
        color: '#8247E5'
    },
    '0xfa': {
        icon: fantomIcon,
        color: '#1969FF'
    },
    '0xa': {
        icon: optimismIcon,
        color: '#FF0420'
    },
    '0x45': {
        icon: optimismIcon,
        color: '#FF0420'
    },
    '0xa86a': {
        icon: avalancheIcon,
        color: '#E84142'
    },
    '0xa4ec': {
        icon: celoIcon,
        color: '#FBCC5C'
    },
    '0x64': {
        icon: gnosisIcon,
        color: '#04795B'
    },
    '0x63564C40': {
        icon: harmonyOneIcon,
        color: '#ffffff'
    },
    '0xa4b1': {
        icon: arbitrumIcon,
        color: '#33394B'
    }
};
const unrecognizedChainStyle = { icon: questionIcon, color: '#33394B' };

function getDefaultChainStyles(chainId) {
    return chainId ? chainStyles[chainId.toLowerCase()] : undefined;
}

function connectedToValidAppChain(walletConnectedChain, chains) {
    return !!chains.find(({ id, namespace }) => id === walletConnectedChain.id &&
        namespace === walletConnectedChain.namespace);
}
const defaultNotifyEventStyles = {
    pending: {
        backgroundColor: 'var(--onboard-primary-700, var(--primary-700))',
        borderColor: '#6370E5',
        eventIcon: hourglass
    },
    success: {
        backgroundColor: '#052E17',
        borderColor: 'var(--onboard-success-300, var(--success-300))',
        eventIcon: checkmark
    },
    error: {
        backgroundColor: '#FDB1B11A',
        borderColor: 'var(--onboard-danger-300, var(--danger-300))',
        eventIcon: errorIcon
    },
    hint: {
        backgroundColor: 'var(--onboard-gray-500, var(--gray-500))',
        borderColor: 'var(--onboard-gray-500, var(--gray-500))',
        iconColor: 'var(--onboard-gray-100, var(--gray-100))',
        eventIcon: infoIcon
    }
};
const wait$1 = (time) => new Promise(resolve => setTimeout(resolve, time));

let configuration = {
    svelteInstance: null,
    appMetadata: null,
    apiKey: null,
    device: getDevice(),
    initialWalletInit: [],
    gas: null,
    containerElements: { accountCenter: null },
    transactionPreview: null
};

function updateConfiguration(update) {
    configuration = {...configuration, ...update };
}

const APP_INITIAL_STATE = {
    wallets: [],
    walletModules: [],
    chains: [],
    accountCenter: {
        enabled: true,
        position: 'topRight',
        expanded: false,
        minimal: configuration.device.type === 'mobile'
    },
    notify: {
        enabled: true,
        transactionHandler: () => {},
        position: 'topRight',
        replacement: {
            gasPriceProbability: {
                speedup: 80,
                cancel: 95
            }
        }
    },
    notifications: [],
    locale: '',
    connect: {
        showSidebar: true
    }
};
const STORAGE_KEYS = {
    TERMS_AGREEMENT: 'onboard.js:agreement'
};
const MOBILE_WINDOW_WIDTH = 768;

const ADD_CHAINS = 'add_chains';
const RESET_STORE = 'reset_store';
const ADD_WALLET = 'add_wallet';
const UPDATE_WALLET = 'update_wallet';
const REMOVE_WALLET = 'remove_wallet';
const UPDATE_ACCOUNT = 'update_account';
const UPDATE_ACCOUNT_CENTER = 'update_account_center';
const UPDATE_CONNECT_MODAL = 'update_connect_modal';
const SET_WALLET_MODULES = 'set_wallet_modules';
const SET_LOCALE = 'set_locale';
const UPDATE_NOTIFY = 'update_notify';
const ADD_NOTIFICATION = 'add_notification';
const REMOVE_NOTIFICATION = 'remove_notification';
const UPDATE_ALL_WALLETS = 'update_balance';

function reducer(state, action) {
    const { type, payload } = action;
    switch (type) {
        case ADD_CHAINS:
            return {
                ...state,
                chains: [...state.chains, ...payload]
            };
        case ADD_WALLET:
            {
                const wallet = payload;
                const existingWallet = state.wallets.find(({ label }) => label === wallet.label);
                return {
                    ...state,
                    wallets: [
                        // add to front of wallets as it is now the primary wallet
                        existingWallet || payload,
                        // filter out wallet if it already existed
                        ...state.wallets.filter(({ label }) => label !== wallet.label)
                    ]
                };
            }
        case UPDATE_WALLET:
            {
                const update = payload;
                const { id, ...walletUpdate } = update;
                const updatedWallets = state.wallets.map(wallet => wallet.label === id ? {...wallet, ...walletUpdate } : wallet);
                return {
                    ...state,
                    wallets: updatedWallets
                };
            }
        case REMOVE_WALLET:
            {
                const update = payload;
                return {
                    ...state,
                    wallets: state.wallets.filter(({ label }) => label !== update.id)
                };
            }
        case UPDATE_ACCOUNT:
            {
                const update = payload;
                const { id, address, ...accountUpdate } = update;
                const updatedWallets = state.wallets.map(wallet => {
                    if (wallet.label === id) {
                        wallet.accounts = wallet.accounts.map(account => {
                            if (account.address === address) {
                                return {...account, ...accountUpdate };
                            }
                            return account;
                        });
                    }
                    return wallet;
                });
                return {
                    ...state,
                    wallets: updatedWallets
                };
            }
        case UPDATE_ALL_WALLETS:
            {
                const updatedWallets = payload;
                return {
                    ...state,
                    wallets: updatedWallets
                };
            }
        case UPDATE_CONNECT_MODAL:
            {
                const update = payload;
                return {
                    ...state,
                    connect: {
                        ...state.connect,
                        ...update
                    }
                };
            }
        case UPDATE_ACCOUNT_CENTER:
            {
                const update = payload;
                return {
                    ...state,
                    accountCenter: {
                        ...state.accountCenter,
                        ...update
                    }
                };
            }
        case UPDATE_NOTIFY:
            {
                const update = payload;
                return {
                    ...state,
                    notify: {
                        ...state.notify,
                        ...update
                    }
                };
            }
        case ADD_NOTIFICATION:
            {
                const update = payload;
                const notificationsUpdate = [...state.notifications];
                const notificationExistsIndex = notificationsUpdate.findIndex(({ id }) => id === update.id);
                if (notificationExistsIndex !== -1) {
                    // if notification with same id, replace it with update
                    notificationsUpdate[notificationExistsIndex] = update;
                } else {
                    // otherwise add it to the beginning of array as new notification
                    notificationsUpdate.unshift(update);
                }
                return {
                    ...state,
                    notifications: notificationsUpdate
                };
            }
        case REMOVE_NOTIFICATION:
            {
                const id = payload;
                return {
                    ...state,
                    notifications: state.notifications.filter(notification => notification.id !== id)
                };
            }
        case SET_WALLET_MODULES:
            {
                return {
                    ...state,
                    walletModules: payload
                };
            }
        case SET_LOCALE:
            {
                // Set the locale in the svelte-i18n internal state
                locale$1.set(payload);
                return {
                    ...state,
                    locale: payload
                };
            }
        case RESET_STORE:
            return APP_INITIAL_STATE;
        default:
            throw new Error(`Unknown type: ${type} in appStore reducer`);
    }
}
const _store = new BehaviorSubject(APP_INITIAL_STATE);
const _stateUpdates = new Subject();
_stateUpdates.subscribe(_store);

function dispatch$1(action) {
    const state = _store.getValue();
    _stateUpdates.next(reducer(state, action));
}

function select(stateKey) {
    if (!stateKey)
        return _stateUpdates.asObservable();
    const validStateKeys = Object.keys(_store.getValue());
    if (!validStateKeys.includes(String(stateKey))) {
        throw new Error(`key: ${stateKey} does not exist on this store`);
    }
    return _stateUpdates
        .asObservable()
        .pipe(distinctUntilKeyChanged(stateKey), pluck(stateKey), filter(notNullish));
}

function get() {
    return _store.getValue();
}
const state = {
    select,
    get
};

const unknownObject = Joi.object().unknown();
const connectedChain = Joi.object({
    namespace: chainNamespaceValidation.required(),
    id: chainIdValidation.required()
});
const ens = Joi.any().allow(Joi.object({
    name: Joi.string().required(),
    avatar: Joi.string(),
    contentHash: Joi.any().allow(Joi.string(), null),
    getText: Joi.function().arity(1).required()
}), null);
const uns = Joi.any().allow(Joi.object({
    name: Joi.string().required()
}), null);
const balance = Joi.any().allow(Joi.object({
    eth: Joi.number()
}).unknown(), null);
const account = Joi.object({
    address: Joi.string().required(),
    ens,
    uns,
    balance
});
const chains = Joi.array()
    .items(chainValidation)
    .unique((a, b) => a.id === b.id)
    .error(e => {
        if (e[0].code === 'array.unique') {
            return new Error(`There is a duplicate Chain ID in your Onboard Chains array: ${e}`);
        }
        return new Error(`${e}`);
    });
const accounts = Joi.array().items(account);
const wallet = Joi.object({
        label: Joi.string(),
        icon: Joi.string(),
        provider: unknownObject,
        instance: unknownObject,
        accounts,
        chains: Joi.array().items(connectedChain)
    })
    .required()
    .error(new Error('wallet must be defined'));
const wallets = Joi.array().items(wallet);
const recommendedWallet = Joi.object({
    name: Joi.string().required(),
    url: Joi.string().uri().required()
});
const agreement = Joi.object({
    version: Joi.string().required(),
    termsUrl: Joi.string().uri(),
    privacyUrl: Joi.string().uri()
});
const appMetadata = Joi.object({
    name: Joi.string().required(),
    description: Joi.string().required(),
    icon: Joi.string().required(),
    logo: Joi.string(),
    gettingStartedGuide: Joi.string(),
    email: Joi.string(),
    appUrl: Joi.string(),
    explore: Joi.string(),
    recommendedInjectedWallets: Joi.array().items(recommendedWallet),
    agreement
});
Joi.object({
    label: Joi.string().required(),
    getInfo: Joi.function().arity(1).required(),
    getInterface: Joi.function().arity(1).required()
});
const walletInit = Joi.array().items(Joi.function()).required();
const locale = Joi.string();
const commonPositions = Joi.string().valid('topRight', 'bottomRight', 'bottomLeft', 'topLeft');
const gasPriceProbabilities = [70, 80, 90, 95, 99];
const notify$1 = Joi.object({
    transactionHandler: Joi.function(),
    enabled: Joi.boolean(),
    position: commonPositions,
    replacement: Joi.object({
        gasPriceProbability: Joi.object({
            speedup: Joi.number().valid(...gasPriceProbabilities),
            cancel: Joi.number().valid(...gasPriceProbabilities)
        })
    })
});
const notifyOptions = Joi.object({
    desktop: notify$1,
    mobile: notify$1
});
const accountCenterInitOptions = Joi.object({
    enabled: Joi.boolean(),
    position: commonPositions,
    minimal: Joi.boolean(),
    containerElement: Joi.string()
});
const accountCenter$1 = Joi.object({
    enabled: Joi.boolean(),
    position: commonPositions,
    expanded: Joi.boolean(),
    minimal: Joi.boolean(),
    containerElement: Joi.string()
});
const connectModalOptions = Joi.object({
    showSidebar: Joi.boolean()
});
const containerElements = Joi.object({
    accountCenter: Joi.string()
});
const initOptions = Joi.object({
    wallets: walletInit,
    chains: chains.required(),
    appMetadata: appMetadata,
    i18n: Joi.object().unknown(),
    apiKey: Joi.string(),
    accountCenter: Joi.object({
        desktop: accountCenterInitOptions,
        mobile: accountCenterInitOptions
    }),
    notify: [notifyOptions, notify$1],
    gas: Joi.object({
        get: Joi.function().required(),
        stream: Joi.function().required()
    }),
    connect: connectModalOptions,
    containerElements: containerElements,
    transactionPreview: Joi.object({
        patchProvider: Joi.function().required(),
        init: Joi.function().required()
    })
});
const connectOptions = Joi.object({
    autoSelect: Joi.alternatives()
        .try(Joi.object({
            label: Joi.string().required(),
            disableModals: Joi.boolean()
        }), Joi.string())
        .required()
});
const disconnectOptions = Joi.object({
    label: Joi.string().required()
}).required();
const setChainOptions = Joi.object({
    chainId: chainIdValidation.required(),
    chainNamespace: chainNamespaceValidation,
    wallet: Joi.string()
});
const customNotificationUpdate = Joi.object({
    key: Joi.string().required(),
    type: Joi.string().allow('pending', 'error', 'success', 'hint'),
    eventCode: Joi.string(),
    message: Joi.string().required(),
    id: Joi.string().required(),
    autoDismiss: Joi.number(),
    onClick: Joi.function(),
    link: Joi.string()
});
const preflightNotifications$1 = Joi.object({
    sendTransaction: Joi.function(),
    estimateGas: Joi.function(),
    gasPrice: Joi.function(),
    balance: Joi.alternatives(Joi.string(), Joi.number()),
    txDetails: Joi.object({
        value: Joi.alternatives(Joi.string(), Joi.number()),
        to: Joi.string(),
        from: Joi.string()
    }),
    txApproveReminderTimeout: Joi.number()
});
const customNotification$1 = Joi.object({
    key: Joi.string(),
    type: Joi.string().allow('pending', 'error', 'success', 'hint'),
    eventCode: Joi.string(),
    message: Joi.string(),
    id: Joi.string(),
    autoDismiss: Joi.number(),
    onClick: Joi.function(),
    link: Joi.string()
});
const notification = Joi.object({
    id: Joi.string().required(),
    key: Joi.string().required(),
    type: Joi.string().allow('pending', 'error', 'success', 'hint').required(),
    eventCode: Joi.string().required(),
    message: Joi.string().required(),
    autoDismiss: Joi.number().required(),
    network: Joi.string().required(),
    startTime: Joi.number(),
    onClick: Joi.function(),
    link: Joi.string()
});
const transactionHandlerReturn = Joi.any().allow(customNotificationUpdate, Joi.boolean().allow(false));

function validateWallet(data) {
    return validate(wallet, data);
}

function validateInitOptions(data) {
    return validate(initOptions, data);
}

function validateConnectOptions(data) {
    return validate(connectOptions, data);
}

function validateDisconnectOptions(data) {
    return validate(disconnectOptions, data);
}

function validateString(str, label) {
    return validate(Joi.string()
        .required()
        .label(label || 'value'), str);
}

function validateSetChainOptions(data) {
    return validate(setChainOptions, data);
}

function validateAccountCenterUpdate(data) {
    return validate(accountCenter$1, data);
}

function validateConnectModalUpdate(data) {
    return validate(connectModalOptions, data);
}

function validateWalletInit(data) {
    return validate(walletInit, data);
}

function validateLocale(data) {
    return validate(locale, data);
}

function validateNotify(data) {
    return validate(notify$1, data);
}

function validateNotifyOptions(data) {
    return validate(notifyOptions, data);
}

function validateTransactionHandlerReturn(data) {
    return validate(transactionHandlerReturn, data);
}

function validateNotification(data) {
    return validate(notification, data);
}

function validatePreflightNotifications(data) {
    return validate(preflightNotifications$1, data);
}

function validateCustomNotificationUpdate(data) {
    return validate(customNotificationUpdate, data);
}

function validateCustomNotification(data) {
    return validate(customNotification$1, data);
}

function validateUpdateBalances(data) {
    return validate(wallets, data);
}

function addChains(chains) {
    // chains are validated on init
    const action = {
        type: ADD_CHAINS,
        payload: chains.map(({ namespace = 'evm', id, rpcUrl, ...rest }) => ({
            ...rest,
            namespace,
            id: id.toLowerCase(),
            rpcUrl: rpcUrl.trim()
        }))
    };
    dispatch$1(action);
}

function addWallet(wallet) {
    const error = validateWallet(wallet);
    if (error) {
        console.error(error);
        throw error;
    }
    const action = {
        type: ADD_WALLET,
        payload: wallet
    };
    dispatch$1(action);
}

function updateWallet(id, update) {
    const error = validateWallet(update);
    if (error) {
        console.error(error);
        throw error;
    }
    const action = {
        type: UPDATE_WALLET,
        payload: {
            id,
            ...update
        }
    };
    dispatch$1(action);
}

function removeWallet(id) {
    const error = validateString(id, 'wallet id');
    if (error) {
        throw error;
    }
    const action = {
        type: REMOVE_WALLET,
        payload: {
            id
        }
    };
    dispatch$1(action);
}

function setPrimaryWallet(wallet, address) {
    const error = validateWallet(wallet) || (address && validateString(address, 'address'));
    if (error) {
        throw error;
    }
    // if also setting the primary account
    if (address) {
        const account = wallet.accounts.find(ac => ac.address === address);
        if (account) {
            wallet.accounts = [
                account,
                ...wallet.accounts.filter(({ address }) => address !== account.address)
            ];
        }
    }
    // add wallet will set it to first wallet since it already exists
    addWallet(wallet);
}

function updateAccount(id, address, update) {
    const action = {
        type: UPDATE_ACCOUNT,
        payload: {
            id,
            address,
            ...update
        }
    };
    dispatch$1(action);
}

function updateAccountCenter(update) {
    const error = validateAccountCenterUpdate(update);
    if (error) {
        throw error;
    }
    const action = {
        type: UPDATE_ACCOUNT_CENTER,
        payload: update
    };
    dispatch$1(action);
}

function updateConnectModal(update) {
    const error = validateConnectModalUpdate(update);
    if (error) {
        throw error;
    }
    const action = {
        type: UPDATE_CONNECT_MODAL,
        payload: update
    };
    dispatch$1(action);
}

function updateNotify(update) {
    const error = validateNotify(update);
    if (error) {
        throw error;
    }
    const action = {
        type: UPDATE_NOTIFY,
        payload: update
    };
    dispatch$1(action);
}

function addNotification(notification) {
    const error = validateNotification(notification);
    if (error) {
        throw error;
    }
    const action = {
        type: ADD_NOTIFICATION,
        payload: notification
    };
    dispatch$1(action);
}

function addCustomNotification(notification) {
    const customNotificationError = validateCustomNotificationUpdate(notification);
    if (customNotificationError) {
        throw customNotificationError;
    }
    const action = {
        type: ADD_NOTIFICATION,
        payload: notification
    };
    dispatch$1(action);
}

function customNotification(updatedNotification) {
    const customNotificationError = validateCustomNotification(updatedNotification);
    if (customNotificationError) {
        throw customNotificationError;
    }
    const customIdKey = `customNotification-${nanoid()}`;
    const notification = {
        ...updatedNotification,
        id: customIdKey,
        key: customIdKey
    };
    addCustomNotification(notification);
    const dismiss = () => removeNotification(notification.id);
    const update = (notificationUpdate) => {
        const customNotificationError = validateCustomNotification(updatedNotification);
        if (customNotificationError) {
            throw customNotificationError;
        }
        const notificationAfterUpdate = {
            ...notificationUpdate,
            id: notification.id,
            key: notification.key
        };
        addCustomNotification(notificationAfterUpdate);
        return {
            dismiss,
            update
        };
    };
    addCustomNotification(notification);
    return {
        dismiss,
        update
    };
}

function removeNotification(id) {
    if (typeof id !== 'string') {
        throw new Error('Notification id must be of type string');
    }
    const action = {
        type: REMOVE_NOTIFICATION,
        payload: id
    };
    dispatch$1(action);
}

function resetStore() {
    const action = {
        type: RESET_STORE
    };
    dispatch$1(action);
}

function setWalletModules(wallets) {
    const error = validateWalletInit(wallets);
    if (error) {
        throw error;
    }
    const modules = initializeWalletModules(wallets);
    const dedupedWallets = uniqueWalletsByLabel(modules);
    const action = {
        type: SET_WALLET_MODULES,
        payload: dedupedWallets
    };
    dispatch$1(action);
}

function setLocale(locale) {
    const error = validateLocale(locale);
    if (error) {
        throw error;
    }
    const action = {
        type: SET_LOCALE,
        payload: locale
    };
    dispatch$1(action);
}

function updateAllWallets(wallets) {
    const error = validateUpdateBalances(wallets);
    if (error) {
        throw error;
    }
    const action = {
        type: UPDATE_ALL_WALLETS,
        payload: wallets
    };
    dispatch$1(action);
}
// ==== HELPERS ==== //
function initializeWalletModules(modules) {
    const { device } = configuration;
    return modules.reduce((acc, walletInit) => {
        const initialized = walletInit({ device });
        if (initialized) {
            // injected wallets is an array of wallets
            acc.push(...(Array.isArray(initialized) ? initialized : [initialized]));
        }
        return acc;
    }, []);
}

function uniqueWalletsByLabel(walletModuleList) {
    return walletModuleList.filter((wallet, i) => walletModuleList.findIndex((innerWallet) => innerWallet.label === wallet.label) === i);
}

function noop() {}
const identity = x => x;

function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
// Adapted from https://github.com/then/is-promise/blob/master/index.js
// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE
function is_promise(value) {
    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
}

function run(fn) {
    return fn();
}

function blank_object() {
    return Object.create(null);
}

function run_all(fns) {
    fns.forEach(run);
}

function is_function(thing) {
    return typeof thing === 'function';
}

function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
let src_url_equal_anchor;

function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
}

function is_empty(obj) {
    return Object.keys(obj).length === 0;
}

function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}

function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}

function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn ?
        assign($$scope.ctx.slice(), definition[1](fn(ctx))) :
        $$scope.ctx;
}

function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}

function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}

function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}

function null_to_empty(value) {
    return value == null ? '' : value;
}

const is_client = typeof window !== 'undefined';
let now = is_client ?
    () => window.performance.now() :
    () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();

function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

function append(target, node) {
    target.appendChild(node);
}

function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}

function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}

function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element.sheet;
}

function append_stylesheet(node, style) {
    append(node.head || node, style);
    return style.sheet;
}

function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}

function detach(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}

function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}

function element(name) {
    return document.createElement(name);
}

function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}

function text(data) {
    return document.createTextNode(data);
}

function space() {
    return text(' ');
}

function empty() {
    return text('');
}

function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}

function stop_propagation(fn) {
    return function(event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}

function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}

function children(element) {
    return Array.from(element.childNodes);
}

function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}

function set_style(node, key, value, important) {
    if (value === null) {
        node.style.removeProperty(key);
    } else {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
}

function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    select.selectedIndex = -1; // no option should be selected
}

function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}

function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
}
class HtmlTag {
    constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            if (this.is_svg)
                this.e = svg_element(target.nodeName);
            else
                this.e = element(target.nodeName);
            this.t = target;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}

function construct_svelte_component(component, props) {
    return new component(props);
}

// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
const managed_styles = new Map();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash$3(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}

function create_style_information(doc, node) {
    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
    managed_styles.set(doc, info);
    return info;
}

function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash$3(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
    if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        managed_styles.forEach(info => {
            const { ownerNode } = info.stylesheet;
            // there is no ownerNode if it runs on jsdom.
            if (ownerNode)
                detach(ownerNode);
        });
        managed_styles.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
/**
 * Schedules a callback to run immediately before the component is updated after any state change.
 *
 * The first time the callback runs will be before the initial `onMount`
 *
 * https://svelte.dev/docs#run-time-svelte-beforeupdate
 */
function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
}
/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs#run-time-svelte-onmount
 */
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
/**
 * Schedules a callback to run immediately after the component has been updated.
 *
 * The first time the callback runs will be after the initial `onMount`
 */
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs#run-time-svelte-ondestroy
 */
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();
let flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
    // Do not reenter flush while dirty components are updated, as this can
    // result in an infinite loop. Instead, let the inner flush handle it.
    // Reentrancy is ok afterwards for bindings etc.
    if (flushidx !== 0) {
        return;
    }
    const saved_component = current_component;
    do {
        // first, call beforeUpdate functions
        // and update components
        try {
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
        }
        catch (e) {
            // reset dirty state to not end up in a deadlocked state and then rethrow
            dirty_components.length = 0;
            flushidx = 0;
            throw e;
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
    else if (callback) {
        callback();
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    const options = { direction: 'in' };
    let config = fn(node, params, options);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config(options);
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    const options = { direction: 'out' };
    let config = fn(node, params, options);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config(options);
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}
function create_bidirectional_transition(node, fn, params, intro) {
    const options = { direction: 'both' };
    let config = fn(node, params, options);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = (program.b - t);
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config(options);
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function handle_promise(promise, info) {
    const token = info.token = {};
    function update(type, index, key, value) {
        if (info.token !== token)
            return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== undefined) {
            child_ctx = child_ctx.slice();
            child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
            if (info.blocks) {
                info.blocks.forEach((block, i) => {
                    if (i !== index && block) {
                        group_outros();
                        transition_out(block, 1, 1, () => {
                            if (info.blocks[i] === block) {
                                info.blocks[i] = null;
                            }
                        });
                        check_outros();
                    }
                });
            }
            else {
                info.block.d(1);
            }
            block.c();
            transition_in(block, 1);
            block.m(info.mount(), info.anchor);
            needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
            info.blocks[index] = block;
        if (needs_flush) {
            flush();
        }
    }
    if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
            set_current_component(current_component);
            update(info.then, 1, info.value, value);
            set_current_component(null);
        }, error => {
            set_current_component(current_component);
            update(info.catch, 2, info.error, error);
            set_current_component(null);
            if (!info.hasCatch) {
                throw error;
            }
        });
        // if we previously had a then/catch block, destroy it
        if (info.current !== info.pending) {
            update(info.pending, 0);
            return true;
        }
    }
    else {
        if (info.current !== info.then) {
            update(info.then, 1, info.value, promise);
            return true;
        }
        info.resolved = promise;
    }
}
function update_await_block_branch(info, ctx, dirty) {
    const child_ctx = ctx.slice();
    const { resolved } = info;
    if (info.current === info.then) {
        child_ctx[info.value] = resolved;
    }
    if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
    }
    info.block.p(child_ctx, dirty);
}

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
            // if the component was destroyed immediately
            // it will update the `$$.on_destroy` reference to `null`.
            // the destructured on_destroy may still reference to the old array
            if (component.$$.on_destroy) {
                component.$$.on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        if (!is_function(callback)) {
            return noop;
        }
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const reset$ = new Subject();
const disconnectWallet$ = new Subject();
const connectWallet$ = new BehaviorSubject({ inProgress: false, actionRequired: '' });
const switchChainModal$ = new BehaviorSubject(null);
const wallets$ = state.select('wallets').pipe(shareReplay(1));
// reset logic
reset$.pipe(withLatestFrom(wallets$), pluck('1')).subscribe(wallets => {
    // disconnect all wallets
    wallets.forEach(({ label }) => {
        disconnectWallet$.next(label);
    });
    resetStore();
});
// keep transactions for all notifications for replacement actions
const transactions$ = new BehaviorSubject([]);
function updateTransaction(tx) {
    const currentTransactions = transactions$.getValue();
    const txIndex = currentTransactions.findIndex(({ hash }) => hash === tx.hash);
    if (txIndex !== -1) {
        const updatedTransactions = currentTransactions.map((val, i) => i === txIndex ? tx : val);
        transactions$.next(updatedTransactions);
    }
    else {
        transactions$.next([...currentTransactions, tx]);
    }
}
function removeTransaction(hash) {
    const currentTransactions = transactions$.getValue();
    transactions$.next(currentTransactions.filter(tx => tx.hash !== hash));
}
defer(() => {
    const subject = new Subject();
    onMount(() => {
        subject.next();
    });
    return subject.asObservable().pipe(take(1));
});
const onDestroy$ = defer(() => {
    const subject = new Subject();
    onDestroy(() => {
        subject.next();
    });
    return subject.asObservable().pipe(take(1));
});
defer(() => {
    const subject = new Subject();
    afterUpdate(() => {
        subject.next();
    });
    return subject.asObservable().pipe(takeUntil(onDestroy$));
});
defer(() => {
    const subject = new Subject();
    beforeUpdate(() => {
        subject.next();
    });
    return subject.asObservable().pipe(takeUntil(onDestroy$));
});

async function connect$1(options) {
    if (options) {
        const error = validateConnectOptions(options);
        if (error) {
            throw error;
        }
    }
    const { chains } = state.get();
    // Wallets require the chains for initializing providers,
    // so we must ensure at least one is set
    if (!chains.length)
        throw new Error('At least one chain must be set before attempting to connect a wallet');
    const { autoSelect } = options || {
        autoSelect: { label: '', disableModals: false }
    };
    // if auto selecting, wait until next event loop
    if (autoSelect && (typeof autoSelect === 'string' || autoSelect.label)) {
        await wait$1(50);
    }
    // first time calling connect, so initialize and set wallet modules
    if (!state.get().walletModules.length) {
        setWalletModules(configuration.initialWalletInit);
    }
    connectWallet$.next({
        autoSelect: typeof autoSelect === 'string'
            ? { label: autoSelect, disableModals: false }
            : autoSelect,
        inProgress: true
    });
    const result$ = connectWallet$.pipe(filter(({ inProgress, actionRequired }) => inProgress === false && !actionRequired), withLatestFrom(wallets$), pluck(1));
    return firstValueFrom(result$);
}

var connect = {
	selectingWallet: {
		header: "Available Wallets",
		sidebar: {
			heading: "Get Started",
			subheading: "Connect your wallet",
			paragraph: "Connecting your wallet is like “logging in” to Web3. Select your wallet from the options to get started."
		},
		recommendedWalletsPart1: "{app} only supports",
		recommendedWalletsPart2: "on this platform. Please use or install one of the supported wallets to continue",
		installWallet: "You do not have any wallets installed that {app} supports, please use a supported wallet",
		agreement: {
			agree: "I agree to the",
			terms: "Terms & Conditions",
			and: "and",
			privacy: "Privacy Policy"
		}
	},
	connectingWallet: {
		header: "{connectionRejected, select, false {Connecting to {wallet}...} other {Connection Rejected}}",
		sidebar: {
			subheading: "Approve Connection",
			paragraph: "Please approve the connection in your wallet and authorize access to continue."
		},
		mainText: "Connecting...",
		paragraph: "Make sure to select all accounts that you want to grant access to.",
		previousConnection: "{wallet} already has a pending connection request, please open the {wallet} app to login and connect.",
		rejectedText: "Connection Rejected!",
		rejectedCTA: "Click here to try again",
		primaryButton: "Back to wallets"
	},
	connectedWallet: {
		header: "Connection Successful",
		sidebar: {
			subheading: "Connection Successful!",
			paragraph: "Your wallet is now connected to {app}"
		},
		mainText: "Connected"
	}
};
var modals = {
	actionRequired: {
		heading: "Action required in {wallet}",
		paragraph: "Please switch the active account in your wallet.",
		linkText: "Learn more.",
		buttonText: "Okay"
	},
	switchChain: {
		heading: "Switch Chain",
		paragraph1: "{app} requires that you switch your wallet to the {nextNetworkName} network to continue.",
		paragraph2: "*Some wallets may not support changing networks. If you can not change networks in your wallet you may consider switching to a different wallet."
	},
	confirmDisconnectAll: {
		heading: "Disconnect all Wallets",
		description: "Are you sure that you would like to disconnect all your wallets?",
		confirm: "Confirm",
		cancel: "Cancel"
	}
};
var accountCenter = {
	connectAnotherWallet: "Connect another Wallet",
	disconnectAllWallets: "Disconnect all Wallets",
	currentNetwork: "Current Network",
	appInfo: "App Info",
	learnMore: "Learn More",
	gettingStartedGuide: "Getting Started Guide",
	smartContracts: "Smart Contract(s)",
	explore: "Explore",
	backToApp: "Back to dapp",
	poweredBy: "",
	addAccount: "Add Account",
	setPrimaryAccount: "Set Primary Account",
	disconnectWallet: "Disconnect Wallet",
	copyAddress: "Copy Wallet address"
};
var notify = {
	transaction: {
		txRequest: "Your transaction is waiting for you to confirm",
		nsfFail: "You have insufficient funds for this transaction",
		txUnderpriced: "The gas price for your transaction is too low, try a higher gas price",
		txRepeat: "This could be a repeat transaction",
		txAwaitingApproval: "You have a previous transaction waiting for you to confirm",
		txConfirmReminder: "Please confirm your transaction to continue",
		txSendFail: "You rejected the transaction",
		txSent: "Your transaction has been sent to the network",
		txStallPending: "Your transaction has stalled before it was sent, please try again",
		txStuck: "Your transaction is stuck due to a nonce gap",
		txPool: "Your transaction has started",
		txStallConfirmed: "Your transaction has stalled and hasn't been confirmed",
		txSpeedUp: "Your transaction has been sped up",
		txCancel: "Your transaction is being canceled",
		txFailed: "Your transaction has failed",
		txConfirmed: "Your transaction has succeeded",
		txError: "Oops something went wrong, please try again",
		txReplaceError: "There was an error replacing your transaction, please try again"
	},
	watched: {
		txPool: "Your account is {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
		txSpeedUp: "Transaction for {formattedValue} {asset} {preposition} {counterpartyShortened} has been sped up",
		txCancel: "Transaction for {formattedValue} {asset} {preposition} {counterpartyShortened} has been canceled",
		txConfirmed: "Your account successfully {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
		txFailed: "Your account failed to {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
		txStuck: "Your transaction is stuck due to a nonce gap"
	},
	time: {
		minutes: "min",
		seconds: "sec"
	}
};
var en = {
	connect: connect,
	modals: modals,
	accountCenter: accountCenter,
	notify: notify
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
				var args = [null];
				args.push.apply(args, arguments);
				var Ctor = Function.bind.apply(f, args);
				return new Ctor();
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var build = {};

var Resolution$1 = {};

var bnExports$1 = {};
var bn$1 = {
  get exports(){ return bnExports$1; },
  set exports(v){ bnExports$1 = v; },
};

var _nodeResolve_empty = {};

var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': _nodeResolve_empty
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
	      Buffer = window.Buffer;
	    } else {
	      Buffer = require$$0$2.Buffer;
	    }
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	      this.negative = 1;
	    }

	    if (start < number.length) {
	      if (base === 16) {
	        this._parseHex(number, start, endian);
	      } else {
	        this._parseBase(number, base, start);
	        if (endian === 'le') {
	          this._initArray(this.toArray(), base, endian);
	        }
	      }
	    }
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [ number & 0x3ffffff ];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [ 0 ];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this.strip();
	  };

	  function parseHex4Bits (string, index) {
	    var c = string.charCodeAt(index);
	    // 'A' - 'F'
	    if (c >= 65 && c <= 70) {
	      return c - 55;
	    // 'a' - 'f'
	    } else if (c >= 97 && c <= 102) {
	      return c - 87;
	    // '0' - '9'
	    } else {
	      return (c - 48) & 0xf;
	    }
	  }

	  function parseHexByte (string, lowerBound, index) {
	    var r = parseHex4Bits(string, index);
	    if (index - 1 >= lowerBound) {
	      r |= parseHex4Bits(string, index - 1) << 4;
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start, endian) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    // 24-bits chunks
	    var off = 0;
	    var j = 0;

	    var w;
	    if (endian === 'be') {
	      for (i = number.length - 1; i >= start; i -= 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    } else {
	      var parseLength = number.length - start;
	      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    }

	    this.strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        r += c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        r += c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r += c;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [ 0 ];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    this.strip();
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype.strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  BN.prototype.inspect = function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  };

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16);
	  };

	  BN.prototype.toBuffer = function toBuffer (endian, length) {
	    assert(typeof Buffer !== 'undefined');
	    return this.toArrayLike(Buffer, endian, length);
	  };

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    this.strip();
	    var littleEndian = endian === 'le';
	    var res = new ArrayType(reqLength);

	    var b, i;
	    var q = this.clone();
	    if (!littleEndian) {
	      // Assume big-endian
	      for (i = 0; i < reqLength - byteLength; i++) {
	        res[i] = 0;
	      }

	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[reqLength - i - 1] = b;
	      }
	    } else {
	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[i] = b;
	      }

	      for (; i < reqLength; i++) {
	        res[i] = 0;
	      }
	    }

	    return res;
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this.strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this.strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this.strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this.strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this.strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this.strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  function jumboMulTo (self, num, out) {
	    var fftm = new FFTM();
	    return fftm.mulp(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Cooley-Tukey algorithm for FFT
	  // slightly revisited to rely on looping instead of recursion

	  function FFTM (x, y) {
	    this.x = x;
	    this.y = y;
	  }

	  FFTM.prototype.makeRBT = function makeRBT (N) {
	    var t = new Array(N);
	    var l = BN.prototype._countBits(N) - 1;
	    for (var i = 0; i < N; i++) {
	      t[i] = this.revBin(i, l, N);
	    }

	    return t;
	  };

	  // Returns binary-reversed representation of `x`
	  FFTM.prototype.revBin = function revBin (x, l, N) {
	    if (x === 0 || x === N - 1) return x;

	    var rb = 0;
	    for (var i = 0; i < l; i++) {
	      rb |= (x & 1) << (l - i - 1);
	      x >>= 1;
	    }

	    return rb;
	  };

	  // Performs "tweedling" phase, therefore 'emulating'
	  // behaviour of the recursive algorithm
	  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
	    for (var i = 0; i < N; i++) {
	      rtws[i] = rws[rbt[i]];
	      itws[i] = iws[rbt[i]];
	    }
	  };

	  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
	    this.permute(rbt, rws, iws, rtws, itws, N);

	    for (var s = 1; s < N; s <<= 1) {
	      var l = s << 1;

	      var rtwdf = Math.cos(2 * Math.PI / l);
	      var itwdf = Math.sin(2 * Math.PI / l);

	      for (var p = 0; p < N; p += l) {
	        var rtwdf_ = rtwdf;
	        var itwdf_ = itwdf;

	        for (var j = 0; j < s; j++) {
	          var re = rtws[p + j];
	          var ie = itws[p + j];

	          var ro = rtws[p + j + s];
	          var io = itws[p + j + s];

	          var rx = rtwdf_ * ro - itwdf_ * io;

	          io = rtwdf_ * io + itwdf_ * ro;
	          ro = rx;

	          rtws[p + j] = re + ro;
	          itws[p + j] = ie + io;

	          rtws[p + j + s] = re - ro;
	          itws[p + j + s] = ie - io;

	          /* jshint maxdepth : false */
	          if (j !== l) {
	            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

	            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
	            rtwdf_ = rx;
	          }
	        }
	      }
	    }
	  };

	  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
	    var N = Math.max(m, n) | 1;
	    var odd = N & 1;
	    var i = 0;
	    for (N = N / 2 | 0; N; N = N >>> 1) {
	      i++;
	    }

	    return 1 << i + 1 + odd;
	  };

	  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
	    if (N <= 1) return;

	    for (var i = 0; i < N / 2; i++) {
	      var t = rws[i];

	      rws[i] = rws[N - i - 1];
	      rws[N - i - 1] = t;

	      t = iws[i];

	      iws[i] = -iws[N - i - 1];
	      iws[N - i - 1] = -t;
	    }
	  };

	  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
	    var carry = 0;
	    for (var i = 0; i < N / 2; i++) {
	      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
	        Math.round(ws[2 * i] / N) +
	        carry;

	      ws[i] = w & 0x3ffffff;

	      if (w < 0x4000000) {
	        carry = 0;
	      } else {
	        carry = w / 0x4000000 | 0;
	      }
	    }

	    return ws;
	  };

	  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
	    var carry = 0;
	    for (var i = 0; i < len; i++) {
	      carry = carry + (ws[i] | 0);

	      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
	      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
	    }

	    // Pad with zeroes
	    for (i = 2 * len; i < N; ++i) {
	      rws[i] = 0;
	    }

	    assert(carry === 0);
	    assert((carry & ~0x1fff) === 0);
	  };

	  FFTM.prototype.stub = function stub (N) {
	    var ph = new Array(N);
	    for (var i = 0; i < N; i++) {
	      ph[i] = 0;
	    }

	    return ph;
	  };

	  FFTM.prototype.mulp = function mulp (x, y, out) {
	    var N = 2 * this.guessLen13b(x.length, y.length);

	    var rbt = this.makeRBT(N);

	    var _ = this.stub(N);

	    var rws = new Array(N);
	    var rwst = new Array(N);
	    var iwst = new Array(N);

	    var nrws = new Array(N);
	    var nrwst = new Array(N);
	    var niwst = new Array(N);

	    var rmws = out.words;
	    rmws.length = N;

	    this.convert13b(x.words, x.length, rws, N);
	    this.convert13b(y.words, y.length, nrws, N);

	    this.transform(rws, _, rwst, iwst, N, rbt);
	    this.transform(nrws, _, nrwst, niwst, N, rbt);

	    for (var i = 0; i < N; i++) {
	      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
	      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
	      rwst[i] = rx;
	    }

	    this.conjugate(rwst, iwst, N);
	    this.transform(rwst, iwst, rmws, _, N, rbt);
	    this.conjugate(rmws, _, N);
	    this.normalize13b(rmws, N);

	    out.negative = x.negative ^ y.negative;
	    out.length = x.length + y.length;
	    return out.strip();
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this.strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) < num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this.strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this.strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this.strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q.strip();
	    }
	    a.strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modn = function modn (num) {
	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return acc;
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    return this.strip();
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this.strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      if (r.strip !== undefined) {
	        // r is BN v4 instance
	        r.strip();
	      } else {
	        // r is BN v5 instance
	        r._strip();
	      }
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
	    return a.umod(this.m)._forceRed(this);
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1).toRed(this);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal);
} (bn$1));

var Zns$1 = {};

var znsUtils = {};

var sha256Exports = {};
var sha256 = {
  get exports(){ return sha256Exports; },
  set exports(v){ sha256Exports = v; },
};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var coreExports = {};
var core = {
  get exports(){ return coreExports; },
  set exports(v){ coreExports = v; },
};

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return coreExports;
	hasRequiredCore = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory();
			}
		}(commonjsGlobal, function () {

			/*globals window, global, require*/

			/**
			 * CryptoJS core components.
			 */
			var CryptoJS = CryptoJS || (function (Math, undefined$1) {

			    var crypto;

			    // Native crypto from window (Browser)
			    if (typeof window !== 'undefined' && window.crypto) {
			        crypto = window.crypto;
			    }

			    // Native crypto in web worker (Browser)
			    if (typeof self !== 'undefined' && self.crypto) {
			        crypto = self.crypto;
			    }

			    // Native crypto from worker
			    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
			        crypto = globalThis.crypto;
			    }

			    // Native (experimental IE 11) crypto from window (Browser)
			    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
			        crypto = window.msCrypto;
			    }

			    // Native crypto from global (NodeJS)
			    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
			        crypto = commonjsGlobal.crypto;
			    }

			    // Native crypto import via require (NodeJS)
			    if (!crypto && typeof commonjsRequire === 'function') {
			        try {
			            crypto = require$$0$2;
			        } catch (err) {}
			    }

			    /*
			     * Cryptographically secure pseudorandom number generator
			     *
			     * As Math.random() is cryptographically not safe to use
			     */
			    var cryptoSecureRandomInt = function () {
			        if (crypto) {
			            // Use getRandomValues method (Browser)
			            if (typeof crypto.getRandomValues === 'function') {
			                try {
			                    return crypto.getRandomValues(new Uint32Array(1))[0];
			                } catch (err) {}
			            }

			            // Use randomBytes method (NodeJS)
			            if (typeof crypto.randomBytes === 'function') {
			                try {
			                    return crypto.randomBytes(4).readInt32LE();
			                } catch (err) {}
			            }
			        }

			        throw new Error('Native crypto module could not be used to get secure random number.');
			    };

			    /*
			     * Local polyfill of Object.create

			     */
			    var create = Object.create || (function () {
			        function F() {}

			        return function (obj) {
			            var subtype;

			            F.prototype = obj;

			            subtype = new F();

			            F.prototype = null;

			            return subtype;
			        };
			    }());

			    /**
			     * CryptoJS namespace.
			     */
			    var C = {};

			    /**
			     * Library namespace.
			     */
			    var C_lib = C.lib = {};

			    /**
			     * Base object for prototypal inheritance.
			     */
			    var Base = C_lib.Base = (function () {


			        return {
			            /**
			             * Creates a new object that inherits from this object.
			             *
			             * @param {Object} overrides Properties to copy into the new object.
			             *
			             * @return {Object} The new object.
			             *
			             * @static
			             *
			             * @example
			             *
			             *     var MyType = CryptoJS.lib.Base.extend({
			             *         field: 'value',
			             *
			             *         method: function () {
			             *         }
			             *     });
			             */
			            extend: function (overrides) {
			                // Spawn
			                var subtype = create(this);

			                // Augment
			                if (overrides) {
			                    subtype.mixIn(overrides);
			                }

			                // Create default initializer
			                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
			                    subtype.init = function () {
			                        subtype.$super.init.apply(this, arguments);
			                    };
			                }

			                // Initializer's prototype is the subtype object
			                subtype.init.prototype = subtype;

			                // Reference supertype
			                subtype.$super = this;

			                return subtype;
			            },

			            /**
			             * Extends this object and runs the init method.
			             * Arguments to create() will be passed to init().
			             *
			             * @return {Object} The new object.
			             *
			             * @static
			             *
			             * @example
			             *
			             *     var instance = MyType.create();
			             */
			            create: function () {
			                var instance = this.extend();
			                instance.init.apply(instance, arguments);

			                return instance;
			            },

			            /**
			             * Initializes a newly created object.
			             * Override this method to add some logic when your objects are created.
			             *
			             * @example
			             *
			             *     var MyType = CryptoJS.lib.Base.extend({
			             *         init: function () {
			             *             // ...
			             *         }
			             *     });
			             */
			            init: function () {
			            },

			            /**
			             * Copies properties into this object.
			             *
			             * @param {Object} properties The properties to mix in.
			             *
			             * @example
			             *
			             *     MyType.mixIn({
			             *         field: 'value'
			             *     });
			             */
			            mixIn: function (properties) {
			                for (var propertyName in properties) {
			                    if (properties.hasOwnProperty(propertyName)) {
			                        this[propertyName] = properties[propertyName];
			                    }
			                }

			                // IE won't copy toString using the loop above
			                if (properties.hasOwnProperty('toString')) {
			                    this.toString = properties.toString;
			                }
			            },

			            /**
			             * Creates a copy of this object.
			             *
			             * @return {Object} The clone.
			             *
			             * @example
			             *
			             *     var clone = instance.clone();
			             */
			            clone: function () {
			                return this.init.prototype.extend(this);
			            }
			        };
			    }());

			    /**
			     * An array of 32-bit words.
			     *
			     * @property {Array} words The array of 32-bit words.
			     * @property {number} sigBytes The number of significant bytes in this word array.
			     */
			    var WordArray = C_lib.WordArray = Base.extend({
			        /**
			         * Initializes a newly created word array.
			         *
			         * @param {Array} words (Optional) An array of 32-bit words.
			         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.lib.WordArray.create();
			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
			         */
			        init: function (words, sigBytes) {
			            words = this.words = words || [];

			            if (sigBytes != undefined$1) {
			                this.sigBytes = sigBytes;
			            } else {
			                this.sigBytes = words.length * 4;
			            }
			        },

			        /**
			         * Converts this word array to a string.
			         *
			         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
			         *
			         * @return {string} The stringified word array.
			         *
			         * @example
			         *
			         *     var string = wordArray + '';
			         *     var string = wordArray.toString();
			         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
			         */
			        toString: function (encoder) {
			            return (encoder || Hex).stringify(this);
			        },

			        /**
			         * Concatenates a word array to this word array.
			         *
			         * @param {WordArray} wordArray The word array to append.
			         *
			         * @return {WordArray} This word array.
			         *
			         * @example
			         *
			         *     wordArray1.concat(wordArray2);
			         */
			        concat: function (wordArray) {
			            // Shortcuts
			            var thisWords = this.words;
			            var thatWords = wordArray.words;
			            var thisSigBytes = this.sigBytes;
			            var thatSigBytes = wordArray.sigBytes;

			            // Clamp excess bits
			            this.clamp();

			            // Concat
			            if (thisSigBytes % 4) {
			                // Copy one byte at a time
			                for (var i = 0; i < thatSigBytes; i++) {
			                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
			                }
			            } else {
			                // Copy one word at a time
			                for (var j = 0; j < thatSigBytes; j += 4) {
			                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
			                }
			            }
			            this.sigBytes += thatSigBytes;

			            // Chainable
			            return this;
			        },

			        /**
			         * Removes insignificant bits.
			         *
			         * @example
			         *
			         *     wordArray.clamp();
			         */
			        clamp: function () {
			            // Shortcuts
			            var words = this.words;
			            var sigBytes = this.sigBytes;

			            // Clamp
			            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
			            words.length = Math.ceil(sigBytes / 4);
			        },

			        /**
			         * Creates a copy of this word array.
			         *
			         * @return {WordArray} The clone.
			         *
			         * @example
			         *
			         *     var clone = wordArray.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone.words = this.words.slice(0);

			            return clone;
			        },

			        /**
			         * Creates a word array filled with random bytes.
			         *
			         * @param {number} nBytes The number of random bytes to generate.
			         *
			         * @return {WordArray} The random word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.lib.WordArray.random(16);
			         */
			        random: function (nBytes) {
			            var words = [];

			            for (var i = 0; i < nBytes; i += 4) {
			                words.push(cryptoSecureRandomInt());
			            }

			            return new WordArray.init(words, nBytes);
			        }
			    });

			    /**
			     * Encoder namespace.
			     */
			    var C_enc = C.enc = {};

			    /**
			     * Hex encoding strategy.
			     */
			    var Hex = C_enc.Hex = {
			        /**
			         * Converts a word array to a hex string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The hex string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var hexChars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                hexChars.push((bite >>> 4).toString(16));
			                hexChars.push((bite & 0x0f).toString(16));
			            }

			            return hexChars.join('');
			        },

			        /**
			         * Converts a hex string to a word array.
			         *
			         * @param {string} hexStr The hex string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
			         */
			        parse: function (hexStr) {
			            // Shortcut
			            var hexStrLength = hexStr.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < hexStrLength; i += 2) {
			                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
			            }

			            return new WordArray.init(words, hexStrLength / 2);
			        }
			    };

			    /**
			     * Latin1 encoding strategy.
			     */
			    var Latin1 = C_enc.Latin1 = {
			        /**
			         * Converts a word array to a Latin1 string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The Latin1 string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            // Shortcuts
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;

			            // Convert
			            var latin1Chars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                latin1Chars.push(String.fromCharCode(bite));
			            }

			            return latin1Chars.join('');
			        },

			        /**
			         * Converts a Latin1 string to a word array.
			         *
			         * @param {string} latin1Str The Latin1 string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
			         */
			        parse: function (latin1Str) {
			            // Shortcut
			            var latin1StrLength = latin1Str.length;

			            // Convert
			            var words = [];
			            for (var i = 0; i < latin1StrLength; i++) {
			                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
			            }

			            return new WordArray.init(words, latin1StrLength);
			        }
			    };

			    /**
			     * UTF-8 encoding strategy.
			     */
			    var Utf8 = C_enc.Utf8 = {
			        /**
			         * Converts a word array to a UTF-8 string.
			         *
			         * @param {WordArray} wordArray The word array.
			         *
			         * @return {string} The UTF-8 string.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
			         */
			        stringify: function (wordArray) {
			            try {
			                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
			            } catch (e) {
			                throw new Error('Malformed UTF-8 data');
			            }
			        },

			        /**
			         * Converts a UTF-8 string to a word array.
			         *
			         * @param {string} utf8Str The UTF-8 string.
			         *
			         * @return {WordArray} The word array.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
			         */
			        parse: function (utf8Str) {
			            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
			        }
			    };

			    /**
			     * Abstract buffered block algorithm template.
			     *
			     * The property blockSize must be implemented in a concrete subtype.
			     *
			     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
			     */
			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
			        /**
			         * Resets this block algorithm's data buffer to its initial state.
			         *
			         * @example
			         *
			         *     bufferedBlockAlgorithm.reset();
			         */
			        reset: function () {
			            // Initial values
			            this._data = new WordArray.init();
			            this._nDataBytes = 0;
			        },

			        /**
			         * Adds new data to this block algorithm's buffer.
			         *
			         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
			         *
			         * @example
			         *
			         *     bufferedBlockAlgorithm._append('data');
			         *     bufferedBlockAlgorithm._append(wordArray);
			         */
			        _append: function (data) {
			            // Convert string to WordArray, else assume WordArray already
			            if (typeof data == 'string') {
			                data = Utf8.parse(data);
			            }

			            // Append
			            this._data.concat(data);
			            this._nDataBytes += data.sigBytes;
			        },

			        /**
			         * Processes available data blocks.
			         *
			         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
			         *
			         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
			         *
			         * @return {WordArray} The processed data.
			         *
			         * @example
			         *
			         *     var processedData = bufferedBlockAlgorithm._process();
			         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
			         */
			        _process: function (doFlush) {
			            var processedWords;

			            // Shortcuts
			            var data = this._data;
			            var dataWords = data.words;
			            var dataSigBytes = data.sigBytes;
			            var blockSize = this.blockSize;
			            var blockSizeBytes = blockSize * 4;

			            // Count blocks ready
			            var nBlocksReady = dataSigBytes / blockSizeBytes;
			            if (doFlush) {
			                // Round up to include partial blocks
			                nBlocksReady = Math.ceil(nBlocksReady);
			            } else {
			                // Round down to include only full blocks,
			                // less the number of blocks that must remain in the buffer
			                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
			            }

			            // Count words ready
			            var nWordsReady = nBlocksReady * blockSize;

			            // Count bytes ready
			            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

			            // Process blocks
			            if (nWordsReady) {
			                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
			                    // Perform concrete-algorithm logic
			                    this._doProcessBlock(dataWords, offset);
			                }

			                // Remove processed words
			                processedWords = dataWords.splice(0, nWordsReady);
			                data.sigBytes -= nBytesReady;
			            }

			            // Return processed words
			            return new WordArray.init(processedWords, nBytesReady);
			        },

			        /**
			         * Creates a copy of this object.
			         *
			         * @return {Object} The clone.
			         *
			         * @example
			         *
			         *     var clone = bufferedBlockAlgorithm.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone._data = this._data.clone();

			            return clone;
			        },

			        _minBufferSize: 0
			    });

			    /**
			     * Abstract hasher template.
			     *
			     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
			     */
			    C_lib.Hasher = BufferedBlockAlgorithm.extend({
			        /**
			         * Configuration options.
			         */
			        cfg: Base.extend(),

			        /**
			         * Initializes a newly created hasher.
			         *
			         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
			         *
			         * @example
			         *
			         *     var hasher = CryptoJS.algo.SHA256.create();
			         */
			        init: function (cfg) {
			            // Apply config defaults
			            this.cfg = this.cfg.extend(cfg);

			            // Set initial values
			            this.reset();
			        },

			        /**
			         * Resets this hasher to its initial state.
			         *
			         * @example
			         *
			         *     hasher.reset();
			         */
			        reset: function () {
			            // Reset data buffer
			            BufferedBlockAlgorithm.reset.call(this);

			            // Perform concrete-hasher logic
			            this._doReset();
			        },

			        /**
			         * Updates this hasher with a message.
			         *
			         * @param {WordArray|string} messageUpdate The message to append.
			         *
			         * @return {Hasher} This hasher.
			         *
			         * @example
			         *
			         *     hasher.update('message');
			         *     hasher.update(wordArray);
			         */
			        update: function (messageUpdate) {
			            // Append
			            this._append(messageUpdate);

			            // Update the hash
			            this._process();

			            // Chainable
			            return this;
			        },

			        /**
			         * Finalizes the hash computation.
			         * Note that the finalize operation is effectively a destructive, read-once operation.
			         *
			         * @param {WordArray|string} messageUpdate (Optional) A final message update.
			         *
			         * @return {WordArray} The hash.
			         *
			         * @example
			         *
			         *     var hash = hasher.finalize();
			         *     var hash = hasher.finalize('message');
			         *     var hash = hasher.finalize(wordArray);
			         */
			        finalize: function (messageUpdate) {
			            // Final message update
			            if (messageUpdate) {
			                this._append(messageUpdate);
			            }

			            // Perform concrete-hasher logic
			            var hash = this._doFinalize();

			            return hash;
			        },

			        blockSize: 512/32,

			        /**
			         * Creates a shortcut function to a hasher's object interface.
			         *
			         * @param {Hasher} hasher The hasher to create a helper for.
			         *
			         * @return {Function} The shortcut function.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
			         */
			        _createHelper: function (hasher) {
			            return function (message, cfg) {
			                return new hasher.init(cfg).finalize(message);
			            };
			        },

			        /**
			         * Creates a shortcut function to the HMAC's object interface.
			         *
			         * @param {Hasher} hasher The hasher to use in this HMAC helper.
			         *
			         * @return {Function} The shortcut function.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
			         */
			        _createHmacHelper: function (hasher) {
			            return function (message, key) {
			                return new C_algo.HMAC.init(hasher, key).finalize(message);
			            };
			        }
			    });

			    /**
			     * Algorithm namespace.
			     */
			    var C_algo = C.algo = {};

			    return C;
			}(Math));


			return CryptoJS;

		}));
} (core));
	return coreExports;
}

(function (module, exports) {
(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(requireCore());
		}
	}(commonjsGlobal, function (CryptoJS) {

		(function (Math) {
		    // Shortcuts
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var Hasher = C_lib.Hasher;
		    var C_algo = C.algo;

		    // Initialization and round constants tables
		    var H = [];
		    var K = [];

		    // Compute constants
		    (function () {
		        function isPrime(n) {
		            var sqrtN = Math.sqrt(n);
		            for (var factor = 2; factor <= sqrtN; factor++) {
		                if (!(n % factor)) {
		                    return false;
		                }
		            }

		            return true;
		        }

		        function getFractionalBits(n) {
		            return ((n - (n | 0)) * 0x100000000) | 0;
		        }

		        var n = 2;
		        var nPrime = 0;
		        while (nPrime < 64) {
		            if (isPrime(n)) {
		                if (nPrime < 8) {
		                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
		                }
		                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

		                nPrime++;
		            }

		            n++;
		        }
		    }());

		    // Reusable object
		    var W = [];

		    /**
		     * SHA-256 hash algorithm.
		     */
		    var SHA256 = C_algo.SHA256 = Hasher.extend({
		        _doReset: function () {
		            this._hash = new WordArray.init(H.slice(0));
		        },

		        _doProcessBlock: function (M, offset) {
		            // Shortcut
		            var H = this._hash.words;

		            // Working variables
		            var a = H[0];
		            var b = H[1];
		            var c = H[2];
		            var d = H[3];
		            var e = H[4];
		            var f = H[5];
		            var g = H[6];
		            var h = H[7];

		            // Computation
		            for (var i = 0; i < 64; i++) {
		                if (i < 16) {
		                    W[i] = M[offset + i] | 0;
		                } else {
		                    var gamma0x = W[i - 15];
		                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
		                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
		                                   (gamma0x >>> 3);

		                    var gamma1x = W[i - 2];
		                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
		                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
		                                   (gamma1x >>> 10);

		                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
		                }

		                var ch  = (e & f) ^ (~e & g);
		                var maj = (a & b) ^ (a & c) ^ (b & c);

		                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
		                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

		                var t1 = h + sigma1 + ch + K[i] + W[i];
		                var t2 = sigma0 + maj;

		                h = g;
		                g = f;
		                f = e;
		                e = (d + t1) | 0;
		                d = c;
		                c = b;
		                b = a;
		                a = (t1 + t2) | 0;
		            }

		            // Intermediate hash value
		            H[0] = (H[0] + a) | 0;
		            H[1] = (H[1] + b) | 0;
		            H[2] = (H[2] + c) | 0;
		            H[3] = (H[3] + d) | 0;
		            H[4] = (H[4] + e) | 0;
		            H[5] = (H[5] + f) | 0;
		            H[6] = (H[6] + g) | 0;
		            H[7] = (H[7] + h) | 0;
		        },

		        _doFinalize: function () {
		            // Shortcuts
		            var data = this._data;
		            var dataWords = data.words;

		            var nBitsTotal = this._nDataBytes * 8;
		            var nBitsLeft = data.sigBytes * 8;

		            // Add padding
		            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
		            data.sigBytes = dataWords.length * 4;

		            // Hash final blocks
		            this._process();

		            // Return final computed hash
		            return this._hash;
		        },

		        clone: function () {
		            var clone = Hasher.clone.call(this);
		            clone._hash = this._hash.clone();

		            return clone;
		        }
		    });

		    /**
		     * Shortcut function to the hasher's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     *
		     * @return {WordArray} The hash.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hash = CryptoJS.SHA256('message');
		     *     var hash = CryptoJS.SHA256(wordArray);
		     */
		    C.SHA256 = Hasher._createHelper(SHA256);

		    /**
		     * Shortcut function to the HMAC's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     * @param {WordArray|string} key The secret key.
		     *
		     * @return {WordArray} The HMAC.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hmac = CryptoJS.HmacSHA256(message, key);
		     */
		    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
		}(Math));


		return CryptoJS.SHA256;

	}));
} (sha256));

var encHexExports = {};
var encHex = {
  get exports(){ return encHexExports; },
  set exports(v){ encHexExports = v; },
};

(function (module, exports) {
(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(requireCore());
		}
	}(commonjsGlobal, function (CryptoJS) {

		return CryptoJS.enc.Hex;

	}));
} (encHex));

(function (exports) {
	/**
	 * All functionality below came from here https://github.com/Zilliqa/Zilliqa-JavaScript-Library/tree/dev/packages/zilliqa-js-crypto/src
	 */
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fromBech32Address = exports.toBech32Address = exports.toChecksumAddress = void 0;
	var bn_js_1 = __importDefault(bnExports$1);
	var sha256_1 = __importDefault(sha256Exports);
	var enc_hex_1 = __importDefault(encHexExports);
	var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
	var GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
	// HRP is the human-readable part of zilliqa bech32 addresses
	var HRP = 'zil';
	var tHRP = 'tzil';
	function isByteString(str, len) {
	    return !!str.replace('0x', '').match("^[0-9a-fA-F]{".concat(len, "}$"));
	}
	function isAddress(address) {
	    return isByteString(address, 40);
	}
	/**
	 * convertBits
	 *
	 * groups buffers of a certain width to buffers of the desired width.
	 *
	 * For example, converts byte buffers to buffers of maximum 5 bit numbers,
	 * padding those numbers as necessary. Necessary for encoding Ethereum-style
	 * addresses as bech32 ones.
	 * @param {Buffer} data
	 * @param {number} fromWidth
	 * @param {number} toWidth
	 * @param {boolean} pad
	 * @returns {Buffer|null}
	 */
	function convertBits(data, fromWidth, toWidth, pad) {
	    if (pad === void 0) { pad = true; }
	    var acc = 0;
	    var bits = 0;
	    var ret = [];
	    var maxv = (1 << toWidth) - 1;
	    // tslint:disable-next-line
	    for (var p = 0; p < data.length; ++p) {
	        var value = data[p];
	        if (value < 0 || value >> fromWidth !== 0) {
	            return null;
	        }
	        acc = (acc << fromWidth) | value;
	        bits += fromWidth;
	        while (bits >= toWidth) {
	            bits -= toWidth;
	            ret.push((acc >> bits) & maxv);
	        }
	    }
	    if (pad) {
	        if (bits > 0) {
	            ret.push((acc << (toWidth - bits)) & maxv);
	        }
	    }
	    else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {
	        return null;
	    }
	    return Buffer.from(ret);
	}
	function hrpExpand(hrp) {
	    var ret = [];
	    var p;
	    for (p = 0; p < hrp.length; ++p) {
	        ret.push(hrp.charCodeAt(p) >> 5);
	    }
	    ret.push(0);
	    for (p = 0; p < hrp.length; ++p) {
	        ret.push(hrp.charCodeAt(p) & 31);
	    }
	    return Buffer.from(ret);
	}
	function polymod(values) {
	    var chk = 1;
	    // tslint:disable-next-line
	    for (var p = 0; p < values.length; ++p) {
	        var top_1 = chk >> 25;
	        chk = ((chk & 0x1ffffff) << 5) ^ values[p];
	        for (var i = 0; i < 5; ++i) {
	            if ((top_1 >> i) & 1) {
	                chk ^= GENERATOR[i];
	            }
	        }
	    }
	    return chk;
	}
	function createChecksum(hrp, data) {
	    var values = Buffer.concat([
	        Buffer.from(hrpExpand(hrp)),
	        data,
	        Buffer.from([0, 0, 0, 0, 0, 0]),
	    ]);
	    // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
	    var mod = polymod(values) ^ 1;
	    var ret = [];
	    for (var p = 0; p < 6; ++p) {
	        ret.push((mod >> (5 * (5 - p))) & 31);
	    }
	    return Buffer.from(ret);
	}
	function verifyChecksum(hrp, data) {
	    return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;
	}
	function encode(hrp, data) {
	    var combined = Buffer.concat([data, createChecksum(hrp, data)]);
	    var ret = hrp + '1';
	    // tslint:disable-next-line
	    for (var p = 0; p < combined.length; ++p) {
	        ret += CHARSET.charAt(combined[p]);
	    }
	    return ret;
	}
	function decode(bechString) {
	    var p;
	    var hasLower = false;
	    var hasUpper = false;
	    for (p = 0; p < bechString.length; ++p) {
	        if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {
	            return null;
	        }
	        if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {
	            hasLower = true;
	        }
	        if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {
	            hasUpper = true;
	        }
	    }
	    if (hasLower && hasUpper) {
	        return null;
	    }
	    bechString = bechString.toLowerCase();
	    var pos = bechString.lastIndexOf('1');
	    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {
	        return null;
	    }
	    var hrp = bechString.substring(0, pos);
	    var data = [];
	    for (p = pos + 1; p < bechString.length; ++p) {
	        var d = CHARSET.indexOf(bechString.charAt(p));
	        if (d === -1) {
	            return null;
	        }
	        data.push(d);
	    }
	    if (!verifyChecksum(hrp, Buffer.from(data))) {
	        return null;
	    }
	    return { hrp: hrp, data: Buffer.from(data.slice(0, data.length - 6)) };
	}
	/**
	 * toChecksumAddress
	 *
	 * takes hex-encoded string and returns the corresponding address
	 * @param {string} address
	 * @returns {string}
	 */
	var toChecksumAddress = function (address) {
	    if (!isAddress(address)) {
	        throw new Error("".concat(address, " is not a valid base 16 address"));
	    }
	    address = address.toLowerCase().replace('0x', '');
	    var hash = enc_hex_1.default.stringify((0, sha256_1.default)(enc_hex_1.default.parse(address)));
	    var v = new bn_js_1.default(hash, 'hex', 'be');
	    var ret = '0x';
	    for (var i = 0; i < address.length; i++) {
	        if ('0123456789'.indexOf(address[i]) !== -1) {
	            ret += address[i];
	        }
	        else {
	            ret += v.and(new bn_js_1.default(2).pow(new bn_js_1.default(255 - 6 * i))).gte(new bn_js_1.default(1))
	                ? address[i].toUpperCase()
	                : address[i].toLowerCase();
	        }
	    }
	    return ret;
	};
	exports.toChecksumAddress = toChecksumAddress;
	/**
	 * toBech32Address
	 *
	 * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa
	 * address.
	 *
	 * The expected format is zil1<address><checksum> where address and checksum
	 * are the result of bech32 encoding a Buffer containing the address bytes.
	 * @param {string} address 20 byte canonical address
	 * @param {boolean} testnet
	 * @returns {string} 38 char bech32 encoded zilliqa address
	 */
	function toBech32Address(address, testnet) {
	    if (testnet === void 0) { testnet = false; }
	    if (!isAddress(address)) {
	        throw new Error('Invalid address format.');
	    }
	    var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);
	    if (addrBz === null) {
	        throw new Error('Could not convert byte Buffer to 5-bit Buffer');
	    }
	    return encode(testnet ? tHRP : HRP, addrBz);
	}
	exports.toBech32Address = toBech32Address;
	/**
	 * fromBech32Address
	 * @param {string} address - a valid Zilliqa bech32 address
	 * @param {boolean} testnet
	 * @returns {string} a canonical 20-byte Ethereum-style address
	 */
	function fromBech32Address(address, testnet) {
	    if (testnet === void 0) { testnet = false; }
	    var res = decode(address);
	    if (res === null) {
	        throw new Error('Invalid bech32 address');
	    }
	    var hrp = res.hrp, data = res.data;
	    var shouldBe = testnet ? tHRP : HRP;
	    if (hrp !== shouldBe) {
	        throw new Error("Expected hrp to be ".concat(shouldBe, " but got ").concat(hrp));
	    }
	    var buf = convertBits(data, 5, 8, false);
	    if (buf === null) {
	        throw new Error('Could not convert buffer to bytes');
	    }
	    return (0, exports.toChecksumAddress)(buf.toString('hex'));
	}
	exports.fromBech32Address = fromBech32Address;
} (znsUtils));

var utils$n = {};

var publicTypes = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlockchainType = exports.DnsRecordType = exports.NamehashOptionsDefault = exports.UDApiDefaultUrl = exports.UnclaimedDomainResponse = exports.NamingServiceName = exports.UnsLocation = void 0;
	(function (UnsLocation) {
	    UnsLocation["Layer1"] = "UNSLayer1";
	    UnsLocation["Layer2"] = "UNSLayer2";
	})(exports.UnsLocation || (exports.UnsLocation = {}));
	(function (NamingServiceName) {
	    NamingServiceName["UNS"] = "UNS";
	    NamingServiceName["ZNS"] = "ZNS";
	})(exports.NamingServiceName || (exports.NamingServiceName = {}));
	exports.UnclaimedDomainResponse = {
	    addresses: {},
	    meta: {
	        domain: '',
	        namehash: '',
	        resolver: '',
	        owner: null,
	        type: '',
	        ttl: 0,
	        blockchain: null,
	    },
	    records: {},
	};
	exports.UDApiDefaultUrl = 'https://unstoppabledomains.com/api/v1';
	exports.NamehashOptionsDefault = {
	    format: 'hex',
	    prefix: true,
	    zns: false,
	};
	(function (DnsRecordType) {
	    DnsRecordType["A"] = "A";
	    DnsRecordType["AAAA"] = "AAAA";
	    DnsRecordType["AFSDB"] = "AFSDB";
	    DnsRecordType["APL"] = "APL";
	    DnsRecordType["CAA"] = "CAA";
	    DnsRecordType["CDNSKEY"] = "CDNSKEY";
	    DnsRecordType["CDS"] = "CDS";
	    DnsRecordType["CERT"] = "CERT";
	    DnsRecordType["CNAME"] = "CNAME";
	    DnsRecordType["CSYNC"] = "CSYNC";
	    DnsRecordType["DHCID"] = "DHCID";
	    DnsRecordType["DLV"] = "DLV";
	    DnsRecordType["DNAME"] = "DNAME";
	    DnsRecordType["DNSKEY"] = "DNSKEY";
	    DnsRecordType["DS"] = "DS";
	    DnsRecordType["EUI48"] = "EUI48";
	    DnsRecordType["EUI64"] = "EUI64";
	    DnsRecordType["HINFO"] = "HINFO";
	    DnsRecordType["HIP"] = "HIP";
	    DnsRecordType["HTTPS"] = "HTTPS";
	    DnsRecordType["IPSECKEY"] = "IPSECKEY";
	    DnsRecordType["KEY"] = "KEY";
	    DnsRecordType["KX"] = "KX";
	    DnsRecordType["LOC"] = "LOC";
	    DnsRecordType["MX"] = "MX";
	    DnsRecordType["NAPTR"] = "NAPTR";
	    DnsRecordType["NS"] = "NS";
	    DnsRecordType["NSEC"] = "NSEC";
	    DnsRecordType["NSEC3"] = "NSEC3";
	    DnsRecordType["NSEC3PARAM"] = "NSEC3PARAM";
	    DnsRecordType["OPENPGPKEY"] = "OPENPGPKEY";
	    DnsRecordType["PTR"] = "PTR";
	    DnsRecordType["RP"] = "RP";
	    DnsRecordType["RRSIG"] = "RRSIG";
	    DnsRecordType["SIG"] = "SIG";
	    DnsRecordType["SMIMEA"] = "SMIMEA";
	    DnsRecordType["SOA"] = "SOA";
	    DnsRecordType["SRV"] = "SRV";
	    DnsRecordType["SSHFP"] = "SSHFP";
	    DnsRecordType["SVCB"] = "SVCB";
	    DnsRecordType["TA"] = "TA";
	    DnsRecordType["TKEY"] = "TKEY";
	    DnsRecordType["TLSA"] = "TLSA";
	    DnsRecordType["TSIG"] = "TSIG";
	    DnsRecordType["TXT"] = "TXT";
	    DnsRecordType["URI"] = "URI";
	    DnsRecordType["ZONEMD"] = "ZONEMD";
	})(exports.DnsRecordType || (exports.DnsRecordType = {}));
	(function (BlockchainType) {
	    BlockchainType["ETH"] = "ETH";
	    BlockchainType["MATIC"] = "MATIC";
	    BlockchainType["ZIL"] = "ZIL";
	})(exports.BlockchainType || (exports.BlockchainType = {}));
} (publicTypes));

var types = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hasProvider = exports.ZnsSupportedNetwork = exports.UnsSupportedNetwork = exports.NullAddresses = exports.NullAddress = void 0;
	exports.NullAddress = '0x0000000000000000000000000000000000000000';
	(function (NullAddresses) {
	    NullAddresses[NullAddresses["0x"] = 0] = "0x";
	    NullAddresses[NullAddresses["0x0000000000000000000000000000000000000000"] = 1] = "0x0000000000000000000000000000000000000000";
	    NullAddresses[NullAddresses["0x0000000000000000000000000000000000000000000000000000000000000000"] = 2] = "0x0000000000000000000000000000000000000000000000000000000000000000";
	})(exports.NullAddresses || (exports.NullAddresses = {}));
	// TypeScript will infer a string union type from the literal values passed to
	// this function. Without `extends string`, it would instead generalize them
	// to the common string type.
	// @see https://stackoverflow.com/questions/36836011/checking-validity-of-string-literal-union-type-at-runtime
	var StringUnion = function () {
	    var values = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        values[_i] = arguments[_i];
	    }
	    Object.freeze(values);
	    var valueSet = new Set(values);
	    var guard = function (value) {
	        return valueSet.has(value);
	    };
	    var check = function (value) {
	        if (!guard(value)) {
	            var actual = JSON.stringify(value);
	            var expected = values.map(function (s) { return JSON.stringify(s); }).join(' | ');
	            throw new TypeError("Value '".concat(actual, "' is not assignable to type '").concat(expected, "'."));
	        }
	        return value;
	    };
	    var unionNamespace = { guard: guard, check: check, values: values };
	    return Object.freeze(unionNamespace);
	};
	exports.UnsSupportedNetwork = StringUnion('mainnet', 'rinkeby', 'goerli', 'polygon-mainnet', 'polygon-mumbai');
	exports.ZnsSupportedNetwork = StringUnion('mainnet', 'testnet');
	function hasProvider(obj) {
	    return obj && !!obj.provider;
	}
	exports.hasProvider = hasProvider;
} (types));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.unwrapResult = exports.wrapResult = exports.EthereumNetworksInverted = exports.EthereumNetworks = exports.findNamingServiceName = exports.domainExtensionToNamingServiceName = exports.constructRecords = exports.isNullAddress = exports.hexToBytes = exports.signedLink = void 0;
	var publicTypes_1 = publicTypes;
	var types_1 = types;
	var ProviderURLMap = {
	    infura: {
	        mainnet: 'https://mainnet.infura.io/v3/',
	        rinkeby: 'https://rinkeby.infura.io/v3/',
	        goerli: 'https://goerli.infura.io/v3/',
	        'polygon-mainnet': 'https://polygon-mainnet.infura.io/v3/',
	        'polygon-mumbai': 'https://polygon-mumbai.infura.io/v3/',
	    },
	    alchemy: {
	        mainnet: 'https://eth-mainnet.alchemyapi.io/v2/',
	        rinkeby: 'https://eth-rinkeby.alchemyapi.io/v2/',
	        goerli: 'https://eth-goerli.alchemyapi.io/v2/',
	        'polygon-mainnet': 'https://polygon-mainnet.g.alchemy.com/v2/',
	        'polygon-mumbai': 'https://polygon-mumbai.g.alchemy.com/v2/',
	    },
	};
	function signedLink(key, network, provider) {
	    if (network === void 0) { network = 'mainnet'; }
	    if (provider === void 0) { provider = 'alchemy'; }
	    var url = ProviderURLMap[provider][network];
	    return "".concat(url).concat(key);
	}
	exports.signedLink = signedLink;
	function hexToBytes(hexString) {
	    var hex = hexString.replace(/^0x/i, '');
	    var bytes = [];
	    for (var c = 0; c < hex.length; c += 2) {
	        bytes.push(parseInt(hex.substr(c, 2), 16));
	    }
	    return bytes;
	}
	exports.hexToBytes = hexToBytes;
	function isNullAddress(key) {
	    if (!key) {
	        return true;
	    }
	    return Object.values(types_1.NullAddresses).includes(key);
	}
	exports.isNullAddress = isNullAddress;
	function constructRecords(keys, values) {
	    var records = {};
	    keys.forEach(function (key, index) {
	        records[key] =
	            (values instanceof Array ? values[index] : values === null || values === void 0 ? void 0 : values[key]) || '';
	    });
	    return records;
	}
	exports.constructRecords = constructRecords;
	exports.domainExtensionToNamingServiceName = {
	    crypto: publicTypes_1.NamingServiceName.UNS,
	    zil: publicTypes_1.NamingServiceName.ZNS,
	};
	var findNamingServiceName = function (domain) {
	    var extension = domain.split('.').pop();
	    if (!extension) {
	        return '';
	    }
	    else if (extension in exports.domainExtensionToNamingServiceName) {
	        return exports.domainExtensionToNamingServiceName[extension];
	    }
	    else {
	        return exports.domainExtensionToNamingServiceName.crypto;
	    }
	};
	exports.findNamingServiceName = findNamingServiceName;
	exports.EthereumNetworks = {
	    mainnet: 1,
	    ropsten: 3,
	    rinkeby: 4,
	    goerli: 5,
	    'polygon-mainnet': 137,
	    'polygon-mumbai': 80001,
	};
	exports.EthereumNetworksInverted = {
	    1: 'mainnet',
	    3: 'ropsten',
	    4: 'rinkeby',
	    5: 'goerli',
	    137: 'polygon-mainnet',
	    80001: 'polygon-mumbai',
	};
	var wrapResult = function (func) {
	    var callResult;
	    // Catch immediately in case it's not an async call.
	    try {
	        callResult = func();
	    }
	    catch (error) {
	        return Promise.resolve({ result: null, error: error });
	    }
	    // `Promise.resolve` will convert both promise-like objects and plain values to promises.
	    var promise = callResult instanceof Promise ? callResult : Promise.resolve(callResult);
	    // We wrap results and errors to avoid unhandled promise rejections in case we won't `await` every promise
	    // and return earlier.
	    return promise.then(function (result) { return ({ result: result, error: null }); }, function (error) { return ({ result: null, error: error }); });
	};
	exports.wrapResult = wrapResult;
	var unwrapResult = function (wrappedResult) {
	    if (wrappedResult.error !== null) {
	        throw wrappedResult.error;
	    }
	    return wrappedResult.result;
	};
	exports.unwrapResult = unwrapResult;
} (utils$n));

var resolutionError = {};

(function (exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var _a;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ResolutionError = exports.ResolutionErrorCode = void 0;
	var ResolutionErrorCode;
	(function (ResolutionErrorCode) {
	    ResolutionErrorCode["UnregisteredDomain"] = "UnregisteredDomain";
	    ResolutionErrorCode["UnspecifiedResolver"] = "UnspecifiedResolver";
	    ResolutionErrorCode["UnsupportedDomain"] = "UnsupportedDomain";
	    ResolutionErrorCode["UnsupportedService"] = "UnsupportedService";
	    ResolutionErrorCode["UnsupportedMethod"] = "UnsupportedMethod";
	    ResolutionErrorCode["UnspecifiedCurrency"] = "UnspecifiedCurrency";
	    ResolutionErrorCode["UnsupportedCurrency"] = "UnsupportedCurrency";
	    ResolutionErrorCode["IncorrectResolverInterface"] = "IncorrectResolverInterface";
	    ResolutionErrorCode["RecordNotFound"] = "RecordNotFound";
	    ResolutionErrorCode["MetadataEndpointError"] = "MetadataEndpointError";
	    ResolutionErrorCode["ServiceProviderError"] = "ServiceProviderError";
	    ResolutionErrorCode["InvalidTwitterVerification"] = "InvalidTwitterVerification";
	    ResolutionErrorCode["InconsistentDomainArray"] = "InconsistentDomainArray";
	    ResolutionErrorCode["InvalidDomainAddress"] = "InvalidDomainAddress";
	})(ResolutionErrorCode = exports.ResolutionErrorCode || (exports.ResolutionErrorCode = {}));
	/**
	 * @internal
	 * Internal Mapping object from ResolutionErrorCode to a ResolutionErrorHandler
	 */
	var HandlersByCode = (_a = {},
	    _a[ResolutionErrorCode.UnregisteredDomain] = function (params) {
	        return "Domain ".concat(params.domain, " is not registered");
	    },
	    _a[ResolutionErrorCode.UnspecifiedResolver] = function (params) {
	        return "".concat(params.location ? "".concat(params.location, ": ") : '', "Domain ").concat(params.domain, " is not configured");
	    },
	    _a[ResolutionErrorCode.UnsupportedDomain] = function (params) {
	        return "Domain ".concat(params.domain, " is not supported");
	    },
	    _a[ResolutionErrorCode.UnsupportedMethod] = function (params) {
	        var _a;
	        // We normally expect a domain name, but in can be absent in the tests.
	        var zilHelp = ((_a = params.domain) === null || _a === void 0 ? void 0 : _a.endsWith('.zil'))
	            ? " (if this method was called via the Resolution class with both UNS and ZNS providers configured not in the API mode, this error also means that the domain doesn't exist in UNS)"
	            : '';
	        return "Method ".concat(params.methodName, " is not supported for ").concat(params.domain).concat(zilHelp);
	    },
	    _a[ResolutionErrorCode.InvalidTwitterVerification] = function (params) {
	        return "".concat(params.location ? "".concat(params.location, ": ") : '', "Domain ").concat(params.domain, " has invalid Twitter signature verification");
	    },
	    _a[ResolutionErrorCode.UnsupportedCurrency] = function (params) { return "".concat(params.currencyTicker, " is not supported"); },
	    _a[ResolutionErrorCode.IncorrectResolverInterface] = function (params) { return "Domain resolver is configured incorrectly for ".concat(params.method); },
	    _a[ResolutionErrorCode.RecordNotFound] = function (params) {
	        return "".concat(params.location ? "".concat(params.location, ": ") : '', "No ").concat(params.recordName, " record found for ").concat(params.domain);
	    },
	    _a[ResolutionErrorCode.ServiceProviderError] = function (params) { return "< ".concat(params.providerMessage, " >"); },
	    _a[ResolutionErrorCode.MetadataEndpointError] = function (params) {
	        return "Failed to query tokenUri ".concat(params.tokenUri, ". Error: ").concat(params.errorMessage);
	    },
	    _a[ResolutionErrorCode.UnsupportedService] = function (params) {
	        return "Naming service ".concat(params.namingService, " is not supported");
	    },
	    _a[ResolutionErrorCode.InvalidDomainAddress] = function (params) {
	        return "Domain address ".concat(params.domain, " is invalid");
	    },
	    _a);
	/**
	 * Resolution Error class is designed to control every error being thrown by Resolution
	 * @param code - Error Code
	 * - UnsupportedDomain - domain is not supported by current Resolution instance
	 * - UnregisteredDomain - domain is not owned by any address
	 * - UnspecifiedResolver - domain has no resolver specified
	 * - UnspecifiedCurrency - domain resolver doesn't have any address of specified currency
	 * - UnsupportedCurrency - currency is not supported
	 * - IncorrectResolverInterface - ResolverInterface is incorrected
	 * - RecordNotFound - No record was found
	 * @param domain - Domain name that was being used
	 * @param method
	 */
	var ResolutionError = /** @class */ (function (_super) {
	    __extends(ResolutionError, _super);
	    function ResolutionError(code, options) {
	        if (options === void 0) { options = {}; }
	        var _this = this;
	        var resolutionErrorHandler = HandlersByCode[code];
	        var domain = options.domain, method = options.method, currencyTicker = options.currencyTicker;
	        var message = resolutionErrorHandler(options);
	        _this = _super.call(this, message) || this;
	        _this.code = code;
	        _this.domain = domain;
	        _this.method = method;
	        _this.currencyTicker = currencyTicker;
	        _this.name = 'ResolutionError';
	        Object.setPrototypeOf(_this, ResolutionError.prototype);
	        return _this;
	    }
	    return ResolutionError;
	}(Error));
	exports.ResolutionError = ResolutionError;
	exports.default = ResolutionError;
} (resolutionError));

var FetchProvider$1 = {};

var Networking$1 = {};

var browserPonyfillExports = {};
var browserPonyfill = {
  get exports(){ return browserPonyfillExports; },
  set exports(v){ browserPonyfillExports = v; },
};

(function (module, exports) {
	var global = typeof self !== 'undefined' ? self : commonjsGlobal;
	var __self__ = (function () {
	function F() {
	this.fetch = false;
	this.DOMException = global.DOMException;
	}
	F.prototype = global;
	return new F();
	})();
	(function(self) {

	((function (exports) {

	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob:
	      'FileReader' in self &&
	      'Blob' in self &&
	      (function() {
	        try {
	          new Blob();
	          return true
	        } catch (e) {
	          return false
	        }
	      })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  };

	  function isDataView(obj) {
	    return obj && DataView.prototype.isPrototypeOf(obj)
	  }

	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ];

	    var isArrayBufferView =
	      ArrayBuffer.isView ||
	      function(obj) {
	        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	      };
	  }

	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name);
	    }
	    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }

	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value);
	    }
	    return value
	  }

	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift();
	        return {done: value === undefined, value: value}
	      }
	    };

	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      };
	    }

	    return iterator
	  }

	  function Headers(headers) {
	    this.map = {};

	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value);
	      }, this);
	    } else if (Array.isArray(headers)) {
	      headers.forEach(function(header) {
	        this.append(header[0], header[1]);
	      }, this);
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name]);
	      }, this);
	    }
	  }

	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name);
	    value = normalizeValue(value);
	    var oldValue = this.map[name];
	    this.map[name] = oldValue ? oldValue + ', ' + value : value;
	  };

	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)];
	  };

	  Headers.prototype.get = function(name) {
	    name = normalizeName(name);
	    return this.has(name) ? this.map[name] : null
	  };

	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  };

	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value);
	  };

	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this);
	      }
	    }
	  };

	  Headers.prototype.keys = function() {
	    var items = [];
	    this.forEach(function(value, name) {
	      items.push(name);
	    });
	    return iteratorFor(items)
	  };

	  Headers.prototype.values = function() {
	    var items = [];
	    this.forEach(function(value) {
	      items.push(value);
	    });
	    return iteratorFor(items)
	  };

	  Headers.prototype.entries = function() {
	    var items = [];
	    this.forEach(function(value, name) {
	      items.push([name, value]);
	    });
	    return iteratorFor(items)
	  };

	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
	  }

	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true;
	  }

	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result);
	      };
	      reader.onerror = function() {
	        reject(reader.error);
	      };
	    })
	  }

	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader();
	    var promise = fileReaderReady(reader);
	    reader.readAsArrayBuffer(blob);
	    return promise
	  }

	  function readBlobAsText(blob) {
	    var reader = new FileReader();
	    var promise = fileReaderReady(reader);
	    reader.readAsText(blob);
	    return promise
	  }

	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf);
	    var chars = new Array(view.length);

	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i]);
	    }
	    return chars.join('')
	  }

	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength);
	      view.set(new Uint8Array(buf));
	      return view.buffer
	    }
	  }

	  function Body() {
	    this.bodyUsed = false;

	    this._initBody = function(body) {
	      this._bodyInit = body;
	      if (!body) {
	        this._bodyText = '';
	      } else if (typeof body === 'string') {
	        this._bodyText = body;
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body;
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body;
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString();
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer);
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer]);
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body);
	      } else {
	        this._bodyText = body = Object.prototype.toString.call(body);
	      }

	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8');
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type);
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	        }
	      }
	    };

	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this);
	        if (rejected) {
	          return rejected
	        }

	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      };

	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      };
	    }

	    this.text = function() {
	      var rejected = consumed(this);
	      if (rejected) {
	        return rejected
	      }

	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    };

	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      };
	    }

	    this.json = function() {
	      return this.text().then(JSON.parse)
	    };

	    return this
	  }

	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase();
	    return methods.indexOf(upcased) > -1 ? upcased : method
	  }

	  function Request(input, options) {
	    options = options || {};
	    var body = options.body;

	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url;
	      this.credentials = input.credentials;
	      if (!options.headers) {
	        this.headers = new Headers(input.headers);
	      }
	      this.method = input.method;
	      this.mode = input.mode;
	      this.signal = input.signal;
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit;
	        input.bodyUsed = true;
	      }
	    } else {
	      this.url = String(input);
	    }

	    this.credentials = options.credentials || this.credentials || 'same-origin';
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers);
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET');
	    this.mode = options.mode || this.mode || null;
	    this.signal = options.signal || this.signal;
	    this.referrer = null;

	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body);
	  }

	  Request.prototype.clone = function() {
	    return new Request(this, {body: this._bodyInit})
	  };

	  function decode(body) {
	    var form = new FormData();
	    body
	      .trim()
	      .split('&')
	      .forEach(function(bytes) {
	        if (bytes) {
	          var split = bytes.split('=');
	          var name = split.shift().replace(/\+/g, ' ');
	          var value = split.join('=').replace(/\+/g, ' ');
	          form.append(decodeURIComponent(name), decodeURIComponent(value));
	        }
	      });
	    return form
	  }

	  function parseHeaders(rawHeaders) {
	    var headers = new Headers();
	    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
	    // https://tools.ietf.org/html/rfc7230#section-3.2
	    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
	    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':');
	      var key = parts.shift().trim();
	      if (key) {
	        var value = parts.join(':').trim();
	        headers.append(key, value);
	      }
	    });
	    return headers
	  }

	  Body.call(Request.prototype);

	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {};
	    }

	    this.type = 'default';
	    this.status = options.status === undefined ? 200 : options.status;
	    this.ok = this.status >= 200 && this.status < 300;
	    this.statusText = 'statusText' in options ? options.statusText : 'OK';
	    this.headers = new Headers(options.headers);
	    this.url = options.url || '';
	    this._initBody(bodyInit);
	  }

	  Body.call(Response.prototype);

	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  };

	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''});
	    response.type = 'error';
	    return response
	  };

	  var redirectStatuses = [301, 302, 303, 307, 308];

	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }

	    return new Response(null, {status: status, headers: {location: url}})
	  };

	  exports.DOMException = self.DOMException;
	  try {
	    new exports.DOMException();
	  } catch (err) {
	    exports.DOMException = function(message, name) {
	      this.message = message;
	      this.name = name;
	      var error = Error(message);
	      this.stack = error.stack;
	    };
	    exports.DOMException.prototype = Object.create(Error.prototype);
	    exports.DOMException.prototype.constructor = exports.DOMException;
	  }

	  function fetch(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init);

	      if (request.signal && request.signal.aborted) {
	        return reject(new exports.DOMException('Aborted', 'AbortError'))
	      }

	      var xhr = new XMLHttpRequest();

	      function abortXhr() {
	        xhr.abort();
	      }

	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        };
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
	        var body = 'response' in xhr ? xhr.response : xhr.responseText;
	        resolve(new Response(body, options));
	      };

	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'));
	      };

	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'));
	      };

	      xhr.onabort = function() {
	        reject(new exports.DOMException('Aborted', 'AbortError'));
	      };

	      xhr.open(request.method, request.url, true);

	      if (request.credentials === 'include') {
	        xhr.withCredentials = true;
	      } else if (request.credentials === 'omit') {
	        xhr.withCredentials = false;
	      }

	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob';
	      }

	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value);
	      });

	      if (request.signal) {
	        request.signal.addEventListener('abort', abortXhr);

	        xhr.onreadystatechange = function() {
	          // DONE (success or failure)
	          if (xhr.readyState === 4) {
	            request.signal.removeEventListener('abort', abortXhr);
	          }
	        };
	      }

	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
	    })
	  }

	  fetch.polyfill = true;

	  if (!self.fetch) {
	    self.fetch = fetch;
	    self.Headers = Headers;
	    self.Request = Request;
	    self.Response = Response;
	  }

	  exports.Headers = Headers;
	  exports.Request = Request;
	  exports.Response = Response;
	  exports.fetch = fetch;

	  Object.defineProperty(exports, '__esModule', { value: true });

	  return exports;

	}))({});
	})(__self__);
	__self__.fetch.ponyfill = true;
	// Remove "polyfill" property added by whatwg-fetch
	delete __self__.fetch.polyfill;
	// Choose between native implementation (global) or custom implementation (__self__)
	// var ctx = global.fetch ? global : __self__;
	var ctx = __self__; // this line disable service worker support temporarily
	exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
	exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.
	exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
	exports.Headers = ctx.Headers;
	exports.Request = ctx.Request;
	exports.Response = ctx.Response;
	module.exports = exports;
} (browserPonyfill, browserPonyfillExports));

var __awaiter$8 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$8 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault$7 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(Networking$1, "__esModule", { value: true });
var cross_fetch_1 = __importDefault$7(browserPonyfillExports);
var Networking = /** @class */ (function () {
    function Networking() {
    }
    Networking.fetch = function (url, options) {
        return __awaiter$8(this, void 0, void 0, function () {
            return __generator$8(this, function (_a) {
                return [2 /*return*/, (0, cross_fetch_1.default)(url, options)];
            });
        });
    };
    return Networking;
}());
Networking$1.default = Networking;

var __createBinding$7 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$7 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$7 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$7(result, mod, k);
    __setModuleDefault$7(result, mod);
    return result;
};
var __awaiter$7 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$7 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault$6 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(FetchProvider$1, "__esModule", { value: true });
var resolutionError_1$7 = __importStar$7(resolutionError);
var Networking_1$3 = __importDefault$6(Networking$1);
var FetchProvider = /** @class */ (function () {
    function FetchProvider(name, url) {
        this.url = url;
        this.name = name;
    }
    // This is used for test mocking
    FetchProvider.factory = function (name, url) {
        return new this(name, url);
    };
    FetchProvider.prototype.request = function (args) {
        return __awaiter$7(this, void 0, void 0, function () {
            var json;
            return __generator$7(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fetchJson(args)];
                    case 1:
                        json = _a.sent();
                        if (json.error) {
                            throw new resolutionError_1$7.default(resolutionError_1$7.ResolutionErrorCode.ServiceProviderError, {
                                providerMessage: json.error.message,
                            });
                        }
                        return [2 /*return*/, json.result];
                }
            });
        });
    };
    FetchProvider.prototype.fetchJson = function (args) {
        return __awaiter$7(this, void 0, void 0, function () {
            var response;
            return __generator$7(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Networking_1$3.default.fetch(this.url, {
                            method: 'POST',
                            body: JSON.stringify({
                                jsonrpc: '2.0',
                                id: '1',
                                method: args.method,
                                params: args.params || [],
                            }),
                            headers: {
                                'Content-Type': 'application/json',
                            },
                        })];
                    case 1:
                        response = _a.sent();
                        if (response.status !== 200) {
                            throw new resolutionError_1$7.default(resolutionError_1$7.ResolutionErrorCode.ServiceProviderError, {
                                providerMessage: "Request to ".concat(this.url, " failed with response status ").concat(response.status),
                            });
                        }
                        return [2 /*return*/, response.json()];
                }
            });
        });
    };
    return FetchProvider;
}());
FetchProvider$1.default = FetchProvider;

var namehash = {};

var sha3Exports$1 = {};
var sha3$2 = {
  get exports(){ return sha3Exports$1; },
  set exports(v){ sha3Exports$1 = v; },
};

var x64CoreExports = {};
var x64Core = {
  get exports(){ return x64CoreExports; },
  set exports(v){ x64CoreExports = v; },
};

var hasRequiredX64Core;

function requireX64Core () {
	if (hasRequiredX64Core) return x64CoreExports;
	hasRequiredX64Core = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				// CommonJS
				module.exports = factory(requireCore());
			}
		}(commonjsGlobal, function (CryptoJS) {

			(function (undefined$1) {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var Base = C_lib.Base;
			    var X32WordArray = C_lib.WordArray;

			    /**
			     * x64 namespace.
			     */
			    var C_x64 = C.x64 = {};

			    /**
			     * A 64-bit word.
			     */
			    C_x64.Word = Base.extend({
			        /**
			         * Initializes a newly created 64-bit word.
			         *
			         * @param {number} high The high 32 bits.
			         * @param {number} low The low 32 bits.
			         *
			         * @example
			         *
			         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
			         */
			        init: function (high, low) {
			            this.high = high;
			            this.low = low;
			        }

			        /**
			         * Bitwise NOTs this word.
			         *
			         * @return {X64Word} A new x64-Word object after negating.
			         *
			         * @example
			         *
			         *     var negated = x64Word.not();
			         */
			        // not: function () {
			            // var high = ~this.high;
			            // var low = ~this.low;

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Bitwise ANDs this word with the passed word.
			         *
			         * @param {X64Word} word The x64-Word to AND with this word.
			         *
			         * @return {X64Word} A new x64-Word object after ANDing.
			         *
			         * @example
			         *
			         *     var anded = x64Word.and(anotherX64Word);
			         */
			        // and: function (word) {
			            // var high = this.high & word.high;
			            // var low = this.low & word.low;

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Bitwise ORs this word with the passed word.
			         *
			         * @param {X64Word} word The x64-Word to OR with this word.
			         *
			         * @return {X64Word} A new x64-Word object after ORing.
			         *
			         * @example
			         *
			         *     var ored = x64Word.or(anotherX64Word);
			         */
			        // or: function (word) {
			            // var high = this.high | word.high;
			            // var low = this.low | word.low;

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Bitwise XORs this word with the passed word.
			         *
			         * @param {X64Word} word The x64-Word to XOR with this word.
			         *
			         * @return {X64Word} A new x64-Word object after XORing.
			         *
			         * @example
			         *
			         *     var xored = x64Word.xor(anotherX64Word);
			         */
			        // xor: function (word) {
			            // var high = this.high ^ word.high;
			            // var low = this.low ^ word.low;

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Shifts this word n bits to the left.
			         *
			         * @param {number} n The number of bits to shift.
			         *
			         * @return {X64Word} A new x64-Word object after shifting.
			         *
			         * @example
			         *
			         *     var shifted = x64Word.shiftL(25);
			         */
			        // shiftL: function (n) {
			            // if (n < 32) {
			                // var high = (this.high << n) | (this.low >>> (32 - n));
			                // var low = this.low << n;
			            // } else {
			                // var high = this.low << (n - 32);
			                // var low = 0;
			            // }

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Shifts this word n bits to the right.
			         *
			         * @param {number} n The number of bits to shift.
			         *
			         * @return {X64Word} A new x64-Word object after shifting.
			         *
			         * @example
			         *
			         *     var shifted = x64Word.shiftR(7);
			         */
			        // shiftR: function (n) {
			            // if (n < 32) {
			                // var low = (this.low >>> n) | (this.high << (32 - n));
			                // var high = this.high >>> n;
			            // } else {
			                // var low = this.high >>> (n - 32);
			                // var high = 0;
			            // }

			            // return X64Word.create(high, low);
			        // },

			        /**
			         * Rotates this word n bits to the left.
			         *
			         * @param {number} n The number of bits to rotate.
			         *
			         * @return {X64Word} A new x64-Word object after rotating.
			         *
			         * @example
			         *
			         *     var rotated = x64Word.rotL(25);
			         */
			        // rotL: function (n) {
			            // return this.shiftL(n).or(this.shiftR(64 - n));
			        // },

			        /**
			         * Rotates this word n bits to the right.
			         *
			         * @param {number} n The number of bits to rotate.
			         *
			         * @return {X64Word} A new x64-Word object after rotating.
			         *
			         * @example
			         *
			         *     var rotated = x64Word.rotR(7);
			         */
			        // rotR: function (n) {
			            // return this.shiftR(n).or(this.shiftL(64 - n));
			        // },

			        /**
			         * Adds this word with the passed word.
			         *
			         * @param {X64Word} word The x64-Word to add with this word.
			         *
			         * @return {X64Word} A new x64-Word object after adding.
			         *
			         * @example
			         *
			         *     var added = x64Word.add(anotherX64Word);
			         */
			        // add: function (word) {
			            // var low = (this.low + word.low) | 0;
			            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
			            // var high = (this.high + word.high + carry) | 0;

			            // return X64Word.create(high, low);
			        // }
			    });

			    /**
			     * An array of 64-bit words.
			     *
			     * @property {Array} words The array of CryptoJS.x64.Word objects.
			     * @property {number} sigBytes The number of significant bytes in this word array.
			     */
			    C_x64.WordArray = Base.extend({
			        /**
			         * Initializes a newly created word array.
			         *
			         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
			         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
			         *
			         * @example
			         *
			         *     var wordArray = CryptoJS.x64.WordArray.create();
			         *
			         *     var wordArray = CryptoJS.x64.WordArray.create([
			         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
			         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
			         *     ]);
			         *
			         *     var wordArray = CryptoJS.x64.WordArray.create([
			         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
			         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
			         *     ], 10);
			         */
			        init: function (words, sigBytes) {
			            words = this.words = words || [];

			            if (sigBytes != undefined$1) {
			                this.sigBytes = sigBytes;
			            } else {
			                this.sigBytes = words.length * 8;
			            }
			        },

			        /**
			         * Converts this 64-bit word array to a 32-bit word array.
			         *
			         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
			         *
			         * @example
			         *
			         *     var x32WordArray = x64WordArray.toX32();
			         */
			        toX32: function () {
			            // Shortcuts
			            var x64Words = this.words;
			            var x64WordsLength = x64Words.length;

			            // Convert
			            var x32Words = [];
			            for (var i = 0; i < x64WordsLength; i++) {
			                var x64Word = x64Words[i];
			                x32Words.push(x64Word.high);
			                x32Words.push(x64Word.low);
			            }

			            return X32WordArray.create(x32Words, this.sigBytes);
			        },

			        /**
			         * Creates a copy of this word array.
			         *
			         * @return {X64WordArray} The clone.
			         *
			         * @example
			         *
			         *     var clone = x64WordArray.clone();
			         */
			        clone: function () {
			            var clone = Base.clone.call(this);

			            // Clone "words" array
			            var words = clone.words = this.words.slice(0);

			            // Clone each X64Word object
			            var wordsLength = words.length;
			            for (var i = 0; i < wordsLength; i++) {
			                words[i] = words[i].clone();
			            }

			            return clone;
			        }
			    });
			}());


			return CryptoJS;

		}));
} (x64Core));
	return x64CoreExports;
}

(function (module, exports) {
(function (root, factory, undef) {
		{
			// CommonJS
			module.exports = factory(requireCore(), requireX64Core());
		}
	}(commonjsGlobal, function (CryptoJS) {

		(function (Math) {
		    // Shortcuts
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var Hasher = C_lib.Hasher;
		    var C_x64 = C.x64;
		    var X64Word = C_x64.Word;
		    var C_algo = C.algo;

		    // Constants tables
		    var RHO_OFFSETS = [];
		    var PI_INDEXES  = [];
		    var ROUND_CONSTANTS = [];

		    // Compute Constants
		    (function () {
		        // Compute rho offset constants
		        var x = 1, y = 0;
		        for (var t = 0; t < 24; t++) {
		            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

		            var newX = y % 5;
		            var newY = (2 * x + 3 * y) % 5;
		            x = newX;
		            y = newY;
		        }

		        // Compute pi index constants
		        for (var x = 0; x < 5; x++) {
		            for (var y = 0; y < 5; y++) {
		                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
		            }
		        }

		        // Compute round constants
		        var LFSR = 0x01;
		        for (var i = 0; i < 24; i++) {
		            var roundConstantMsw = 0;
		            var roundConstantLsw = 0;

		            for (var j = 0; j < 7; j++) {
		                if (LFSR & 0x01) {
		                    var bitPosition = (1 << j) - 1;
		                    if (bitPosition < 32) {
		                        roundConstantLsw ^= 1 << bitPosition;
		                    } else /* if (bitPosition >= 32) */ {
		                        roundConstantMsw ^= 1 << (bitPosition - 32);
		                    }
		                }

		                // Compute next LFSR
		                if (LFSR & 0x80) {
		                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
		                    LFSR = (LFSR << 1) ^ 0x71;
		                } else {
		                    LFSR <<= 1;
		                }
		            }

		            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
		        }
		    }());

		    // Reusable objects for temporary values
		    var T = [];
		    (function () {
		        for (var i = 0; i < 25; i++) {
		            T[i] = X64Word.create();
		        }
		    }());

		    /**
		     * SHA-3 hash algorithm.
		     */
		    var SHA3 = C_algo.SHA3 = Hasher.extend({
		        /**
		         * Configuration options.
		         *
		         * @property {number} outputLength
		         *   The desired number of bits in the output hash.
		         *   Only values permitted are: 224, 256, 384, 512.
		         *   Default: 512
		         */
		        cfg: Hasher.cfg.extend({
		            outputLength: 512
		        }),

		        _doReset: function () {
		            var state = this._state = [];
		            for (var i = 0; i < 25; i++) {
		                state[i] = new X64Word.init();
		            }

		            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
		        },

		        _doProcessBlock: function (M, offset) {
		            // Shortcuts
		            var state = this._state;
		            var nBlockSizeLanes = this.blockSize / 2;

		            // Absorb
		            for (var i = 0; i < nBlockSizeLanes; i++) {
		                // Shortcuts
		                var M2i  = M[offset + 2 * i];
		                var M2i1 = M[offset + 2 * i + 1];

		                // Swap endian
		                M2i = (
		                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
		                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
		                );
		                M2i1 = (
		                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
		                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
		                );

		                // Absorb message into state
		                var lane = state[i];
		                lane.high ^= M2i1;
		                lane.low  ^= M2i;
		            }

		            // Rounds
		            for (var round = 0; round < 24; round++) {
		                // Theta
		                for (var x = 0; x < 5; x++) {
		                    // Mix column lanes
		                    var tMsw = 0, tLsw = 0;
		                    for (var y = 0; y < 5; y++) {
		                        var lane = state[x + 5 * y];
		                        tMsw ^= lane.high;
		                        tLsw ^= lane.low;
		                    }

		                    // Temporary values
		                    var Tx = T[x];
		                    Tx.high = tMsw;
		                    Tx.low  = tLsw;
		                }
		                for (var x = 0; x < 5; x++) {
		                    // Shortcuts
		                    var Tx4 = T[(x + 4) % 5];
		                    var Tx1 = T[(x + 1) % 5];
		                    var Tx1Msw = Tx1.high;
		                    var Tx1Lsw = Tx1.low;

		                    // Mix surrounding columns
		                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
		                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
		                    for (var y = 0; y < 5; y++) {
		                        var lane = state[x + 5 * y];
		                        lane.high ^= tMsw;
		                        lane.low  ^= tLsw;
		                    }
		                }

		                // Rho Pi
		                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
		                    var tMsw;
		                    var tLsw;

		                    // Shortcuts
		                    var lane = state[laneIndex];
		                    var laneMsw = lane.high;
		                    var laneLsw = lane.low;
		                    var rhoOffset = RHO_OFFSETS[laneIndex];

		                    // Rotate lanes
		                    if (rhoOffset < 32) {
		                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
		                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
		                    } else /* if (rhoOffset >= 32) */ {
		                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
		                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
		                    }

		                    // Transpose lanes
		                    var TPiLane = T[PI_INDEXES[laneIndex]];
		                    TPiLane.high = tMsw;
		                    TPiLane.low  = tLsw;
		                }

		                // Rho pi at x = y = 0
		                var T0 = T[0];
		                var state0 = state[0];
		                T0.high = state0.high;
		                T0.low  = state0.low;

		                // Chi
		                for (var x = 0; x < 5; x++) {
		                    for (var y = 0; y < 5; y++) {
		                        // Shortcuts
		                        var laneIndex = x + 5 * y;
		                        var lane = state[laneIndex];
		                        var TLane = T[laneIndex];
		                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
		                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

		                        // Mix rows
		                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
		                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
		                    }
		                }

		                // Iota
		                var lane = state[0];
		                var roundConstant = ROUND_CONSTANTS[round];
		                lane.high ^= roundConstant.high;
		                lane.low  ^= roundConstant.low;
		            }
		        },

		        _doFinalize: function () {
		            // Shortcuts
		            var data = this._data;
		            var dataWords = data.words;
		            this._nDataBytes * 8;
		            var nBitsLeft = data.sigBytes * 8;
		            var blockSizeBits = this.blockSize * 32;

		            // Add padding
		            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
		            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
		            data.sigBytes = dataWords.length * 4;

		            // Hash final blocks
		            this._process();

		            // Shortcuts
		            var state = this._state;
		            var outputLengthBytes = this.cfg.outputLength / 8;
		            var outputLengthLanes = outputLengthBytes / 8;

		            // Squeeze
		            var hashWords = [];
		            for (var i = 0; i < outputLengthLanes; i++) {
		                // Shortcuts
		                var lane = state[i];
		                var laneMsw = lane.high;
		                var laneLsw = lane.low;

		                // Swap endian
		                laneMsw = (
		                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
		                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
		                );
		                laneLsw = (
		                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
		                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
		                );

		                // Squeeze state to retrieve hash
		                hashWords.push(laneLsw);
		                hashWords.push(laneMsw);
		            }

		            // Return final computed hash
		            return new WordArray.init(hashWords, outputLengthBytes);
		        },

		        clone: function () {
		            var clone = Hasher.clone.call(this);

		            var state = clone._state = this._state.slice(0);
		            for (var i = 0; i < 25; i++) {
		                state[i] = state[i].clone();
		            }

		            return clone;
		        }
		    });

		    /**
		     * Shortcut function to the hasher's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     *
		     * @return {WordArray} The hash.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hash = CryptoJS.SHA3('message');
		     *     var hash = CryptoJS.SHA3(wordArray);
		     */
		    C.SHA3 = Hasher._createHelper(SHA3);

		    /**
		     * Shortcut function to the HMAC's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     * @param {WordArray|string} key The secret key.
		     *
		     * @return {WordArray} The HMAC.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hmac = CryptoJS.HmacSHA3(message, key);
		     */
		    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
		}(Math));


		return CryptoJS.SHA3;

	}));
} (sha3$2));

var libTypedarraysExports = {};
var libTypedarrays = {
  get exports(){ return libTypedarraysExports; },
  set exports(v){ libTypedarraysExports = v; },
};

(function (module, exports) {
(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(requireCore());
		}
	}(commonjsGlobal, function (CryptoJS) {

		(function () {
		    // Check if typed arrays are supported
		    if (typeof ArrayBuffer != 'function') {
		        return;
		    }

		    // Shortcuts
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;

		    // Reference original init
		    var superInit = WordArray.init;

		    // Augment WordArray.init to handle typed arrays
		    var subInit = WordArray.init = function (typedArray) {
		        // Convert buffers to uint8
		        if (typedArray instanceof ArrayBuffer) {
		            typedArray = new Uint8Array(typedArray);
		        }

		        // Convert other array views to uint8
		        if (
		            typedArray instanceof Int8Array ||
		            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
		            typedArray instanceof Int16Array ||
		            typedArray instanceof Uint16Array ||
		            typedArray instanceof Int32Array ||
		            typedArray instanceof Uint32Array ||
		            typedArray instanceof Float32Array ||
		            typedArray instanceof Float64Array
		        ) {
		            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
		        }

		        // Handle Uint8Array
		        if (typedArray instanceof Uint8Array) {
		            // Shortcut
		            var typedArrayByteLength = typedArray.byteLength;

		            // Extract bytes
		            var words = [];
		            for (var i = 0; i < typedArrayByteLength; i++) {
		                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
		            }

		            // Initialize this word array
		            superInit.call(this, words, typedArrayByteLength);
		        } else {
		            // Else call normal init
		            superInit.apply(this, arguments);
		        }
		    };

		    subInit.prototype = WordArray;
		}());


		return CryptoJS.lib.WordArray;

	}));
} (libTypedarrays));

var __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(namehash, "__esModule", { value: true });
namehash.fromDecStringToHex = namehash.fromHexStringToDecimals = namehash.znsChildhash = namehash.znsNamehash = namehash.eip137Childhash = namehash.eip137Namehash = void 0;
var sha256_1 = __importDefault$5(sha256Exports);
var sha3_1 = __importDefault$5(sha3Exports$1);
var enc_hex_1 = __importDefault$5(encHexExports);
var lib_typedarrays_1 = __importDefault$5(libTypedarraysExports);
var bn_js_1$1 = __importDefault$5(bnExports$1);
function eip137Namehash(domain) {
    var arr = hashArray(domain, 'sha3');
    return arrayToHex(arr);
}
namehash.eip137Namehash = eip137Namehash;
function eip137Childhash(parentHash, label) {
    return childhash(parentHash, label, 'sha3');
}
namehash.eip137Childhash = eip137Childhash;
function znsNamehash(domain) {
    var arr = hashArray(domain, 'sha256');
    return arrayToHex(arr);
}
namehash.znsNamehash = znsNamehash;
function znsChildhash(parentHash, label) {
    return childhash(parentHash, label, 'sha256');
}
namehash.znsChildhash = znsChildhash;
function childhash(parentHash, label, hashingAlgo) {
    var hash = hashingAlgo === 'sha256' ? sha256_1.default : sha3_1.default;
    var opts = { outputLength: 256 };
    var parent = parentHash.replace(/^0x/, '');
    var childHash = enc_hex_1.default.stringify(hash(label, opts));
    return "0x".concat(enc_hex_1.default.stringify(hash(enc_hex_1.default.parse("".concat(parent).concat(childHash)), opts)));
}
function hashArray(domain, hashingAlgo) {
    if (!domain) {
        return lib_typedarrays_1.default.create(Array.from(new Uint8Array(8)));
    }
    var hash = hashingAlgo === 'sha256' ? sha256_1.default : sha3_1.default;
    var opts = { outputLength: 256 };
    var _a = domain.split('.'), label = _a[0], remainder = _a.slice(1);
    var labelHash = hash(label, opts);
    var remainderHash = hashArray(remainder.join('.'), hashingAlgo);
    return hash(remainderHash.concat(labelHash), opts);
}
function arrayToHex(arr) {
    return "0x".concat(enc_hex_1.default.stringify(arr));
}
function fromHexStringToDecimals(value) {
    if (value.startsWith('0x')) {
        var valueWithoutPrefix = value.slice(2, value.length);
        var bn = new bn_js_1$1.default(valueWithoutPrefix, 16);
        return bn.toString(10);
    }
    return value;
}
namehash.fromHexStringToDecimals = fromHexStringToDecimals;
function fromDecStringToHex(value) {
    if (!value.startsWith('0x')) {
        var bn = new bn_js_1$1.default(value, 10);
        var bnString = bn.toString(16);
        return "0x".concat(bnString.padStart(64, '0'));
    }
    return value;
}
namehash.fromDecStringToHex = fromDecStringToHex;

var NamingService$1 = {};

Object.defineProperty(NamingService$1, "__esModule", { value: true });
NamingService$1.NamingService = void 0;
var NamingService = /** @class */ (function () {
    function NamingService() {
    }
    return NamingService;
}());
NamingService$1.NamingService = NamingService;

var configurationError = {};

(function (exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var _a;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ConfigurationError = exports.ConfigurationErrorCode = void 0;
	var ConfigurationErrorCode;
	(function (ConfigurationErrorCode) {
	    ConfigurationErrorCode["IncorrectProvider"] = "IncorrectProvider";
	    ConfigurationErrorCode["UnsupportedNetwork"] = "UnsupportedNetwork";
	    ConfigurationErrorCode["UnspecifiedUrl"] = "UnspecifiedUrl";
	    ConfigurationErrorCode["NetworkConfigMissing"] = "NetworkConfigMissing";
	    ConfigurationErrorCode["CustomNetworkConfigMissing"] = "CustomNetworkConfigMissing";
	    ConfigurationErrorCode["InvalidConfigurationField"] = "InvalidProxyReader";
	})(ConfigurationErrorCode = exports.ConfigurationErrorCode || (exports.ConfigurationErrorCode = {}));
	/**
	 * @internal
	 * Internal Mapping object from ConfigurationErrorCode to a ConfigurationErrorHandler
	 */
	var HandlersByCode = (_a = {},
	    _a[ConfigurationErrorCode.IncorrectProvider] = function () {
	        return "Provider doesn't implement sendAsync or send method";
	    },
	    _a[ConfigurationErrorCode.UnsupportedNetwork] = function (params) {
	        return "Unsupported network in Resolution ".concat(params.method || '', " configuration");
	    },
	    _a[ConfigurationErrorCode.UnspecifiedUrl] = function (params) { return "Unspecified url in Resolution ".concat(params.method, " configuration"); },
	    _a[ConfigurationErrorCode.NetworkConfigMissing] = function (params) {
	        return "Missing configuration in Resolution ".concat(params.method, ". Please specify ").concat(params.config);
	    },
	    _a[ConfigurationErrorCode.CustomNetworkConfigMissing] = function (params) {
	        return "Missing configuration in Resolution ".concat(params.method, ". Please specify ").concat(params.config, " when using a custom network");
	    },
	    _a[ConfigurationErrorCode.InvalidConfigurationField] = function (params) { return "Invalid '".concat(params.field, "' in Resolution ").concat(params.method); },
	    _a);
	/**
	 * Configuration Error class is designed to control every error being thrown by wrong configurations for objects
	 * @param code - Error Code
	 * - IncorrectProvider - When provider doesn't have implemented send or sendAsync methods
	 * - UnsupportedNetwork - When network is not specified or not supported
	 * - UnspecifiedUrl - When url is not specified for custom naming service configurations
	 * - CustomNetworkConfigMissing - When configuration is missing for custom network configurations
	 * @param method - optional param to specify which namingService errored out
	 */
	var ConfigurationError = /** @class */ (function (_super) {
	    __extends(ConfigurationError, _super);
	    function ConfigurationError(code, options) {
	        if (options === void 0) { options = {}; }
	        var _this = this;
	        var configurationErrorHandler = HandlersByCode[code];
	        _this = _super.call(this, configurationErrorHandler(options)) || this;
	        _this.code = code;
	        _this.method = options.method;
	        _this.name = 'ConfigurationError';
	        Object.setPrototypeOf(_this, ConfigurationError.prototype);
	        return _this;
	    }
	    return ConfigurationError;
	}(Error));
	exports.ConfigurationError = ConfigurationError;
	exports.default = ConfigurationError;
} (configurationError));

var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$1 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
var __createBinding$6 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$6 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$6 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$6(result, mod, k);
    __setModuleDefault$6(result, mod);
    return result;
};
var __awaiter$6 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$6 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(Zns$1, "__esModule", { value: true });
var znsUtils_1$1 = znsUtils;
var utils_1$4 = utils$n;
var types_1$2 = types;
var resolutionError_1$6 = resolutionError;
var publicTypes_1$4 = publicTypes;
var FetchProvider_1$2 = __importDefault$4(FetchProvider$1);
var namehash_1$5 = namehash;
var NamingService_1$2 = NamingService$1;
var configurationError_1$3 = __importStar$6(configurationError);
/**
 * @internal
 */
var Zns = /** @class */ (function (_super) {
    __extends$2(Zns, _super);
    function Zns(source) {
        if (source === void 0) { source = {
            url: Zns.UrlMap[1],
            network: 'mainnet',
        }; }
        var _this = _super.call(this) || this;
        _this.name = publicTypes_1$4.NamingServiceName.ZNS;
        _this.checkNetworkConfig(source);
        _this.network = Zns.NetworkNameMap[source.network];
        _this.url = source['url'] || Zns.UrlMap[_this.network];
        _this.provider =
            source['provider'] || new FetchProvider_1$2.default(_this.name, _this.url);
        _this.registryAddr =
            source['registryAddress'] || Zns.RegistryMap[_this.network];
        _this.checkRegistryAddress(_this.registryAddr);
        if (_this.registryAddr.startsWith('0x')) {
            _this.registryAddr = (0, znsUtils_1$1.toBech32Address)(_this.registryAddr);
        }
        return _this;
    }
    Zns.prototype.owner = function (domain) {
        return __awaiter$6(this, void 0, void 0, function () {
            var recordAddresses, ownerAddress;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getRecordsAddresses(domain)];
                    case 1:
                        recordAddresses = _a.sent();
                        if (!recordAddresses) {
                            throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnregisteredDomain, {
                                domain: domain,
                            });
                        }
                        ownerAddress = recordAddresses[0];
                        if (!ownerAddress) {
                            throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnregisteredDomain, {
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, ownerAddress];
                }
            });
        });
    };
    Zns.prototype.resolver = function (domain) {
        return __awaiter$6(this, void 0, void 0, function () {
            var recordsAddresses, resolverAddress;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getRecordsAddresses(domain)];
                    case 1:
                        recordsAddresses = _a.sent();
                        if (!recordsAddresses || !recordsAddresses[0]) {
                            throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnregisteredDomain, {
                                domain: domain,
                            });
                        }
                        resolverAddress = recordsAddresses[1];
                        if ((0, utils_1$4.isNullAddress)(resolverAddress)) {
                            throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnspecifiedResolver, {
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, resolverAddress];
                }
            });
        });
    };
    Zns.prototype.namehash = function (domain) {
        if (!this.checkDomain(domain)) {
            throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnsupportedDomain, {
                domain: domain,
            });
        }
        return (0, namehash_1$5.znsNamehash)(domain);
    };
    Zns.prototype.childhash = function (parentHash, label) {
        return (0, namehash_1$5.znsChildhash)(parentHash, label);
    };
    Zns.prototype.isSupportedDomain = function (domain) {
        return __awaiter$6(this, void 0, void 0, function () {
            return __generator$6(this, function (_a) {
                return [2 /*return*/, this.checkDomain(domain)];
            });
        });
    };
    Zns.prototype.record = function (domain, key) {
        return __awaiter$6(this, void 0, void 0, function () {
            var records, record;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.records(domain, [key])];
                    case 1:
                        records = _a.sent();
                        record = records[key];
                        if (!record) {
                            throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.RecordNotFound, {
                                domain: domain,
                                recordName: key,
                            });
                        }
                        return [2 /*return*/, record];
                }
            });
        });
    };
    Zns.prototype.records = function (domain, keys) {
        return __awaiter$6(this, void 0, void 0, function () {
            var records;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.allRecords(domain)];
                    case 1:
                        records = _a.sent();
                        return [2 /*return*/, (0, utils_1$4.constructRecords)(keys, records)];
                }
            });
        });
    };
    Zns.prototype.allRecords = function (domain) {
        return __awaiter$6(this, void 0, void 0, function () {
            var resolverAddress;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.resolver(domain)];
                    case 1:
                        resolverAddress = _a.sent();
                        return [2 /*return*/, this.getResolverRecords(resolverAddress)];
                }
            });
        });
    };
    Zns.prototype.twitter = function (domain) {
        return __awaiter$6(this, void 0, void 0, function () {
            return __generator$6(this, function (_a) {
                throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnsupportedMethod, {
                    domain: domain,
                    methodName: 'twitter',
                });
            });
        });
    };
    Zns.prototype.reverse = function (address, currencyTicker) {
        return __awaiter$6(this, void 0, void 0, function () {
            return __generator$6(this, function (_a) {
                throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'reverse',
                });
            });
        });
    };
    Zns.prototype.reverseOf = function (address, location) {
        return __awaiter$6(this, void 0, void 0, function () {
            return __generator$6(this, function (_a) {
                throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'reverseOf',
                });
            });
        });
    };
    Zns.prototype.isRegistered = function (domain) {
        return __awaiter$6(this, void 0, void 0, function () {
            var recordAddresses;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getRecordsAddresses(domain)];
                    case 1:
                        recordAddresses = _a.sent();
                        return [2 /*return*/, Boolean(recordAddresses && recordAddresses[0])];
                }
            });
        });
    };
    Zns.prototype.getTokenUri = function (tokenId) {
        return __awaiter$6(this, void 0, void 0, function () {
            return __generator$6(this, function (_a) {
                throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'getTokenUri',
                });
            });
        });
    };
    Zns.prototype.getDomainFromTokenId = function (tokenId) {
        return __awaiter$6(this, void 0, void 0, function () {
            return __generator$6(this, function (_a) {
                throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'getDomainFromTokenId',
                });
            });
        });
    };
    Zns.prototype.isAvailable = function (domain) {
        return __awaiter$6(this, void 0, void 0, function () {
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isRegistered(domain)];
                    case 1: return [2 /*return*/, !(_a.sent())];
                }
            });
        });
    };
    Zns.prototype.registryAddress = function (domain) {
        return __awaiter$6(this, void 0, void 0, function () {
            return __generator$6(this, function (_a) {
                return [2 /*return*/, this.registryAddr];
            });
        });
    };
    Zns.prototype.locations = function (domains) {
        return __awaiter$6(this, void 0, void 0, function () {
            var recordsAddresses;
            var _this = this;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(domains.map(function (domain) { return _this.getRecordsAddresses(domain); }))];
                    case 1:
                        recordsAddresses = _a.sent();
                        return [2 /*return*/, domains.reduce(function (locations, domain, i) {
                                var _a;
                                var location = null;
                                var domainRecordsAddresses = recordsAddresses[i];
                                if (domainRecordsAddresses) {
                                    var ownerAddress = domainRecordsAddresses[0], resolverAddress = domainRecordsAddresses[1];
                                    location = {
                                        registryAddress: _this.registryAddr,
                                        resolverAddress: resolverAddress,
                                        networkId: _this.network,
                                        blockchain: publicTypes_1$4.BlockchainType.ZIL,
                                        ownerAddress: ownerAddress,
                                        blockchainProviderUrl: _this.url,
                                    };
                                }
                                return __assign$1(__assign$1({}, locations), (_a = {}, _a[domain] = location, _a));
                            }, {})];
                }
            });
        });
    };
    Zns.prototype.getRecordsAddresses = function (domain) {
        return __awaiter$6(this, void 0, void 0, function () {
            var registryRecord, _a, ownerAddress, resolverAddress;
            return __generator$6(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.isSupportedDomain(domain)) {
                            throw new resolutionError_1$6.ResolutionError(resolutionError_1$6.ResolutionErrorCode.UnsupportedDomain, {
                                domain: domain,
                            });
                        }
                        return [4 /*yield*/, this.getContractMapValue(this.registryAddr, 'records', this.namehash(domain))];
                    case 1:
                        registryRecord = _b.sent();
                        if (!registryRecord) {
                            return [2 /*return*/, undefined];
                        }
                        _a = registryRecord.arguments, ownerAddress = _a[0], resolverAddress = _a[1];
                        return [2 /*return*/, [
                                ownerAddress.startsWith('0x')
                                    ? (0, znsUtils_1$1.toBech32Address)(ownerAddress)
                                    : ownerAddress,
                                resolverAddress,
                            ]];
                }
            });
        });
    };
    Zns.prototype.getResolverRecords = function (resolverAddress) {
        return __awaiter$6(this, void 0, void 0, function () {
            var resolver;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if ((0, utils_1$4.isNullAddress)(resolverAddress)) {
                            return [2 /*return*/, {}];
                        }
                        resolver = (0, znsUtils_1$1.toChecksumAddress)(resolverAddress);
                        return [4 /*yield*/, this.getContractField(resolver, 'records')];
                    case 1: return [2 /*return*/, ((_a.sent()) ||
                            {})];
                }
            });
        });
    };
    Zns.prototype.fetchSubState = function (contractAddress, field, keys) {
        if (keys === void 0) { keys = []; }
        return __awaiter$6(this, void 0, void 0, function () {
            var params, method;
            return __generator$6(this, function (_a) {
                params = [contractAddress.replace('0x', ''), field, keys];
                method = 'GetSmartContractSubState';
                return [2 /*return*/, this.provider.request({ method: method, params: params })];
            });
        });
    };
    Zns.prototype.getContractField = function (contractAddress, field, keys) {
        if (keys === void 0) { keys = []; }
        return __awaiter$6(this, void 0, void 0, function () {
            var contractAddr, result;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contractAddr = contractAddress.startsWith('zil1')
                            ? (0, znsUtils_1$1.fromBech32Address)(contractAddress)
                            : contractAddress;
                        return [4 /*yield*/, this.fetchSubState(contractAddr, field, keys)];
                    case 1:
                        result = (_a.sent()) || {};
                        return [2 /*return*/, result[field]];
                }
            });
        });
    };
    Zns.prototype.getContractMapValue = function (contractAddress, field, key) {
        return __awaiter$6(this, void 0, void 0, function () {
            var record;
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getContractField(contractAddress, field, [key])];
                    case 1:
                        record = _a.sent();
                        return [2 /*return*/, (record && record[key]) || null];
                }
            });
        });
    };
    Zns.prototype.checkDomain = function (domain) {
        var tokens = domain.split('.');
        return (!!tokens.length &&
            tokens[tokens.length - 1] === 'zil' &&
            tokens.every(function (v) { return !!v.length; }));
    };
    Zns.prototype.checkNetworkConfig = function (source) {
        if (!source.network) {
            throw new configurationError_1$3.default(configurationError_1$3.ConfigurationErrorCode.UnsupportedNetwork, {
                method: publicTypes_1$4.NamingServiceName.ZNS,
            });
        }
        if (!types_1$2.ZnsSupportedNetwork.guard(source.network)) {
            this.checkCustomNetworkConfig(source);
        }
    };
    Zns.prototype.checkRegistryAddress = function (address) {
        // Represents both versions of Zilliqa addresses eth-like and bech32 zil-like
        var addressValidator = new RegExp('^0x[a-fA-F0-9]{40}$|^zil1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$');
        if (!addressValidator.test(address)) {
            throw new configurationError_1$3.default(configurationError_1$3.ConfigurationErrorCode.InvalidConfigurationField, {
                method: this.name,
                field: 'registryAddress',
            });
        }
    };
    Zns.prototype.checkCustomNetworkConfig = function (source) {
        if (!source.registryAddress) {
            throw new configurationError_1$3.default(configurationError_1$3.ConfigurationErrorCode.CustomNetworkConfigMissing, {
                method: publicTypes_1$4.NamingServiceName.ZNS,
                config: 'registryAddress',
            });
        }
        if (!source['url'] && !source['provider']) {
            throw new configurationError_1$3.default(configurationError_1$3.ConfigurationErrorCode.CustomNetworkConfigMissing, {
                method: publicTypes_1$4.NamingServiceName.ZNS,
                config: 'url or provider',
            });
        }
    };
    Zns.UrlMap = {
        1: 'https://api.zilliqa.com',
        333: 'https://dev-api.zilliqa.com',
        111: 'http://localhost:4201',
    };
    Zns.NetworkNameMap = {
        mainnet: 1,
        testnet: 333,
        localnet: 111,
    };
    Zns.RegistryMap = {
        1: 'zil1jcgu2wlx6xejqk9jw3aaankw6lsjzeunx2j0jz',
        333: 'zil1hyj6m5w4atcn7s806s69r0uh5g4t84e8gp6nps',
    };
    return Zns;
}(NamingService_1$2.NamingService));
Zns$1.default = Zns;

var Uns$1 = {};

var TwitterSignatureValidator = {};

var sha3Exports = {};
var sha3$1 = {
  get exports(){ return sha3Exports; },
  set exports(v){ sha3Exports = v; },
};

/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */

(function (module) {
	/*jslint bitwise: true */
	(function () {

	  var INPUT_ERROR = 'input is invalid type';
	  var FINALIZE_ERROR = 'finalize already called';
	  var WINDOW = typeof window === 'object';
	  var root = WINDOW ? window : {};
	  if (root.JS_SHA3_NO_WINDOW) {
	    WINDOW = false;
	  }
	  var WEB_WORKER = !WINDOW && typeof self === 'object';
	  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
	  if (NODE_JS) {
	    root = commonjsGlobal;
	  } else if (WEB_WORKER) {
	    root = self;
	  }
	  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
	  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
	  var HEX_CHARS = '0123456789abcdef'.split('');
	  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
	  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
	  var KECCAK_PADDING = [1, 256, 65536, 16777216];
	  var PADDING = [6, 1536, 393216, 100663296];
	  var SHIFT = [0, 8, 16, 24];
	  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
	    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
	    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
	    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
	    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
	  var BITS = [224, 256, 384, 512];
	  var SHAKE_BITS = [128, 256];
	  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
	  var CSHAKE_BYTEPAD = {
	    '128': 168,
	    '256': 136
	  };

	  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
	    Array.isArray = function (obj) {
	      return Object.prototype.toString.call(obj) === '[object Array]';
	    };
	  }

	  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
	    ArrayBuffer.isView = function (obj) {
	      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
	    };
	  }

	  var createOutputMethod = function (bits, padding, outputType) {
	    return function (message) {
	      return new Keccak(bits, padding, bits).update(message)[outputType]();
	    };
	  };

	  var createShakeOutputMethod = function (bits, padding, outputType) {
	    return function (message, outputBits) {
	      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
	    };
	  };

	  var createCshakeOutputMethod = function (bits, padding, outputType) {
	    return function (message, outputBits, n, s) {
	      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
	    };
	  };

	  var createKmacOutputMethod = function (bits, padding, outputType) {
	    return function (key, message, outputBits, s) {
	      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
	    };
	  };

	  var createOutputMethods = function (method, createMethod, bits, padding) {
	    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
	      var type = OUTPUT_TYPES[i];
	      method[type] = createMethod(bits, padding, type);
	    }
	    return method;
	  };

	  var createMethod = function (bits, padding) {
	    var method = createOutputMethod(bits, padding, 'hex');
	    method.create = function () {
	      return new Keccak(bits, padding, bits);
	    };
	    method.update = function (message) {
	      return method.create().update(message);
	    };
	    return createOutputMethods(method, createOutputMethod, bits, padding);
	  };

	  var createShakeMethod = function (bits, padding) {
	    var method = createShakeOutputMethod(bits, padding, 'hex');
	    method.create = function (outputBits) {
	      return new Keccak(bits, padding, outputBits);
	    };
	    method.update = function (message, outputBits) {
	      return method.create(outputBits).update(message);
	    };
	    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
	  };

	  var createCshakeMethod = function (bits, padding) {
	    var w = CSHAKE_BYTEPAD[bits];
	    var method = createCshakeOutputMethod(bits, padding, 'hex');
	    method.create = function (outputBits, n, s) {
	      if (!n && !s) {
	        return methods['shake' + bits].create(outputBits);
	      } else {
	        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
	      }
	    };
	    method.update = function (message, outputBits, n, s) {
	      return method.create(outputBits, n, s).update(message);
	    };
	    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
	  };

	  var createKmacMethod = function (bits, padding) {
	    var w = CSHAKE_BYTEPAD[bits];
	    var method = createKmacOutputMethod(bits, padding, 'hex');
	    method.create = function (key, outputBits, s) {
	      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
	    };
	    method.update = function (key, message, outputBits, s) {
	      return method.create(key, outputBits, s).update(message);
	    };
	    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
	  };

	  var algorithms = [
	    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
	    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
	    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
	    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
	    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
	  ];

	  var methods = {}, methodNames = [];

	  for (var i = 0; i < algorithms.length; ++i) {
	    var algorithm = algorithms[i];
	    var bits = algorithm.bits;
	    for (var j = 0; j < bits.length; ++j) {
	      var methodName = algorithm.name + '_' + bits[j];
	      methodNames.push(methodName);
	      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
	      if (algorithm.name !== 'sha3') {
	        var newMethodName = algorithm.name + bits[j];
	        methodNames.push(newMethodName);
	        methods[newMethodName] = methods[methodName];
	      }
	    }
	  }

	  function Keccak(bits, padding, outputBits) {
	    this.blocks = [];
	    this.s = [];
	    this.padding = padding;
	    this.outputBits = outputBits;
	    this.reset = true;
	    this.finalized = false;
	    this.block = 0;
	    this.start = 0;
	    this.blockCount = (1600 - (bits << 1)) >> 5;
	    this.byteCount = this.blockCount << 2;
	    this.outputBlocks = outputBits >> 5;
	    this.extraBytes = (outputBits & 31) >> 3;

	    for (var i = 0; i < 50; ++i) {
	      this.s[i] = 0;
	    }
	  }

	  Keccak.prototype.update = function (message) {
	    if (this.finalized) {
	      throw new Error(FINALIZE_ERROR);
	    }
	    var notString, type = typeof message;
	    if (type !== 'string') {
	      if (type === 'object') {
	        if (message === null) {
	          throw new Error(INPUT_ERROR);
	        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
	          message = new Uint8Array(message);
	        } else if (!Array.isArray(message)) {
	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
	            throw new Error(INPUT_ERROR);
	          }
	        }
	      } else {
	        throw new Error(INPUT_ERROR);
	      }
	      notString = true;
	    }
	    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
	      blockCount = this.blockCount, index = 0, s = this.s, i, code;

	    while (index < length) {
	      if (this.reset) {
	        this.reset = false;
	        blocks[0] = this.block;
	        for (i = 1; i < blockCount + 1; ++i) {
	          blocks[i] = 0;
	        }
	      }
	      if (notString) {
	        for (i = this.start; index < length && i < byteCount; ++index) {
	          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
	        }
	      } else {
	        for (i = this.start; index < length && i < byteCount; ++index) {
	          code = message.charCodeAt(index);
	          if (code < 0x80) {
	            blocks[i >> 2] |= code << SHIFT[i++ & 3];
	          } else if (code < 0x800) {
	            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          } else if (code < 0xd800 || code >= 0xe000) {
	            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          } else {
	            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
	            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          }
	        }
	      }
	      this.lastByteIndex = i;
	      if (i >= byteCount) {
	        this.start = i - byteCount;
	        this.block = blocks[blockCount];
	        for (i = 0; i < blockCount; ++i) {
	          s[i] ^= blocks[i];
	        }
	        f(s);
	        this.reset = true;
	      } else {
	        this.start = i;
	      }
	    }
	    return this;
	  };

	  Keccak.prototype.encode = function (x, right) {
	    var o = x & 255, n = 1;
	    var bytes = [o];
	    x = x >> 8;
	    o = x & 255;
	    while (o > 0) {
	      bytes.unshift(o);
	      x = x >> 8;
	      o = x & 255;
	      ++n;
	    }
	    if (right) {
	      bytes.push(n);
	    } else {
	      bytes.unshift(n);
	    }
	    this.update(bytes);
	    return bytes.length;
	  };

	  Keccak.prototype.encodeString = function (str) {
	    var notString, type = typeof str;
	    if (type !== 'string') {
	      if (type === 'object') {
	        if (str === null) {
	          throw new Error(INPUT_ERROR);
	        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
	          str = new Uint8Array(str);
	        } else if (!Array.isArray(str)) {
	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
	            throw new Error(INPUT_ERROR);
	          }
	        }
	      } else {
	        throw new Error(INPUT_ERROR);
	      }
	      notString = true;
	    }
	    var bytes = 0, length = str.length;
	    if (notString) {
	      bytes = length;
	    } else {
	      for (var i = 0; i < str.length; ++i) {
	        var code = str.charCodeAt(i);
	        if (code < 0x80) {
	          bytes += 1;
	        } else if (code < 0x800) {
	          bytes += 2;
	        } else if (code < 0xd800 || code >= 0xe000) {
	          bytes += 3;
	        } else {
	          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
	          bytes += 4;
	        }
	      }
	    }
	    bytes += this.encode(bytes * 8);
	    this.update(str);
	    return bytes;
	  };

	  Keccak.prototype.bytepad = function (strs, w) {
	    var bytes = this.encode(w);
	    for (var i = 0; i < strs.length; ++i) {
	      bytes += this.encodeString(strs[i]);
	    }
	    var paddingBytes = w - bytes % w;
	    var zeros = [];
	    zeros.length = paddingBytes;
	    this.update(zeros);
	    return this;
	  };

	  Keccak.prototype.finalize = function () {
	    if (this.finalized) {
	      return;
	    }
	    this.finalized = true;
	    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
	    blocks[i >> 2] |= this.padding[i & 3];
	    if (this.lastByteIndex === this.byteCount) {
	      blocks[0] = blocks[blockCount];
	      for (i = 1; i < blockCount + 1; ++i) {
	        blocks[i] = 0;
	      }
	    }
	    blocks[blockCount - 1] |= 0x80000000;
	    for (i = 0; i < blockCount; ++i) {
	      s[i] ^= blocks[i];
	    }
	    f(s);
	  };

	  Keccak.prototype.toString = Keccak.prototype.hex = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var hex = '', block;
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        block = s[i];
	        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
	          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
	          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
	          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
	      }
	      if (j % blockCount === 0) {
	        f(s);
	        i = 0;
	      }
	    }
	    if (extraBytes) {
	      block = s[i];
	      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
	      if (extraBytes > 1) {
	        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
	      }
	      if (extraBytes > 2) {
	        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
	      }
	    }
	    return hex;
	  };

	  Keccak.prototype.arrayBuffer = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var bytes = this.outputBits >> 3;
	    var buffer;
	    if (extraBytes) {
	      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
	    } else {
	      buffer = new ArrayBuffer(bytes);
	    }
	    var array = new Uint32Array(buffer);
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        array[j] = s[i];
	      }
	      if (j % blockCount === 0) {
	        f(s);
	      }
	    }
	    if (extraBytes) {
	      array[i] = s[i];
	      buffer = buffer.slice(0, bytes);
	    }
	    return buffer;
	  };

	  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

	  Keccak.prototype.digest = Keccak.prototype.array = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var array = [], offset, block;
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        offset = j << 2;
	        block = s[i];
	        array[offset] = block & 0xFF;
	        array[offset + 1] = (block >> 8) & 0xFF;
	        array[offset + 2] = (block >> 16) & 0xFF;
	        array[offset + 3] = (block >> 24) & 0xFF;
	      }
	      if (j % blockCount === 0) {
	        f(s);
	      }
	    }
	    if (extraBytes) {
	      offset = j << 2;
	      block = s[i];
	      array[offset] = block & 0xFF;
	      if (extraBytes > 1) {
	        array[offset + 1] = (block >> 8) & 0xFF;
	      }
	      if (extraBytes > 2) {
	        array[offset + 2] = (block >> 16) & 0xFF;
	      }
	    }
	    return array;
	  };

	  function Kmac(bits, padding, outputBits) {
	    Keccak.call(this, bits, padding, outputBits);
	  }

	  Kmac.prototype = new Keccak();

	  Kmac.prototype.finalize = function () {
	    this.encode(this.outputBits, true);
	    return Keccak.prototype.finalize.call(this);
	  };

	  var f = function (s) {
	    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
	      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
	      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
	      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
	    for (n = 0; n < 48; n += 2) {
	      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
	      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
	      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
	      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
	      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
	      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
	      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
	      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
	      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
	      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

	      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
	      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
	      s[0] ^= h;
	      s[1] ^= l;
	      s[10] ^= h;
	      s[11] ^= l;
	      s[20] ^= h;
	      s[21] ^= l;
	      s[30] ^= h;
	      s[31] ^= l;
	      s[40] ^= h;
	      s[41] ^= l;
	      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
	      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
	      s[2] ^= h;
	      s[3] ^= l;
	      s[12] ^= h;
	      s[13] ^= l;
	      s[22] ^= h;
	      s[23] ^= l;
	      s[32] ^= h;
	      s[33] ^= l;
	      s[42] ^= h;
	      s[43] ^= l;
	      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
	      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
	      s[4] ^= h;
	      s[5] ^= l;
	      s[14] ^= h;
	      s[15] ^= l;
	      s[24] ^= h;
	      s[25] ^= l;
	      s[34] ^= h;
	      s[35] ^= l;
	      s[44] ^= h;
	      s[45] ^= l;
	      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
	      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
	      s[6] ^= h;
	      s[7] ^= l;
	      s[16] ^= h;
	      s[17] ^= l;
	      s[26] ^= h;
	      s[27] ^= l;
	      s[36] ^= h;
	      s[37] ^= l;
	      s[46] ^= h;
	      s[47] ^= l;
	      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
	      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
	      s[8] ^= h;
	      s[9] ^= l;
	      s[18] ^= h;
	      s[19] ^= l;
	      s[28] ^= h;
	      s[29] ^= l;
	      s[38] ^= h;
	      s[39] ^= l;
	      s[48] ^= h;
	      s[49] ^= l;

	      b0 = s[0];
	      b1 = s[1];
	      b32 = (s[11] << 4) | (s[10] >>> 28);
	      b33 = (s[10] << 4) | (s[11] >>> 28);
	      b14 = (s[20] << 3) | (s[21] >>> 29);
	      b15 = (s[21] << 3) | (s[20] >>> 29);
	      b46 = (s[31] << 9) | (s[30] >>> 23);
	      b47 = (s[30] << 9) | (s[31] >>> 23);
	      b28 = (s[40] << 18) | (s[41] >>> 14);
	      b29 = (s[41] << 18) | (s[40] >>> 14);
	      b20 = (s[2] << 1) | (s[3] >>> 31);
	      b21 = (s[3] << 1) | (s[2] >>> 31);
	      b2 = (s[13] << 12) | (s[12] >>> 20);
	      b3 = (s[12] << 12) | (s[13] >>> 20);
	      b34 = (s[22] << 10) | (s[23] >>> 22);
	      b35 = (s[23] << 10) | (s[22] >>> 22);
	      b16 = (s[33] << 13) | (s[32] >>> 19);
	      b17 = (s[32] << 13) | (s[33] >>> 19);
	      b48 = (s[42] << 2) | (s[43] >>> 30);
	      b49 = (s[43] << 2) | (s[42] >>> 30);
	      b40 = (s[5] << 30) | (s[4] >>> 2);
	      b41 = (s[4] << 30) | (s[5] >>> 2);
	      b22 = (s[14] << 6) | (s[15] >>> 26);
	      b23 = (s[15] << 6) | (s[14] >>> 26);
	      b4 = (s[25] << 11) | (s[24] >>> 21);
	      b5 = (s[24] << 11) | (s[25] >>> 21);
	      b36 = (s[34] << 15) | (s[35] >>> 17);
	      b37 = (s[35] << 15) | (s[34] >>> 17);
	      b18 = (s[45] << 29) | (s[44] >>> 3);
	      b19 = (s[44] << 29) | (s[45] >>> 3);
	      b10 = (s[6] << 28) | (s[7] >>> 4);
	      b11 = (s[7] << 28) | (s[6] >>> 4);
	      b42 = (s[17] << 23) | (s[16] >>> 9);
	      b43 = (s[16] << 23) | (s[17] >>> 9);
	      b24 = (s[26] << 25) | (s[27] >>> 7);
	      b25 = (s[27] << 25) | (s[26] >>> 7);
	      b6 = (s[36] << 21) | (s[37] >>> 11);
	      b7 = (s[37] << 21) | (s[36] >>> 11);
	      b38 = (s[47] << 24) | (s[46] >>> 8);
	      b39 = (s[46] << 24) | (s[47] >>> 8);
	      b30 = (s[8] << 27) | (s[9] >>> 5);
	      b31 = (s[9] << 27) | (s[8] >>> 5);
	      b12 = (s[18] << 20) | (s[19] >>> 12);
	      b13 = (s[19] << 20) | (s[18] >>> 12);
	      b44 = (s[29] << 7) | (s[28] >>> 25);
	      b45 = (s[28] << 7) | (s[29] >>> 25);
	      b26 = (s[38] << 8) | (s[39] >>> 24);
	      b27 = (s[39] << 8) | (s[38] >>> 24);
	      b8 = (s[48] << 14) | (s[49] >>> 18);
	      b9 = (s[49] << 14) | (s[48] >>> 18);

	      s[0] = b0 ^ (~b2 & b4);
	      s[1] = b1 ^ (~b3 & b5);
	      s[10] = b10 ^ (~b12 & b14);
	      s[11] = b11 ^ (~b13 & b15);
	      s[20] = b20 ^ (~b22 & b24);
	      s[21] = b21 ^ (~b23 & b25);
	      s[30] = b30 ^ (~b32 & b34);
	      s[31] = b31 ^ (~b33 & b35);
	      s[40] = b40 ^ (~b42 & b44);
	      s[41] = b41 ^ (~b43 & b45);
	      s[2] = b2 ^ (~b4 & b6);
	      s[3] = b3 ^ (~b5 & b7);
	      s[12] = b12 ^ (~b14 & b16);
	      s[13] = b13 ^ (~b15 & b17);
	      s[22] = b22 ^ (~b24 & b26);
	      s[23] = b23 ^ (~b25 & b27);
	      s[32] = b32 ^ (~b34 & b36);
	      s[33] = b33 ^ (~b35 & b37);
	      s[42] = b42 ^ (~b44 & b46);
	      s[43] = b43 ^ (~b45 & b47);
	      s[4] = b4 ^ (~b6 & b8);
	      s[5] = b5 ^ (~b7 & b9);
	      s[14] = b14 ^ (~b16 & b18);
	      s[15] = b15 ^ (~b17 & b19);
	      s[24] = b24 ^ (~b26 & b28);
	      s[25] = b25 ^ (~b27 & b29);
	      s[34] = b34 ^ (~b36 & b38);
	      s[35] = b35 ^ (~b37 & b39);
	      s[44] = b44 ^ (~b46 & b48);
	      s[45] = b45 ^ (~b47 & b49);
	      s[6] = b6 ^ (~b8 & b0);
	      s[7] = b7 ^ (~b9 & b1);
	      s[16] = b16 ^ (~b18 & b10);
	      s[17] = b17 ^ (~b19 & b11);
	      s[26] = b26 ^ (~b28 & b20);
	      s[27] = b27 ^ (~b29 & b21);
	      s[36] = b36 ^ (~b38 & b30);
	      s[37] = b37 ^ (~b39 & b31);
	      s[46] = b46 ^ (~b48 & b40);
	      s[47] = b47 ^ (~b49 & b41);
	      s[8] = b8 ^ (~b0 & b2);
	      s[9] = b9 ^ (~b1 & b3);
	      s[18] = b18 ^ (~b10 & b12);
	      s[19] = b19 ^ (~b11 & b13);
	      s[28] = b28 ^ (~b20 & b22);
	      s[29] = b29 ^ (~b21 & b23);
	      s[38] = b38 ^ (~b30 & b32);
	      s[39] = b39 ^ (~b31 & b33);
	      s[48] = b48 ^ (~b40 & b42);
	      s[49] = b49 ^ (~b41 & b43);

	      s[0] ^= RC[n];
	      s[1] ^= RC[n + 1];
	    }
	  };

	  if (COMMON_JS) {
	    module.exports = methods;
	  } else {
	    for (i = 0; i < methodNames.length; ++i) {
	      root[methodNames[i]] = methods[methodNames[i]];
	    }
	  }
	})();
} (sha3$1));

var sha3 = sha3Exports;

var recoverSignature = {};

var elliptic = {};

var name = "elliptic";
var version$b = "6.5.4";
var description = "EC cryptography";
var main = "lib/elliptic.js";
var files = [
	"lib"
];
var scripts = {
	lint: "eslint lib test",
	"lint:fix": "npm run lint -- --fix",
	unit: "istanbul test _mocha --reporter=spec test/index.js",
	test: "npm run lint && npm run unit",
	version: "grunt dist && git add dist/"
};
var repository = {
	type: "git",
	url: "git@github.com:indutny/elliptic"
};
var keywords = [
	"EC",
	"Elliptic",
	"curve",
	"Cryptography"
];
var author = "Fedor Indutny <fedor@indutny.com>";
var license = "MIT";
var bugs = {
	url: "https://github.com/indutny/elliptic/issues"
};
var homepage = "https://github.com/indutny/elliptic";
var devDependencies = {
	brfs: "^2.0.2",
	coveralls: "^3.1.0",
	eslint: "^7.6.0",
	grunt: "^1.2.1",
	"grunt-browserify": "^5.3.0",
	"grunt-cli": "^1.3.2",
	"grunt-contrib-connect": "^3.0.0",
	"grunt-contrib-copy": "^1.0.0",
	"grunt-contrib-uglify": "^5.0.0",
	"grunt-mocha-istanbul": "^5.0.2",
	"grunt-saucelabs": "^9.0.1",
	istanbul: "^0.4.5",
	mocha: "^8.0.1"
};
var dependencies = {
	"bn.js": "^4.11.9",
	brorand: "^1.1.0",
	"hash.js": "^1.0.0",
	"hmac-drbg": "^1.0.1",
	inherits: "^2.0.4",
	"minimalistic-assert": "^1.0.1",
	"minimalistic-crypto-utils": "^1.0.1"
};
var require$$0$1 = {
	name: name,
	version: version$b,
	description: description,
	main: main,
	files: files,
	scripts: scripts,
	repository: repository,
	keywords: keywords,
	author: author,
	license: license,
	bugs: bugs,
	homepage: homepage,
	devDependencies: devDependencies,
	dependencies: dependencies
};

var utils$m = {};

var minimalisticAssert = assert$f;

function assert$f(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert$f.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var utils$l = {};

(function (exports) {

	var utils = exports;

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg !== 'string') {
	    for (var i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	    return res;
	  }
	  if (enc === 'hex') {
	    msg = msg.replace(/[^a-z0-9]+/ig, '');
	    if (msg.length % 2 !== 0)
	      msg = '0' + msg;
	    for (var i = 0; i < msg.length; i += 2)
	      res.push(parseInt(msg[i] + msg[i + 1], 16));
	  } else {
	    for (var i = 0; i < msg.length; i++) {
	      var c = msg.charCodeAt(i);
	      var hi = c >> 8;
	      var lo = c & 0xff;
	      if (hi)
	        res.push(hi, lo);
	      else
	        res.push(lo);
	    }
	  }
	  return res;
	}
	utils.toArray = toArray;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils.zero2 = zero2;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils.toHex = toHex;

	utils.encode = function encode(arr, enc) {
	  if (enc === 'hex')
	    return toHex(arr);
	  else
	    return arr;
	};
} (utils$l));

(function (exports) {

	var utils = exports;
	var BN = bnExports$1;
	var minAssert = minimalisticAssert;
	var minUtils = utils$l;

	utils.assert = minAssert;
	utils.toArray = minUtils.toArray;
	utils.zero2 = minUtils.zero2;
	utils.toHex = minUtils.toHex;
	utils.encode = minUtils.encode;

	// Represent num in a w-NAF form
	function getNAF(num, w, bits) {
	  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
	  naf.fill(0);

	  var ws = 1 << (w + 1);
	  var k = num.clone();

	  for (var i = 0; i < naf.length; i++) {
	    var z;
	    var mod = k.andln(ws - 1);
	    if (k.isOdd()) {
	      if (mod > (ws >> 1) - 1)
	        z = (ws >> 1) - mod;
	      else
	        z = mod;
	      k.isubn(z);
	    } else {
	      z = 0;
	    }

	    naf[i] = z;
	    k.iushrn(1);
	  }

	  return naf;
	}
	utils.getNAF = getNAF;

	// Represent k1, k2 in a Joint Sparse Form
	function getJSF(k1, k2) {
	  var jsf = [
	    [],
	    [],
	  ];

	  k1 = k1.clone();
	  k2 = k2.clone();
	  var d1 = 0;
	  var d2 = 0;
	  var m8;
	  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
	    // First phase
	    var m14 = (k1.andln(3) + d1) & 3;
	    var m24 = (k2.andln(3) + d2) & 3;
	    if (m14 === 3)
	      m14 = -1;
	    if (m24 === 3)
	      m24 = -1;
	    var u1;
	    if ((m14 & 1) === 0) {
	      u1 = 0;
	    } else {
	      m8 = (k1.andln(7) + d1) & 7;
	      if ((m8 === 3 || m8 === 5) && m24 === 2)
	        u1 = -m14;
	      else
	        u1 = m14;
	    }
	    jsf[0].push(u1);

	    var u2;
	    if ((m24 & 1) === 0) {
	      u2 = 0;
	    } else {
	      m8 = (k2.andln(7) + d2) & 7;
	      if ((m8 === 3 || m8 === 5) && m14 === 2)
	        u2 = -m24;
	      else
	        u2 = m24;
	    }
	    jsf[1].push(u2);

	    // Second phase
	    if (2 * d1 === u1 + 1)
	      d1 = 1 - d1;
	    if (2 * d2 === u2 + 1)
	      d2 = 1 - d2;
	    k1.iushrn(1);
	    k2.iushrn(1);
	  }

	  return jsf;
	}
	utils.getJSF = getJSF;

	function cachedProperty(obj, name, computer) {
	  var key = '_' + name;
	  obj.prototype[name] = function cachedProperty() {
	    return this[key] !== undefined ? this[key] :
	      this[key] = computer.call(this);
	  };
	}
	utils.cachedProperty = cachedProperty;

	function parseBytes(bytes) {
	  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
	    bytes;
	}
	utils.parseBytes = parseBytes;

	function intFromLE(bytes) {
	  return new BN(bytes, 'hex', 'le');
	}
	utils.intFromLE = intFromLE;
} (utils$m));

var brorandExports = {};
var brorand = {
  get exports(){ return brorandExports; },
  set exports(v){ brorandExports = v; },
};

var r$2;

brorand.exports = function rand(len) {
  if (!r$2)
    r$2 = new Rand(null);

  return r$2.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
brorandExports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require$$0$2;
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

var curve = {};

var BN$8 = bnExports$1;
var utils$k = utils$m;
var getNAF = utils$k.getNAF;
var getJSF = utils$k.getJSF;
var assert$e = utils$k.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$8(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN$8.red(conf.prime) : BN$8.mont(this.p);

  // Useful for many curves
  this.zero = new BN$8(0).toRed(this.red);
  this.one = new BN$8(1).toRed(this.red);
  this.two = new BN$8(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN$8(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$e(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert$e(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils$k.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert$e(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert$e(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils$k.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

var inherits_browserExports = {};
var inherits_browser = {
  get exports(){ return inherits_browserExports; },
  set exports(v){ inherits_browserExports = v; },
};

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

var utils$j = utils$m;
var BN$7 = bnExports$1;
var inherits$3 = inherits_browserExports;
var Base$2 = base;

var assert$d = utils$j.assert;

function ShortCurve(conf) {
  Base$2.call(this, 'short', conf);

  this.a = new BN$7(conf.a, 16).toRed(this.red);
  this.b = new BN$7(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits$3(ShortCurve, Base$2);
var short = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$7(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$7(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$d(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$7(vec.a, 16),
        b: new BN$7(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN$7.mont(num);
  var tinv = new BN$7(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN$7(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN$7(1);
  var y1 = new BN$7(0);
  var x2 = new BN$7(0);
  var y2 = new BN$7(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$7(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point$2(curve, x, y, isRed) {
  Base$2.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$7(x, 16);
    this.y = new BN$7(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits$3(Point$2, Base$2.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point$2(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point$2.fromJSON(this, obj, red);
};

Point$2.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point$2.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point$2.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point$2.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point$2.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point$2.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point$2.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point$2.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point$2.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point$2.prototype.mul = function mul(k) {
  k = new BN$7(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point$2.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point$2.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point$2.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base$2.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$7(0);
  } else {
    this.x = new BN$7(x, 16);
    this.y = new BN$7(y, 16);
    this.z = new BN$7(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits$3(JPoint, Base$2.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN$7(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

var BN$6 = bnExports$1;
var inherits$2 = inherits_browserExports;
var Base$1 = base;

var utils$i = utils$m;

function MontCurve(conf) {
  Base$1.call(this, 'mont', conf);

  this.a = new BN$6(conf.a, 16).toRed(this.red);
  this.b = new BN$6(conf.b, 16).toRed(this.red);
  this.i4 = new BN$6(4).toRed(this.red).redInvm();
  this.two = new BN$6(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$2(MontCurve, Base$1);
var mont = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point$1(curve, x, z) {
  Base$1.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN$6(x, 16);
    this.z = new BN$6(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits$2(Point$1, Base$1.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils$i.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point$1(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point$1.fromJSON(this, obj);
};

Point$1.prototype.precompute = function precompute() {
  // No-op
};

Point$1.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point$1.fromJSON = function fromJSON(curve, obj) {
  return new Point$1(curve, obj[0], obj[1] || curve.one);
};

Point$1.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point$1.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point$1.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point$1.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point$1.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point$1.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point$1.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point$1.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point$1.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point$1.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point$1.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

var utils$h = utils$m;
var BN$5 = bnExports$1;
var inherits$1 = inherits_browserExports;
var Base = base;

var assert$c = utils$h.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN$5(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN$5(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN$5(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits$1(EdwardsCurve, Base);
var edwards = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$5(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN$5(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN$5(x, 16);
    this.y = new BN$5(y, 16);
    this.z = z ? new BN$5(z, 16) : this.curve.one;
    this.t = t && new BN$5(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits$1(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

(function (exports) {

	var curve = exports;

	curve.base = base;
	curve.short = short;
	curve.mont = mont;
	curve.edwards = edwards;
} (curve));

var curves$2 = {};

var hash$2 = {};

var utils$g = {};

var assert$b = minimalisticAssert;
var inherits = inherits_browserExports;

utils$g.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils$g.toArray = toArray;

function toHex$1(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils$g.toHex = toHex$1;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils$g.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils$g.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils$g.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils$g.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert$b(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils$g.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils$g.split32 = split32;

function rotr32$1(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils$g.rotr32 = rotr32$1;

function rotl32$2(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils$g.rotl32 = rotl32$2;

function sum32$3(a, b) {
  return (a + b) >>> 0;
}
utils$g.sum32 = sum32$3;

function sum32_3$1(a, b, c) {
  return (a + b + c) >>> 0;
}
utils$g.sum32_3 = sum32_3$1;

function sum32_4$2(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils$g.sum32_4 = sum32_4$2;

function sum32_5$2(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils$g.sum32_5 = sum32_5$2;

function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$g.sum64 = sum64$1;

function sum64_hi$1(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$g.sum64_hi = sum64_hi$1;

function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$g.sum64_lo = sum64_lo$1;

function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
utils$g.sum64_4_hi = sum64_4_hi$1;

function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$g.sum64_4_lo = sum64_4_lo$1;

function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
utils$g.sum64_5_hi = sum64_5_hi$1;

function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
utils$g.sum64_5_lo = sum64_5_lo$1;

function rotr64_hi$1(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
utils$g.rotr64_hi = rotr64_hi$1;

function rotr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
utils$g.rotr64_lo = rotr64_lo$1;

function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$g.shr64_hi = shr64_hi$1;

function shr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
utils$g.shr64_lo = shr64_lo$1;

var common$5 = {};

var utils$f = utils$g;
var assert$a = minimalisticAssert;

function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;

BlockHash$4.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils$f.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils$f.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$a(this.pending === null);

  return this._digest(enc);
};

BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

var sha = {};

var common$4 = {};

var utils$e = utils$g;
var rotr32 = utils$e.rotr32;

function ft_1$1(s, x, y, z) {
  if (s === 0)
    return ch32$1(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32$1(x, y, z);
}
common$4.ft_1 = ft_1$1;

function ch32$1(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
common$4.ch32 = ch32$1;

function maj32$1(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
common$4.maj32 = maj32$1;

function p32(x, y, z) {
  return x ^ y ^ z;
}
common$4.p32 = p32;

function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;

function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;

function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
common$4.g0_256 = g0_256$1;

function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
common$4.g1_256 = g1_256$1;

var utils$d = utils$g;
var common$3 = common$5;
var shaCommon$1 = common$4;

var rotl32$1 = utils$d.rotl32;
var sum32$2 = utils$d.sum32;
var sum32_5$1 = utils$d.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash$3.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils$d.inherits(SHA1, BlockHash$3);
var _1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32$1(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32$2(this.h[0], a);
  this.h[1] = sum32$2(this.h[1], b);
  this.h[2] = sum32$2(this.h[2], c);
  this.h[3] = sum32$2(this.h[3], d);
  this.h[4] = sum32$2(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$d.toHex32(this.h, 'big');
  else
    return utils$d.split32(this.h, 'big');
};

var utils$c = utils$g;
var common$2 = common$5;
var shaCommon = common$4;
var assert$9 = minimalisticAssert;

var sum32$1 = utils$c.sum32;
var sum32_4$1 = utils$c.sum32_4;
var sum32_5 = utils$c.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash$2 = common$2.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();

  BlockHash$2.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$c.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;

SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;

SHA256$1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert$9(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32$1(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32$1(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32$1(T1, T2);
  }

  this.h[0] = sum32$1(this.h[0], a);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c);
  this.h[3] = sum32$1(this.h[3], d);
  this.h[4] = sum32$1(this.h[4], e);
  this.h[5] = sum32$1(this.h[5], f);
  this.h[6] = sum32$1(this.h[6], g);
  this.h[7] = sum32$1(this.h[7], h);
};

SHA256$1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$c.toHex32(this.h, 'big');
  else
    return utils$c.split32(this.h, 'big');
};

var utils$b = utils$g;
var SHA256 = _256;

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils$b.inherits(SHA224, SHA256);
var _224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils$b.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils$b.split32(this.h.slice(0, 7), 'big');
};

var utils$a = utils$g;
var common$1 = common$5;
var assert$8 = minimalisticAssert;

var rotr64_hi = utils$a.rotr64_hi;
var rotr64_lo = utils$a.rotr64_lo;
var shr64_hi = utils$a.shr64_hi;
var shr64_lo = utils$a.shr64_lo;
var sum64 = utils$a.sum64;
var sum64_hi = utils$a.sum64_hi;
var sum64_lo = utils$a.sum64_lo;
var sum64_4_hi = utils$a.sum64_4_hi;
var sum64_4_lo = utils$a.sum64_4_lo;
var sum64_5_hi = utils$a.sum64_5_hi;
var sum64_5_lo = utils$a.sum64_5_lo;

var BlockHash$1 = common$1.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();

  BlockHash$1.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$a.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;

SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;

SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512$1.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert$8(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512$1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$a.toHex32(this.h, 'big');
  else
    return utils$a.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

var utils$9 = utils$g;

var SHA512 = _512;

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils$9.inherits(SHA384, SHA512);
var _384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$9.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils$9.split32(this.h.slice(0, 12), 'big');
};

sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;

var ripemd = {};

var utils$8 = utils$g;
var common = common$5;

var rotl32 = utils$8.rotl32;
var sum32 = utils$8.sum32;
var sum32_3 = utils$8.sum32_3;
var sum32_4 = utils$8.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils$8.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r$1[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$8.toHex32(this.h, 'little');
  else
    return utils$8.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r$1 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

var utils$7 = utils$g;
var assert$7 = minimalisticAssert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils$7.toArray(key, enc));
}
var hmac = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert$7(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

(function (exports) {
	var hash = exports;

	hash.utils = utils$g;
	hash.common = common$5;
	hash.sha = sha;
	hash.ripemd = ripemd;
	hash.hmac = hmac;

	// Proxy hash functions to the main object
	hash.sha1 = hash.sha.sha1;
	hash.sha256 = hash.sha.sha256;
	hash.sha224 = hash.sha.sha224;
	hash.sha384 = hash.sha.sha384;
	hash.sha512 = hash.sha.sha512;
	hash.ripemd160 = hash.ripemd.ripemd160;
} (hash$2));

var secp256k1;
var hasRequiredSecp256k1;

function requireSecp256k1 () {
	if (hasRequiredSecp256k1) return secp256k1;
	hasRequiredSecp256k1 = 1;
	secp256k1 = {
	  doubles: {
	    step: 4,
	    points: [
	      [
	        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
	        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
	      ],
	      [
	        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
	        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
	      ],
	      [
	        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
	        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
	      ],
	      [
	        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
	        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
	      ],
	      [
	        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
	        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
	      ],
	      [
	        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
	        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
	      ],
	      [
	        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
	        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
	      ],
	      [
	        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
	        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
	      ],
	      [
	        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
	        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
	      ],
	      [
	        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
	        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
	      ],
	      [
	        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
	        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
	      ],
	      [
	        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
	        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
	      ],
	      [
	        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
	        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
	      ],
	      [
	        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
	        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
	      ],
	      [
	        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
	        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
	      ],
	      [
	        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
	        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
	      ],
	      [
	        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
	        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
	      ],
	      [
	        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
	        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
	      ],
	      [
	        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
	        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
	      ],
	      [
	        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
	        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
	      ],
	      [
	        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
	        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
	      ],
	      [
	        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
	        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
	      ],
	      [
	        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
	        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
	      ],
	      [
	        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
	        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
	      ],
	      [
	        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
	        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
	      ],
	      [
	        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
	        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
	      ],
	      [
	        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
	        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
	      ],
	      [
	        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
	        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
	      ],
	      [
	        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
	        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
	      ],
	      [
	        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
	        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
	      ],
	      [
	        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
	        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
	      ],
	      [
	        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
	        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
	      ],
	      [
	        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
	        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
	      ],
	      [
	        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
	        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
	      ],
	      [
	        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
	        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
	      ],
	      [
	        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
	        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
	      ],
	      [
	        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
	        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
	      ],
	      [
	        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
	        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
	      ],
	      [
	        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
	        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
	      ],
	      [
	        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
	        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
	      ],
	      [
	        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
	        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
	      ],
	      [
	        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
	        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
	      ],
	      [
	        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
	        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
	      ],
	      [
	        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
	        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
	      ],
	      [
	        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
	        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
	      ],
	      [
	        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
	        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
	      ],
	      [
	        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
	        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
	      ],
	      [
	        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
	        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
	      ],
	      [
	        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
	        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
	      ],
	      [
	        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
	        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
	      ],
	      [
	        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
	        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
	      ],
	      [
	        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
	        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
	      ],
	      [
	        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
	        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
	      ],
	      [
	        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
	        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
	      ],
	      [
	        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
	        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
	      ],
	      [
	        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
	        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
	      ],
	      [
	        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
	        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
	      ],
	      [
	        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
	        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
	      ],
	      [
	        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
	        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
	      ],
	      [
	        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
	        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
	      ],
	      [
	        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
	        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
	      ],
	      [
	        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
	        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
	      ],
	      [
	        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
	        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
	      ],
	      [
	        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
	        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
	      ],
	      [
	        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
	        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
	      ],
	    ],
	  },
	  naf: {
	    wnd: 7,
	    points: [
	      [
	        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
	        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
	      ],
	      [
	        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
	        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
	      ],
	      [
	        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
	        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
	      ],
	      [
	        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
	        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
	      ],
	      [
	        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
	        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
	      ],
	      [
	        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
	        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
	      ],
	      [
	        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
	        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
	      ],
	      [
	        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
	        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
	      ],
	      [
	        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
	        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
	      ],
	      [
	        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
	        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
	      ],
	      [
	        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
	        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
	      ],
	      [
	        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
	        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
	      ],
	      [
	        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
	        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
	      ],
	      [
	        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
	        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
	      ],
	      [
	        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
	        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
	      ],
	      [
	        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
	        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
	      ],
	      [
	        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
	        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
	      ],
	      [
	        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
	        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
	      ],
	      [
	        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
	        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
	      ],
	      [
	        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
	        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
	      ],
	      [
	        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
	        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
	      ],
	      [
	        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
	        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
	      ],
	      [
	        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
	        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
	      ],
	      [
	        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
	        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
	      ],
	      [
	        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
	        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
	      ],
	      [
	        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
	        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
	      ],
	      [
	        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
	        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
	      ],
	      [
	        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
	        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
	      ],
	      [
	        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
	        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
	      ],
	      [
	        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
	        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
	      ],
	      [
	        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
	        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
	      ],
	      [
	        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
	        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
	      ],
	      [
	        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
	        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
	      ],
	      [
	        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
	        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
	      ],
	      [
	        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
	        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
	      ],
	      [
	        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
	        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
	      ],
	      [
	        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
	        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
	      ],
	      [
	        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
	        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
	      ],
	      [
	        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
	        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
	      ],
	      [
	        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
	        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
	      ],
	      [
	        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
	        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
	      ],
	      [
	        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
	        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
	      ],
	      [
	        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
	        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
	      ],
	      [
	        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
	        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
	      ],
	      [
	        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
	        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
	      ],
	      [
	        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
	        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
	      ],
	      [
	        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
	        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
	      ],
	      [
	        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
	        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
	      ],
	      [
	        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
	        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
	      ],
	      [
	        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
	        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
	      ],
	      [
	        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
	        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
	      ],
	      [
	        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
	        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
	      ],
	      [
	        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
	        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
	      ],
	      [
	        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
	        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
	      ],
	      [
	        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
	        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
	      ],
	      [
	        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
	        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
	      ],
	      [
	        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
	        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
	      ],
	      [
	        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
	        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
	      ],
	      [
	        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
	        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
	      ],
	      [
	        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
	        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
	      ],
	      [
	        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
	        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
	      ],
	      [
	        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
	        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
	      ],
	      [
	        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
	        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
	      ],
	      [
	        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
	        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
	      ],
	      [
	        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
	        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
	      ],
	      [
	        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
	        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
	      ],
	      [
	        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
	        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
	      ],
	      [
	        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
	        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
	      ],
	      [
	        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
	        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
	      ],
	      [
	        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
	        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
	      ],
	      [
	        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
	        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
	      ],
	      [
	        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
	        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
	      ],
	      [
	        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
	        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
	      ],
	      [
	        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
	        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
	      ],
	      [
	        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
	        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
	      ],
	      [
	        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
	        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
	      ],
	      [
	        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
	        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
	      ],
	      [
	        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
	        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
	      ],
	      [
	        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
	        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
	      ],
	      [
	        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
	        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
	      ],
	      [
	        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
	        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
	      ],
	      [
	        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
	        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
	      ],
	      [
	        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
	        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
	      ],
	      [
	        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
	        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
	      ],
	      [
	        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
	        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
	      ],
	      [
	        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
	        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
	      ],
	      [
	        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
	        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
	      ],
	      [
	        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
	        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
	      ],
	      [
	        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
	        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
	      ],
	      [
	        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
	        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
	      ],
	      [
	        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
	        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
	      ],
	      [
	        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
	        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
	      ],
	      [
	        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
	        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
	      ],
	      [
	        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
	        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
	      ],
	      [
	        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
	        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
	      ],
	      [
	        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
	        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
	      ],
	      [
	        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
	        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
	      ],
	      [
	        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
	        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
	      ],
	      [
	        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
	        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
	      ],
	      [
	        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
	        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
	      ],
	      [
	        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
	        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
	      ],
	      [
	        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
	        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
	      ],
	      [
	        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
	        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
	      ],
	      [
	        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
	        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
	      ],
	      [
	        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
	        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
	      ],
	      [
	        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
	        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
	      ],
	      [
	        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
	        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
	      ],
	      [
	        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
	        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
	      ],
	      [
	        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
	        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
	      ],
	      [
	        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
	        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
	      ],
	      [
	        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
	        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
	      ],
	      [
	        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
	        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
	      ],
	      [
	        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
	        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
	      ],
	      [
	        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
	        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
	      ],
	      [
	        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
	        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
	      ],
	      [
	        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
	        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
	      ],
	      [
	        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
	        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
	      ],
	      [
	        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
	        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
	      ],
	      [
	        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
	        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
	      ],
	      [
	        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
	        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
	      ],
	      [
	        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
	        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
	      ],
	      [
	        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
	        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
	      ],
	      [
	        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
	        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
	      ],
	      [
	        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
	        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
	      ],
	      [
	        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
	        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
	      ],
	      [
	        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
	        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
	      ],
	      [
	        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
	        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
	      ],
	    ],
	  },
	};
	return secp256k1;
}

(function (exports) {

	var curves = exports;

	var hash = hash$2;
	var curve$1 = curve;
	var utils = utils$m;

	var assert = utils.assert;

	function PresetCurve(options) {
	  if (options.type === 'short')
	    this.curve = new curve$1.short(options);
	  else if (options.type === 'edwards')
	    this.curve = new curve$1.edwards(options);
	  else
	    this.curve = new curve$1.mont(options);
	  this.g = this.curve.g;
	  this.n = this.curve.n;
	  this.hash = options.hash;

	  assert(this.g.validate(), 'Invalid curve');
	  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
	}
	curves.PresetCurve = PresetCurve;

	function defineCurve(name, options) {
	  Object.defineProperty(curves, name, {
	    configurable: true,
	    enumerable: true,
	    get: function() {
	      var curve = new PresetCurve(options);
	      Object.defineProperty(curves, name, {
	        configurable: true,
	        enumerable: true,
	        value: curve,
	      });
	      return curve;
	    },
	  });
	}

	defineCurve('p192', {
	  type: 'short',
	  prime: 'p192',
	  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
	  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
	  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
	    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
	  ],
	});

	defineCurve('p224', {
	  type: 'short',
	  prime: 'p224',
	  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
	  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
	  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
	    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
	  ],
	});

	defineCurve('p256', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
	  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
	  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
	  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
	    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
	  ],
	});

	defineCurve('p384', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 ffffffff',
	  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 fffffffc',
	  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
	     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
	  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
	     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
	  hash: hash.sha384,
	  gRed: false,
	  g: [
	    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
	    '5502f25d bf55296c 3a545e38 72760ab7',
	    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
	    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
	  ],
	});

	defineCurve('p521', {
	  type: 'short',
	  prime: null,
	  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff',
	  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff fffffffc',
	  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
	     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
	     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
	  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
	     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
	  hash: hash.sha512,
	  gRed: false,
	  g: [
	    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
	    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
	    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
	    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
	    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
	    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
	  ],
	});

	defineCurve('curve25519', {
	  type: 'mont',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '76d06',
	  b: '1',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '9',
	  ],
	});

	defineCurve('ed25519', {
	  type: 'edwards',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '-1',
	  c: '1',
	  // -121665 * (121666^(-1)) (mod P)
	  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

	    // 4/5
	    '6666666666666666666666666666666666666666666666666666666666666658',
	  ],
	});

	var pre;
	try {
	  pre = requireSecp256k1();
	} catch (e) {
	  pre = undefined;
	}

	defineCurve('secp256k1', {
	  type: 'short',
	  prime: 'k256',
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
	  a: '0',
	  b: '7',
	  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
	  h: '1',
	  hash: hash.sha256,

	  // Precomputed endomorphism
	  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
	  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
	  basis: [
	    {
	      a: '3086d221a7d46bcde86c90e49284eb15',
	      b: '-e4437ed6010e88286f547fa90abfe4c3',
	    },
	    {
	      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
	      b: '3086d221a7d46bcde86c90e49284eb15',
	    },
	  ],

	  gRed: false,
	  g: [
	    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
	    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	    pre,
	  ],
	});
} (curves$2));

var hash$1 = hash$2;
var utils$6 = utils$l;
var assert$6 = minimalisticAssert;

function HmacDRBG$1(options) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils$6.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils$6.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils$6.toArray(options.pers, options.persEnc || 'hex');
  assert$6(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG$1;

HmacDRBG$1.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG$1.prototype._hmac = function hmac() {
  return new hash$1.hmac(this.hash, this.K);
};

HmacDRBG$1.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils$6.toArray(entropy, entropyEnc);
  add = utils$6.toArray(add, addEnc);

  assert$6(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG$1.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils$6.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils$6.encode(res, enc);
};

var BN$4 = bnExports$1;
var utils$5 = utils$m;
var assert$5 = utils$5.assert;

function KeyPair$3(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$1 = KeyPair$3;

KeyPair$3.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair$3)
    return pub;

  return new KeyPair$3(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair$3.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair$3)
    return priv;

  return new KeyPair$3(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair$3.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair$3.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN$4(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair$3.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert$5(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert$5(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair$3.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert$5(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair$3.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair$3.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair$3.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

var BN$3 = bnExports$1;

var utils$4 = utils$m;
var assert$4 = utils$4.assert;

function Signature$3(options, enc) {
  if (options instanceof Signature$3)
    return options;

  if (this._importDER(options, enc))
    return;

  assert$4(options.r && options.s, 'Signature without r or s');
  this.r = new BN$3(options.r, 16);
  this.s = new BN$3(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$1 = Signature$3;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature$3.prototype._importDER = function _importDER(data, enc) {
  data = utils$4.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN$3(r);
  this.s = new BN$3(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature$3.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils$4.encode(res, enc);
};

var BN$2 = bnExports$1;
var HmacDRBG = hmacDrbg;
var utils$3 = utils$m;
var curves$1 = curves$2;
var rand = brorandExports;
var assert$3 = utils$3.assert;

var KeyPair$2 = key$1;
var Signature$2 = signature$1;

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert$3(Object.prototype.hasOwnProperty.call(curves$1, options),
      'Unknown curve ' + options);

    options = curves$1[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves$1.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair$2(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair$2.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair$2.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN$2(2));
  for (;;) {
    var priv = new BN$2(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN$2(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN$2(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN$2(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature$2({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN$2(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature$2(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert$3((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature$2(signature, enc);

  var n = this.n;
  var e = new BN$2(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature$2(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

var utils$2 = utils$m;
var assert$2 = utils$2.assert;
var parseBytes$2 = utils$2.parseBytes;
var cachedProperty$1 = utils$2.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair$1(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes$2(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes$2(params.pub);
}

KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair$1)
    return pub;
  return new KeyPair$1(eddsa, { pub: pub });
};

KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair$1)
    return secret;
  return new KeyPair$1(eddsa, { secret: secret });
};

KeyPair$1.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty$1(KeyPair$1, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty$1(KeyPair$1, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty$1(KeyPair$1, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty$1(KeyPair$1, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty$1(KeyPair$1, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty$1(KeyPair$1, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair$1.prototype.sign = function sign(message) {
  assert$2(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair$1.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair$1.prototype.getSecret = function getSecret(enc) {
  assert$2(this._secret, 'KeyPair is public only');
  return utils$2.encode(this.secret(), enc);
};

KeyPair$1.prototype.getPublic = function getPublic(enc) {
  return utils$2.encode(this.pubBytes(), enc);
};

var key = KeyPair$1;

var BN$1 = bnExports$1;
var utils$1 = utils$m;
var assert$1 = utils$1.assert;
var cachedProperty = utils$1.cachedProperty;
var parseBytes$1 = utils$1.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature$1(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes$1(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert$1(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN$1)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature$1, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature$1, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature$1, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature$1, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature$1.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature$1.prototype.toHex = function toHex() {
  return utils$1.encode(this.toBytes(), 'hex').toUpperCase();
};

var signature = Signature$1;

var hash = hash$2;
var curves = curves$2;
var utils = utils$m;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = key;
var Signature = signature;

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

var eddsa = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

(function (exports) {

	var elliptic = exports;

	elliptic.version = require$$0$1.version;
	elliptic.utils = utils$m;
	elliptic.rand = brorandExports;
	elliptic.curve = curve;
	elliptic.curves = curves$2;

	// Protocols
	elliptic.ec = ec;
	elliptic.eddsa = eddsa;
} (elliptic));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.recover = exports.hashMessage = void 0;
	var js_sha3_1 = sha3Exports;
	var index_1 = utils$n;
	var elliptic_1 = elliptic;
	var secp256k1 = new elliptic_1.ec('secp256k1');
	var bytesLength = function (a) { return (a.length - 2) / 2; };
	var bytesSlice = function (i, j, bs) {
	    return '0x' + bs.slice(i * 2 + 2, j * 2 + 2);
	};
	var bytesToNumber = function (hex) { return parseInt(hex.slice(2), 16); };
	var decodeSignature = function (hex) { return [
	    bytesSlice(64, bytesLength(hex), hex),
	    bytesSlice(0, 32, hex),
	    bytesSlice(32, 64, hex),
	]; };
	var toChecksum = function (address) {
	    var addressHash = (0, js_sha3_1.keccak256)(address.slice(2));
	    var checksumAddress = '0x';
	    for (var i = 0; i < 40; i++) {
	        checksumAddress +=
	            parseInt(addressHash[i + 2], 16) > 7
	                ? address[i + 2].toUpperCase()
	                : address[i + 2];
	    }
	    return checksumAddress;
	};
	var hashMessage = function (message) {
	    var messageBytes = (0, index_1.hexToBytes)(Buffer.from(message, 'utf8').toString('hex'));
	    var messageBuffer = Buffer.from(messageBytes);
	    var preamble = '\x19Ethereum Signed Message:\n' + messageBytes.length;
	    var preambleBuffer = Buffer.from(preamble);
	    var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);
	    return '0x' + (0, js_sha3_1.keccak256)(ethMessage.toString());
	};
	exports.hashMessage = hashMessage;
	var recover = function (message, signature) {
	    var hash = (0, exports.hashMessage)(message);
	    var vals = decodeSignature(signature);
	    var vrs = {
	        v: bytesToNumber(vals[0]),
	        r: vals[1].slice(2),
	        s: vals[2].slice(2),
	    };
	    var ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - (vrs.v % 2));
	    var publicKey = '0x' + ecPublicKey.encode('hex', false).slice(2);
	    var publicHash = '0x' + (0, js_sha3_1.keccak256)((0, index_1.hexToBytes)(publicKey));
	    return toChecksum('0x' + publicHash.slice(-40));
	};
	exports.recover = recover;
} (recoverSignature));

Object.defineProperty(TwitterSignatureValidator, "__esModule", { value: true });
TwitterSignatureValidator.isValidTwitterSignature = void 0;
var index_1 = utils$n;
var js_sha3_1 = sha3Exports;
var recoverSignature_1 = recoverSignature;
var namehash_1$4 = namehash;
var TwitterVerificationAddress = '0x12cfb13522F13a78b650a8bCbFCf50b7CB899d82';
var isValidTwitterSignature = function (_a) {
    var tokenId = _a.tokenId, owner = _a.owner, twitterHandle = _a.twitterHandle, validationSignature = _a.validationSignature;
    var tokenIdInDecimals = (0, namehash_1$4.fromHexStringToDecimals)(tokenId);
    var message = [
        tokenIdInDecimals,
        owner,
        'social.twitter.username',
        twitterHandle,
    ]
        .map(function (value) {
        return '0x' + (0, js_sha3_1.keccak256)(value.startsWith('0x') ? (0, index_1.hexToBytes)(value) : value);
    })
        .reduce(function (message, hashedValue) { return message + hashedValue; }, '');
    var signerAddress = (0, recoverSignature_1.recover)(message, validationSignature);
    return signerAddress === TwitterVerificationAddress;
};
TwitterSignatureValidator.isValidTwitterSignature = isValidTwitterSignature;

var UnsInternal$1 = {};

var EthereumContract$1 = {};

var bnExports = {};
var bn = {
  get exports(){ return bnExports; },
  set exports(v){ bnExports = v; },
};

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
	      Buffer = window.Buffer;
	    } else {
	      Buffer = require$$0$2.Buffer;
	    }
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	      this.negative = 1;
	    }

	    if (start < number.length) {
	      if (base === 16) {
	        this._parseHex(number, start, endian);
	      } else {
	        this._parseBase(number, base, start);
	        if (endian === 'le') {
	          this._initArray(this.toArray(), base, endian);
	        }
	      }
	    }
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [number & 0x3ffffff];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [0];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this._strip();
	  };

	  function parseHex4Bits (string, index) {
	    var c = string.charCodeAt(index);
	    // '0' - '9'
	    if (c >= 48 && c <= 57) {
	      return c - 48;
	    // 'A' - 'F'
	    } else if (c >= 65 && c <= 70) {
	      return c - 55;
	    // 'a' - 'f'
	    } else if (c >= 97 && c <= 102) {
	      return c - 87;
	    } else {
	      assert(false, 'Invalid character in ' + string);
	    }
	  }

	  function parseHexByte (string, lowerBound, index) {
	    var r = parseHex4Bits(string, index);
	    if (index - 1 >= lowerBound) {
	      r |= parseHex4Bits(string, index - 1) << 4;
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start, endian) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    // 24-bits chunks
	    var off = 0;
	    var j = 0;

	    var w;
	    if (endian === 'be') {
	      for (i = number.length - 1; i >= start; i -= 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    } else {
	      var parseLength = number.length - start;
	      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    }

	    this._strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var b = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        b = c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        b = c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        b = c;
	      }
	      assert(c >= 0 && b < mul, 'Invalid character');
	      r += b;
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [0];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    this._strip();
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  function move (dest, src) {
	    dest.words = src.words;
	    dest.length = src.length;
	    dest.negative = src.negative;
	    dest.red = src.red;
	  }

	  BN.prototype._move = function _move (dest) {
	    move(dest, this);
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype._strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  // Check Symbol.for because not everywhere where Symbol defined
	  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
	  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
	    try {
	      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
	    } catch (e) {
	      BN.prototype.inspect = inspect;
	    }
	  } else {
	    BN.prototype.inspect = inspect;
	  }

	  function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  }

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modrn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16, 2);
	  };

	  if (Buffer) {
	    BN.prototype.toBuffer = function toBuffer (endian, length) {
	      return this.toArrayLike(Buffer, endian, length);
	    };
	  }

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  var allocate = function allocate (ArrayType, size) {
	    if (ArrayType.allocUnsafe) {
	      return ArrayType.allocUnsafe(size);
	    }
	    return new ArrayType(size);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    this._strip();

	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    var res = allocate(ArrayType, reqLength);
	    var postfix = endian === 'le' ? 'LE' : 'BE';
	    this['_toArrayLike' + postfix](res, byteLength);
	    return res;
	  };

	  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
	    var position = 0;
	    var carry = 0;

	    for (var i = 0, shift = 0; i < this.length; i++) {
	      var word = (this.words[i] << shift) | carry;

	      res[position++] = word & 0xff;
	      if (position < res.length) {
	        res[position++] = (word >> 8) & 0xff;
	      }
	      if (position < res.length) {
	        res[position++] = (word >> 16) & 0xff;
	      }

	      if (shift === 6) {
	        if (position < res.length) {
	          res[position++] = (word >> 24) & 0xff;
	        }
	        carry = 0;
	        shift = 0;
	      } else {
	        carry = word >>> 24;
	        shift += 2;
	      }
	    }

	    if (position < res.length) {
	      res[position++] = carry;

	      while (position < res.length) {
	        res[position++] = 0;
	      }
	    }
	  };

	  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
	    var position = res.length - 1;
	    var carry = 0;

	    for (var i = 0, shift = 0; i < this.length; i++) {
	      var word = (this.words[i] << shift) | carry;

	      res[position--] = word & 0xff;
	      if (position >= 0) {
	        res[position--] = (word >> 8) & 0xff;
	      }
	      if (position >= 0) {
	        res[position--] = (word >> 16) & 0xff;
	      }

	      if (shift === 6) {
	        if (position >= 0) {
	          res[position--] = (word >> 24) & 0xff;
	        }
	        carry = 0;
	        shift = 0;
	      } else {
	        carry = word >>> 24;
	        shift += 2;
	      }
	    }

	    if (position >= 0) {
	      res[position--] = carry;

	      while (position >= 0) {
	        res[position--] = 0;
	      }
	    }
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] >>> wbit) & 0x01;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this._strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this._strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this._strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this._strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this._strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this._strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out._strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out._strip();
	  }

	  function jumboMulTo (self, num, out) {
	    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
	    // var fftm = new FFTM();
	    // return fftm.mulp(self, num, out);
	    return bigMulTo(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return isNegNum ? this.ineg() : this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this._strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this._strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this._strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) <= num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this._strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this._strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this._strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q._strip();
	    }
	    a._strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modrn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modrn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modrn = function modrn (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return isNegNum ? -acc : acc;
	  };

	  // WARNING: DEPRECATED
	  BN.prototype.modn = function modn (num) {
	    return this.modrn(num);
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    this._strip();
	    return isNegNum ? this.ineg() : this;
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this._strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      if (r.strip !== undefined) {
	        // r is a BN v4 instance
	        r.strip();
	      } else {
	        // r is a BN v5 instance
	        r._strip();
	      }
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

	    move(a, a.umod(this.m)._forceRed(this));
	    return a;
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1).toRed(this);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal);
} (bn));

var _BN = bnExports;

const version$a = "logger/5.7.0";

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ///////////////////
    // Interaction Errors
    // The user rejected the action, such as signing a message or sending
    // a transaction
    ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                const fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version$a);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

const version$9 = "bytes/5.7.0";

const logger$a = new Logger(version$9);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$a.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0" + hex;
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger$a.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        const result = [];
        for (let i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger$a.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map(item => arrayify(item));
    const length = objects.reduce((accum, item) => (accum + item.length), 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$a.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger$a.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger$a.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger$a.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger$a.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger$a.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}

const version$8 = "bignumber/5.7.0";

var BN = _BN.BN;
const logger$9 = new Logger(version$8);
const _constructorGuard$2 = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return (value != null) && (BigNumber.isBigNumber(value) ||
        (typeof (value) === "number" && (value % 1) === 0) ||
        (typeof (value) === "string" && !!value.match(/^-?[0-9]+$/)) ||
        isHexString(value) ||
        (typeof (value) === "bigint") ||
        isBytes(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard$2) {
            logger$9.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault$1("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault$1("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault$1("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault$1("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault$1("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault$1("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault$1("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault$1("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault$1("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault$1("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger$9.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger$9.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger$9.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger$9.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard$2, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard$2, toHex(new BN(value)));
            }
            return logger$9.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault$1("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault$1("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
            return BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if (isHexString(hex) || (hex[0] === "-" && isHexString(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger$9.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger$9.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger$9.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}

const logger$8 = new Logger(version$8);
const _constructorGuard$1 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$1 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value !== undefined) {
        params.value = value;
    }
    return logger$8.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
let zeros = "0";
while (zeros.length < 256) {
    zeros += zeros;
}
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
    if (typeof (decimals) !== "number") {
        try {
            decimals = BigNumber.from(decimals).toNumber();
        }
        catch (e) { }
    }
    if (typeof (decimals) === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
        return ("1" + zeros.substring(0, decimals));
    }
    return logger$8.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    // Make sure wei is a big number (convert as necessary)
    value = BigNumber.from(value);
    const negative = value.lt(Zero$2);
    if (negative) {
        value = value.mul(NegativeOne$1);
    }
    let fraction = value.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
        fraction = "0" + fraction;
    }
    // Strip training 0
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value.div(multiplier).toString();
    if (multiplier.length === 1) {
        value = whole;
    }
    else {
        value = whole + "." + fraction;
    }
    if (negative) {
        value = "-" + value;
    }
    return value;
}
function parseFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    if (typeof (value) !== "string" || !value.match(/^-?[0-9.]+$/)) {
        logger$8.throwArgumentError("invalid decimal value", "value", value);
    }
    // Is it negative?
    const negative = (value.substring(0, 1) === "-");
    if (negative) {
        value = value.substring(1);
    }
    if (value === ".") {
        logger$8.throwArgumentError("missing value", "value", value);
    }
    // Split it into a whole and fractional part
    const comps = value.split(".");
    if (comps.length > 2) {
        logger$8.throwArgumentError("too many decimal points", "value", value);
    }
    let whole = comps[0], fraction = comps[1];
    if (!whole) {
        whole = "0";
    }
    if (!fraction) {
        fraction = "0";
    }
    // Trim trailing zeros
    while (fraction[fraction.length - 1] === "0") {
        fraction = fraction.substring(0, fraction.length - 1);
    }
    // Check the fraction doesn't exceed our decimals size
    if (fraction.length > multiplier.length - 1) {
        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    }
    // If decimals is 0, we have an empty string for fraction
    if (fraction === "") {
        fraction = "0";
    }
    // Fully pad the string with zeros to get to wei
    while (fraction.length < multiplier.length - 1) {
        fraction += "0";
    }
    const wholeValue = BigNumber.from(whole);
    const fractionValue = BigNumber.from(fraction);
    let wei = (wholeValue.mul(multiplier)).add(fractionValue);
    if (negative) {
        wei = wei.mul(NegativeOne$1);
    }
    return wei;
}
class FixedFormat {
    constructor(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard$1) {
            logger$8.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
    }
    static from(value) {
        if (value instanceof FixedFormat) {
            return value;
        }
        if (typeof (value) === "number") {
            value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof (value) === "string") {
            if (value === "fixed") ;
            else if (value === "ufixed") {
                signed = false;
            }
            else {
                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                if (!match) {
                    logger$8.throwArgumentError("invalid fixed format", "format", value);
                }
                signed = (match[1] !== "u");
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
            }
        }
        else if (value) {
            const check = (key, type, defaultValue) => {
                if (value[key] == null) {
                    return defaultValue;
                }
                if (typeof (value[key]) !== type) {
                    logger$8.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
                }
                return value[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
            logger$8.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
            logger$8.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat(_constructorGuard$1, signed, width, decimals);
    }
}
class FixedNumber {
    constructor(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard$1) {
            logger$8.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
    }
    _checkFormat(other) {
        if (this.format.name !== other.format.name) {
            logger$8.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
    }
    addUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
    }
    subUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
    }
    floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
            result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
    }
    ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
            result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
    }
    // @TODO: Support other rounding algorithms
    round(decimals) {
        if (decimals == null) {
            decimals = 0;
        }
        // If we are already in range, we're done
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || (decimals % 1)) {
            logger$8.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
            return this;
        }
        const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
        return (this._value === "0.0" || this._value === "0");
    }
    isNegative() {
        return (this._value[0] === "-");
    }
    toString() { return this._value; }
    toHexString(width) {
        if (width == null) {
            return this._hex;
        }
        if (width % 8) {
            logger$8.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return hexZeroPad(hex, width / 8);
    }
    toUnsafeFloat() { return parseFloat(this.toString()); }
    toFormat(format) {
        return FixedNumber.fromString(this._value, format);
    }
    static fromValue(value, decimals, format) {
        // If decimals looks more like a format, and there is no format, shift the parameters
        if (format == null && decimals != null && !isBigNumberish(decimals)) {
            format = decimals;
            decimals = null;
        }
        if (decimals == null) {
            decimals = 0;
        }
        if (format == null) {
            format = "fixed";
        }
        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    }
    static fromString(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero$2)) {
            throwFault("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
            hex = numeric.toTwos(fixedFormat.width).toHexString();
        }
        else {
            hex = numeric.toHexString();
            hex = hexZeroPad(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard$1, hex, decimal, fixedFormat);
    }
    static fromBytes(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (arrayify(value).length > fixedFormat.width / 8) {
            throw new Error("overflow");
        }
        let numeric = BigNumber.from(value);
        if (fixedFormat.signed) {
            numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard$1, hex, decimal, fixedFormat);
    }
    static from(value, format) {
        if (typeof (value) === "string") {
            return FixedNumber.fromString(value, format);
        }
        if (isBytes(value)) {
            return FixedNumber.fromBytes(value, format);
        }
        try {
            return FixedNumber.fromValue(value, 0, format);
        }
        catch (error) {
            // Allow NUMERIC_FAULT to bubble up
            if (error.code !== Logger.errors.INVALID_ARGUMENT) {
                throw error;
            }
        }
        return logger$8.throwArgumentError("invalid FixedNumber value", "value", value);
    }
    static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
    }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");

const version$7 = "properties/5.7.0";

(undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$7 = new Logger(version$7);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            let value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger$7.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof (object) === "object") {
        const result = {};
        for (const key in object) {
            const value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger$7.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info) {
        for (const key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
}

const version$6 = "abi/5.7.0";

const logger$6 = new Logger(version$6);
const _constructorGuard = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        logger$6.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger$6.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i = 0; i < param.length; i++) {
        let c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        logger$6.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (let key in params) {
        defineReadOnly(object, key, params[key]);
    }
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$6.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            let result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.components) {
                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof (value) === "string") {
            return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(_constructorGuard, {
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$6.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === "string") {
            return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger$6.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(" ")[0] === "function") {
            return FunctionFragment.fromString(value.substring(8).trim());
        }
        else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(" ")[0] === "error") {
            return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger$6.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            logger$6.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
            logger$6.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger$6.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return (value && value._isFragment && value.type === "event");
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) {
            logger$6.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
            logger$6.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = BigNumber.from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                logger$6.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                logger$6.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger$6.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            logger$6.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        logger$6.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        if (format === FormatTypes.sighash) {
            logger$6.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            logger$6.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
            logger$6.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            logger$6.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return (value && value._isFragment && value.type === "constructor");
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
            }
            if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            logger$6.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
            logger$6.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
            logger$6.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                logger$6.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return (value && value._isFragment && value.type === "function");
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger$6.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            logger$6.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
            logger$6.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return (value && value._isFragment && value.type === "error");
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        logger$6.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    logger$6.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}

const logger$5 = new Logger(version$6);
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic) {
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger$5.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return hexConcat(this._data);
    }
    get length() { return this._dataLength; }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData(concat(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = arrayify(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = arrayify(BigNumber.from(value));
        if (bytes.length > this.wordSize) {
            logger$5.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes.length
            });
        }
        if (bytes.length % this.wordSize) {
            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() { return hexlify(this._data); }
    get consumed() { return this._offset; }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
        }
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) {
            return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                logger$5.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + alignedLength
                });
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
    }
}

function keccak256(data) {
    return '0x' + sha3.keccak_256(arrayify(data));
}

const version$5 = "rlp/5.7.0";

new Logger(version$5);

const version$4 = "address/5.7.0";

const logger$4 = new Logger(version$4);
function getChecksumAddress(address) {
    if (!isHexString(address, 20)) {
        logger$4.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = arrayify(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
function getAddress(address) {
    let result = null;
    if (typeof (address) !== "string") {
        logger$4.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger$4.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger$4.throwArgumentError("bad icap checksum", "address", address);
        }
        result = _base36To16(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger$4.throwArgumentError("invalid address", "address", address);
    }
    return result;
}

class AddressCoder extends Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = getAddress(value);
        }
        catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
    }
}

// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends Coder {
    constructor(coder) {
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

const logger$3 = new Logger(version$6);
function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            if (!name) {
                logger$3.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            if (unique[name]) {
                logger$3.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            unique[name] = true;
            return values[name];
        });
    }
    else {
        logger$3.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
        logger$3.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new Writer(writer.wordSize);
    let dynamicWriter = new Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value != undefined) {
            values.push(value);
        }
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
            return;
        }
        if (name === "length") {
            name = "_length";
        }
        if (values[name] != null) {
            return;
        }
        const value = values[index];
        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
        else {
            values[name] = value;
        }
    });
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
    }
    return Object.freeze(values);
}
class ArrayCoder extends Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger$3.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) {
                logger$3.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
                    length: reader._data.length,
                    count: count
                });
            }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
    }
}

class BooleanCoder extends Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}

class DynamicBytesCoder extends Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
    }
}

// @TODO: Merge this with bytes
class FixedBytesCoder extends Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = arrayify(value);
        if (data.length !== this.size) {
            this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
    }
}

class NullCoder extends Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}

const NegativeOne = ( /*#__PURE__*/BigNumber.from(-1));
const Zero$1 = ( /*#__PURE__*/BigNumber.from(0));
const One$1 = ( /*#__PURE__*/BigNumber.from(1));
const MaxUint256 = ( /*#__PURE__*/BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

class NumberCoder extends Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = BigNumber.from(value);
        // Check bounds are safe for encoding
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(One$1).mul(NegativeOne))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(Zero$1) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}

const version$3 = "strings/5.7.0";

const logger$2 = new Logger(version$3);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger$2.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = arrayify(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger$2.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return arrayify(result);
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}

function bytes2(data) {
    if ((data.length % 4) !== 0) {
        throw new Error("bad data");
    }
    let result = [];
    for (let i = 0; i < data.length; i += 4) {
        result.push(parseInt(data.substring(i, i + 4), 16));
    }
    return result;
}
function createTable(data, func) {
    if (!func) {
        func = function (value) { return [parseInt(value, 16)]; };
    }
    let lo = 0;
    let result = {};
    data.split(",").forEach((pair) => {
        let comps = pair.split(":");
        lo += parseInt(comps[0], 16);
        result[lo] = func(comps[1]);
    });
    return result;
}
function createRangeTable(data) {
    let hi = 0;
    return data.split(",").map((v) => {
        let comps = v.split("-");
        if (comps.length === 1) {
            comps[1] = "0";
        }
        else if (comps[1] === "") {
            comps[1] = "1";
        }
        let lo = hi + parseInt(comps[0], 16);
        hi = parseInt(comps[1], 16);
        return { l: lo, h: hi };
    });
}
createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
// @TODO: Make this relative...
"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

class StringCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
    }
    decode(reader) {
        return toUtf8String(super.decode(reader));
    }
}

class TupleCoder extends Coder {
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return pack(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
    }
}

const logger$1 = new Logger(version$6);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new AddressCoder(param.name);
            case "bool":
                return new BooleanCoder(param.name);
            case "string":
                return new StringCoder(param.name);
            case "bytes":
                return new BytesCoder(param.name);
            case "array":
                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new TupleCoder((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                logger$1.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                logger$1.throwArgumentError("invalid bytes length", "param", param);
            }
            return new FixedBytesCoder(size, param.name);
        }
        return logger$1.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new Writer(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            logger$1.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = (new TupleCoder(coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();

function id(text) {
    return keccak256(toUtf8Bytes(text));
}

const version$2 = "hash/5.7.0";

function decode(textData) {
    textData = atob(textData);
    const data = [];
    for (let i = 0; i < textData.length; i++) {
        data.push(textData.charCodeAt(i));
    }
    return arrayify(data);
}

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js
function flat(array, depth) {
    if (depth == null) {
        depth = 1;
    }
    const result = [];
    const forEach = result.forEach;
    const flatDeep = function (arr, depth) {
        forEach.call(arr, function (val) {
            if (depth > 0 && Array.isArray(val)) {
                flatDeep(val, depth - 1);
            }
            else {
                result.push(val);
            }
        });
    };
    flatDeep(array, depth);
    return result;
}
function fromEntries(array) {
    const result = {};
    for (let i = 0; i < array.length; i++) {
        const value = array[i];
        result[value[0]] = value[1];
    }
    return result;
}
function decode_arithmetic(bytes) {
    let pos = 0;
    function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }
    // decode the frequency table
    let symbol_count = u16();
    let total = 1;
    let acc = [0, 1]; // first symbol has frequency 1
    for (let i = 1; i < symbol_count; i++) {
        acc.push(total += u16());
    }
    // skip the sized-payload that the last 3 symbols index into
    let skip = u16();
    let pos_payload = pos;
    pos += skip;
    let read_width = 0;
    let read_buffer = 0;
    function read_bit() {
        if (read_width == 0) {
            // this will read beyond end of buffer
            // but (undefined|0) => zero pad
            read_buffer = (read_buffer << 8) | bytes[pos++];
            read_width = 8;
        }
        return (read_buffer >> --read_width) & 1;
    }
    const N = 31;
    const FULL = Math.pow(2, N);
    const HALF = FULL >>> 1;
    const QRTR = HALF >> 1;
    const MASK = FULL - 1;
    // fill register
    let register = 0;
    for (let i = 0; i < N; i++)
        register = (register << 1) | read_bit();
    let symbols = [];
    let low = 0;
    let range = FULL; // treat like a float
    while (true) {
        let value = Math.floor((((register - low + 1) * total) - 1) / range);
        let start = 0;
        let end = symbol_count;
        while (end - start > 1) { // binary search
            let mid = (start + end) >>> 1;
            if (value < acc[mid]) {
                end = mid;
            }
            else {
                start = mid;
            }
        }
        if (start == 0)
            break; // first symbol is end mark
        symbols.push(start);
        let a = low + Math.floor(range * acc[start] / total);
        let b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while (((a ^ b) & HALF) == 0) {
            register = (register << 1) & MASK | read_bit();
            a = (a << 1) & MASK;
            b = (b << 1) & MASK | 1;
        }
        while (a & ~b & QRTR) {
            register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();
            a = (a << 1) ^ HALF;
            b = ((b ^ HALF) << 1) | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
    }
    let offset = symbol_count - 4;
    return symbols.map(x => {
        switch (x - offset) {
            case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);
            case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);
            case 1: return offset + bytes[pos_payload++];
            default: return x - 1;
        }
    });
}
// returns an iterator which returns the next symbol
function read_payload(v) {
    let pos = 0;
    return () => v[pos++];
}
function read_compressed_payload(bytes) {
    return read_payload(decode_arithmetic(bytes));
}
// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) {
    return (i & 1) ? (~i >> 1) : (i >> 1);
}
function read_counts(n, next) {
    let v = Array(n);
    for (let i = 0; i < n; i++)
        v[i] = 1 + next();
    return v;
}
function read_ascending(n, next) {
    let v = Array(n);
    for (let i = 0, x = -1; i < n; i++)
        v[i] = x += 1 + next();
    return v;
}
function read_deltas(n, next) {
    let v = Array(n);
    for (let i = 0, x = 0; i < n; i++)
        v[i] = x += signed(next());
    return v;
}
function read_member_array(next, lookup) {
    let v = read_ascending(next(), next);
    let n = next();
    let vX = read_ascending(n, next);
    let vN = read_counts(n, next);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < vN[i]; j++) {
            v.push(vX[i] + j);
        }
    }
    return lookup ? v.map(x => lookup[x]) : v;
}
// returns array of 
// [x, ys] => single replacement rule
// [x, ys, n, dx, dx] => linear map
function read_mapped_map(next) {
    let ret = [];
    while (true) {
        let w = next();
        if (w == 0)
            break;
        ret.push(read_linear_table(w, next));
    }
    while (true) {
        let w = next() - 1;
        if (w < 0)
            break;
        ret.push(read_replacement_table(w, next));
    }
    return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
    let v = [];
    while (true) {
        let i = next();
        if (i == 0)
            break;
        v.push(i);
    }
    return v;
}
function read_transposed(n, w, next) {
    let m = Array(n).fill(undefined).map(() => []);
    for (let i = 0; i < w; i++) {
        read_deltas(n, next).forEach((x, j) => m[j].push(x));
    }
    return m;
}
function read_linear_table(w, next) {
    let dx = 1 + next();
    let dy = next();
    let vN = read_zero_terminated_array(next);
    let m = read_transposed(vN.length, 1 + w, next);
    return flat(m.map((v, i) => {
        const x = v[0], ys = v.slice(1);
        //let [x, ...ys] = v;
        //return Array(vN[i]).fill().map((_, j) => {
        return Array(vN[i]).fill(undefined).map((_, j) => {
            let j_dy = j * dy;
            return [x + j * dx, ys.map(y => y + j_dy)];
        });
    }));
}
function read_replacement_table(w, next) {
    let n = 1 + next();
    let m = read_transposed(n, 1 + w, next);
    return m.map(v => [v[0], v.slice(1)]);
}
function read_emoji_trie(next) {
    let sorted = read_member_array(next).sort((a, b) => a - b);
    return read();
    function read() {
        let branches = [];
        while (true) {
            let keys = read_member_array(next, sorted);
            if (keys.length == 0)
                break;
            branches.push({ set: new Set(keys), node: read() });
        }
        branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood
        let temp = next();
        let valid = temp % 3;
        temp = (temp / 3) | 0;
        let fe0f = !!(temp & 1);
        temp >>= 1;
        let save = temp == 1;
        let check = temp == 2;
        return { branches, valid, fe0f, save, check };
    }
}

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
function getData() {
    return read_compressed_payload(decode('AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=='));
}

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
const r = getData();
// @TODO: This should be lazily loaded
new Set(read_member_array(r));
new Set(read_member_array(r));
read_mapped_map(r);
read_emoji_trie(r);

new Logger(version$2);
const Zeros = new Uint8Array(32);
Zeros.fill(0);

(undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
new Logger(version$2);
const padding = new Uint8Array(32);
padding.fill(0);
BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
hexZeroPad(One.toHexString(), 32);
hexZeroPad(Zero.toHexString(), 32);

const logger = new Logger(version$6);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
            return Fragment.from(fragment);
        }).filter((fragment) => (fragment != null)));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment) => {
            let bucket = null;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        logger.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    defineReadOnly(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            defineReadOnly(this, "deploy", ConstructorFragment.from({
                payable: false,
                type: "constructor"
            }));
        }
        defineReadOnly(this, "_isInterface", true);
    }
    format(format) {
        if (!format) {
            format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
            logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === FormatTypes.json) {
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return defaultAbiCoder;
    }
    static getAddress(address) {
        return getAddress(address);
    }
    static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return id(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            for (const name in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name)) {
                    return this.functions[name];
                }
            }
            logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching function", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching functions", "name", name);
            }
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for (const name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            logger.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching event", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching events", "name", name);
            }
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            const getSighash = getStatic(this.constructor, "getSighash");
            for (const name in this.errors) {
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                    return this.errors[name];
                }
            }
            logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching error", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching errors", "name", name);
            }
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof (fragment) === "string") {
            try {
                fragment = this.getFunction(fragment);
            }
            catch (error) {
                try {
                    fragment = this.getError(fragment);
                }
                catch (_) {
                    throw error;
                }
            }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        return hexlify(concat([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                }
                catch (error) { }
                break;
            case 4: {
                const selector = hexlify(bytes.slice(0, 4));
                const builtin = BuiltinErrors[selector];
                if (builtin) {
                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                    errorName = builtin.name;
                    errorSignature = builtin.signature;
                    if (builtin.reason) {
                        reason = errorArgs[0];
                    }
                    if (errorName === "Error") {
                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
                    }
                    else if (errorName === "Panic") {
                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
                    }
                }
                else {
                    try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    }
                    catch (error) { }
                }
                break;
            }
        }
        return logger.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: hexlify(data), errorArgs, errorName, errorSignature, reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
            logger.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
            });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return id(value);
            }
            else if (param.type === "bytes") {
                return keccak256(hexlify(value));
            }
            if (param.type === "bool" && typeof (value) === "boolean") {
                value = (value ? "0x01" : "0x00");
            }
            if (param.type.match(/^u?int/)) {
                value = BigNumber.from(value).toHexString();
            }
            // Check addresses are valid
            if (param.type === "address") {
                this._abiCoder.encode(["address"], [value]);
            }
            return hexZeroPad(hexlify(value), 32);
        };
        values.forEach((value, index) => {
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) {
                    logger.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                }
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
            logger.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push(id(value));
                }
                else if (param.type === "bytes") {
                    topics.push(keccak256(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                logger.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = new Indexed({ _isIndexed: true, hash: null });
                }
                else if (dynamic[index]) {
                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                }
                else {
                    try {
                        result[index] = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        result[index] = error;
                    }
                }
            }
            else {
                try {
                    result[index] = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    result[index] = error;
                }
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) {
                    Object.defineProperty(result, param.name, {
                        enumerable: true,
                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }
                    });
                }
                else {
                    result[param.name] = value;
                }
            }
        });
        // Make all error indexed values throw on access
        for (let i = 0; i < result.length; i++) {
            const value = result[i];
            if (value instanceof Error) {
                Object.defineProperty(result, i, {
                    enumerable: true,
                    get: () => { throw wrapAccessError(`index ${i}`, value); }
                });
            }
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: BigNumber.from(tx.value || "0"),
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = hexlify(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
        return !!(value && value._isInterface);
    }
}

var lib_esm = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ConstructorFragment: ConstructorFragment,
  ErrorFragment: ErrorFragment,
  EventFragment: EventFragment,
  Fragment: Fragment,
  FunctionFragment: FunctionFragment,
  ParamType: ParamType,
  FormatTypes: FormatTypes,
  AbiCoder: AbiCoder,
  defaultAbiCoder: defaultAbiCoder,
  Interface: Interface,
  Indexed: Indexed,
  checkResultErrors: checkResultErrors,
  LogDescription: LogDescription,
  TransactionDescription: TransactionDescription
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(lib_esm);

var __awaiter$5 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$5 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(EthereumContract$1, "__esModule", { value: true });
var abi_1 = require$$0;
var EthereumContract = /** @class */ (function () {
    function EthereumContract(abi, address, provider) {
        this.abi = abi;
        this.address = address;
        this.provider = provider;
        this.coder = new abi_1.Interface(this.abi);
    }
    EthereumContract.prototype.call = function (method, args) {
        return __awaiter$5(this, void 0, void 0, function () {
            var inputParam, response;
            return __generator$5(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        inputParam = this.coder.encodeFunctionData(method, args);
                        return [4 /*yield*/, this.callEth(inputParam)];
                    case 1:
                        response = (_a.sent());
                        if (!response || response === '0x') {
                            return [2 /*return*/, []];
                        }
                        return [2 /*return*/, this.coder.decodeFunctionResult(method, response)];
                }
            });
        });
    };
    EthereumContract.prototype.multicall = function (callArgs) {
        return __awaiter$5(this, void 0, void 0, function () {
            var methods, _i, callArgs_1, call, inputParam, response, multicallResult, results, i;
            return __generator$5(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methods = [];
                        for (_i = 0, callArgs_1 = callArgs; _i < callArgs_1.length; _i++) {
                            call = callArgs_1[_i];
                            methods.push(this.coder.encodeFunctionData(call.method, call.args));
                        }
                        inputParam = this.coder.encodeFunctionData('multicall', [methods]);
                        return [4 /*yield*/, this.callEth(inputParam)];
                    case 1:
                        response = (_a.sent());
                        if (!response || response === '0x') {
                            return [2 /*return*/, []];
                        }
                        multicallResult = this.coder.decodeFunctionResult('multicall', response);
                        results = [];
                        for (i = 0; i < multicallResult.results.length; i++) {
                            results.push(this.coder.decodeFunctionResult(callArgs[i].method, multicallResult.results[i]));
                        }
                        return [2 /*return*/, results];
                }
            });
        });
    };
    EthereumContract.prototype.fetchLogs = function (eventName, tokenId, fromBlock) {
        if (fromBlock === void 0) { fromBlock = 'earliest'; }
        return __awaiter$5(this, void 0, void 0, function () {
            var topic, params, request;
            return __generator$5(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        topic = this.coder.getEventTopic(eventName);
                        params = [
                            {
                                fromBlock: fromBlock,
                                toBlock: 'latest',
                                address: this.address,
                                topics: [topic, tokenId],
                            },
                        ];
                        request = {
                            method: 'eth_getLogs',
                            params: params,
                        };
                        return [4 /*yield*/, this.provider.request(request)];
                    case 1: return [2 /*return*/, (_a.sent())];
                }
            });
        });
    };
    EthereumContract.prototype.callEth = function (data) {
        return __awaiter$5(this, void 0, void 0, function () {
            var params, request;
            return __generator$5(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = [
                            {
                                data: data,
                                to: this.address,
                            },
                            'latest',
                        ];
                        request = {
                            method: 'eth_call',
                            params: params,
                        };
                        return [4 /*yield*/, this.provider.request(request)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return EthereumContract;
}());
EthereumContract$1.default = EthereumContract;

var proxyReader = {};

Object.defineProperty(proxyReader, "__esModule", { value: true });
proxyReader.default = [
    {
        inputs: [
            {
                internalType: 'contract IUNSRegistry',
                name: 'unsRegistry',
                type: 'address',
            },
            {
                internalType: 'contract ICNSRegistry',
                name: 'cnsRegistry',
                type: 'address',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'constructor',
    },
    {
        inputs: [],
        name: 'NAME',
        outputs: [
            {
                internalType: 'string',
                name: '',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'VERSION',
        outputs: [
            {
                internalType: 'string',
                name: '',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
            {
                internalType: 'string',
                name: 'label',
                type: 'string',
            },
        ],
        name: 'childIdOf',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'exists',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'string',
                name: 'key',
                type: 'string',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'get',
        outputs: [
            {
                internalType: 'string',
                name: 'value',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'getApproved',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'keyHash',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'getByHash',
        outputs: [
            {
                internalType: 'string',
                name: 'key',
                type: 'string',
            },
            {
                internalType: 'string',
                name: 'value',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'string[]',
                name: 'keys',
                type: 'string[]',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'getData',
        outputs: [
            {
                internalType: 'address',
                name: 'resolver',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                internalType: 'string[]',
                name: 'values',
                type: 'string[]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256[]',
                name: 'keyHashes',
                type: 'uint256[]',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'getDataByHash',
        outputs: [
            {
                internalType: 'address',
                name: 'resolver',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                internalType: 'string[]',
                name: 'keys',
                type: 'string[]',
            },
            {
                internalType: 'string[]',
                name: 'values',
                type: 'string[]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256[]',
                name: 'keyHashes',
                type: 'uint256[]',
            },
            {
                internalType: 'uint256[]',
                name: 'tokenIds',
                type: 'uint256[]',
            },
        ],
        name: 'getDataByHashForMany',
        outputs: [
            {
                internalType: 'address[]',
                name: 'resolvers',
                type: 'address[]',
            },
            {
                internalType: 'address[]',
                name: 'owners',
                type: 'address[]',
            },
            {
                internalType: 'string[][]',
                name: 'keys',
                type: 'string[][]',
            },
            {
                internalType: 'string[][]',
                name: 'values',
                type: 'string[][]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'string[]',
                name: 'keys',
                type: 'string[]',
            },
            {
                internalType: 'uint256[]',
                name: 'tokenIds',
                type: 'uint256[]',
            },
        ],
        name: 'getDataForMany',
        outputs: [
            {
                internalType: 'address[]',
                name: 'resolvers',
                type: 'address[]',
            },
            {
                internalType: 'address[]',
                name: 'owners',
                type: 'address[]',
            },
            {
                internalType: 'string[][]',
                name: 'values',
                type: 'string[][]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'string[]',
                name: 'keys',
                type: 'string[]',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'getMany',
        outputs: [
            {
                internalType: 'string[]',
                name: 'values',
                type: 'string[]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256[]',
                name: 'keyHashes',
                type: 'uint256[]',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'getManyByHash',
        outputs: [
            {
                internalType: 'string[]',
                name: 'keys',
                type: 'string[]',
            },
            {
                internalType: 'string[]',
                name: 'values',
                type: 'string[]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        name: 'isApprovedForAll',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'pure',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'isApprovedOrOwner',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes[]',
                name: 'data',
                type: 'bytes[]',
            },
        ],
        name: 'multicall',
        outputs: [
            {
                internalType: 'bytes[]',
                name: 'results',
                type: 'bytes[]',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'ownerOf',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256[]',
                name: 'tokenIds',
                type: 'uint256[]',
            },
        ],
        name: 'ownerOfForMany',
        outputs: [
            {
                internalType: 'address[]',
                name: 'owners',
                type: 'address[]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'registryOf',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'resolverOf',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes4',
                name: 'interfaceId',
                type: 'bytes4',
            },
        ],
        name: 'supportsInterface',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'tokenURI',
        outputs: [
            {
                internalType: 'string',
                name: '',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [{ internalType: 'address', name: 'addr', type: 'address' }],
        name: 'reverseOf',
        outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
    },
];

var version$1 = "0.4.0";
var networks = {
	"1": {
		contracts: {
			UNSRegistry: {
				address: "0x049aba7510f45BA5b64ea9E658E342F904DB358D",
				implementation: "0xa715562307AA8AEDCba976b3793b3337F371c14a",
				legacyAddresses: [
				],
				deploymentBlock: "0xd62e9d",
				forwarder: "0x049aba7510f45BA5b64ea9E658E342F904DB358D"
			},
			CNSRegistry: {
				address: "0xD1E5b0FF1287aA9f9A268759062E4Ab08b9Dacbe",
				legacyAddresses: [
				],
				deploymentBlock: "0x8a958b",
				forwarder: "0x97B0E89fC1B7eD4A8B237D9d8Fcce9b234f25A37"
			},
			MintingManager: {
				address: "0x2a7084870bB724175a3C96Da8FaA55128fa3E19D",
				implementation: "0x8caAeaD19aab5f54C94BB9F4be32e200E54AC8D7",
				legacyAddresses: [
				],
				deploymentBlock: "0xc2fee0",
				forwarder: "0xb970fbCF52cd8111c76c379D4f2FE12E7f8AE7fb"
			},
			ProxyAdmin: {
				address: "0xAA16DA78110D9A9742c760a1a064F28654Ab93de",
				legacyAddresses: [
				],
				deploymentBlock: "0xc2fedc"
			},
			SignatureController: {
				address: "0x82EF94294C95aD0930055f31e53A34509227c5f7",
				legacyAddresses: [
				],
				deploymentBlock: "0x8a95a6"
			},
			MintingController: {
				address: "0xb0EE56339C3253361730F50c08d3d7817ecD60Ca",
				legacyAddresses: [
				],
				deploymentBlock: "0x8a95aa",
				deprecated: true
			},
			WhitelistedMinter: {
				address: "0xd3fF3377b0ceade1303dAF9Db04068ef8a650757",
				legacyAddresses: [
				],
				deploymentBlock: "0xa76ad3",
				deprecated: true
			},
			URIPrefixController: {
				address: "0x09B091492759737C03da9dB7eDF1CD6BCC3A9d91",
				legacyAddresses: [
				],
				deploymentBlock: "0x8a95ae",
				deprecated: true
			},
			DomainZoneController: {
				address: "0xeA70777e28E00E81f58b8921fC47F78B8a72eFE7",
				legacyAddresses: [
				],
				deploymentBlock: "0x98ca20",
				deprecated: true
			},
			Resolver: {
				address: "0xb66DcE2DA6afAAa98F2013446dBCB0f4B0ab2842",
				legacyAddresses: [
					"0xa1cac442be6673c49f8e74ffc7c4fd746f3cbd0d",
					"0x878bc2f3f717766ab69c0a5f9a6144931e61aed3"
				],
				deploymentBlock: "0x960844",
				forwarder: "0x486eb10E4F48C038513ECAf11585Ca2779768CF2"
			},
			ProxyReader: {
				address: "0x1BDc0fD4fbABeed3E611fd6195fCd5d41dcEF393",
				legacyAddresses: [
					"0x58034A288D2E56B661c9056A0C27273E5460B63c",
					"0xc3C2BAB5e3e52DBF311b2aAcEf2e40344f19494E",
					"0xfEe4D4F0aDFF8D84c12170306507554bC7045878",
					"0xa6E7cEf2EDDEA66352Fd68E5915b60BDbb7309f5",
					"0x7ea9Ee21077F84339eDa9C80048ec6db678642B1"
				],
				deploymentBlock: "0xde71cd"
			},
			TwitterValidationOperator: {
				address: "0x2F659766E3D08561CA3408FbAba7C0749ab2c402",
				legacyAddresses: [
					"0xbb486C6E9cF1faA86a6E3eAAFE2e5665C0507855"
				],
				deploymentBlock: "0xc300b5"
			},
			FreeMinter: {
				address: "0x1fC985cAc641ED5846b631f96F35d9b48Bc3b834",
				legacyAddresses: [
				],
				deploymentBlock: "0xacc390",
				deprecated: true
			},
			MintableERC721Predicate: {
				address: "0x932532aA4c0174b8453839A6E44eE09Cc615F2b7",
				legacyAddresses: [
				],
				deploymentBlock: "0xa3cf69"
			},
			RootChainManager: {
				address: "0xA0c68C638235ee32657e8f720a23ceC1bFc77C77",
				legacyAddresses: [
				],
				deploymentBlock: "0xa3cf4d"
			}
		}
	},
	"4": {
		contracts: {
			UNSRegistry: {
				address: "0x7fb83000B8eD59D3eAD22f0D584Df3a85fBC0086",
				implementation: "0xc479D7A65243f7Eb1641F06a6C04E5F06cb5c4F7",
				legacyAddresses: [
				],
				deploymentBlock: "0x85e628",
				forwarder: "0x7fb83000B8eD59D3eAD22f0D584Df3a85fBC0086"
			},
			CNSRegistry: {
				address: "0xAad76bea7CFEc82927239415BB18D2e93518ecBB",
				legacyAddresses: [
				],
				deploymentBlock: "0x7232bc",
				forwarder: "0xdf5CC97216785398D5C77348e68fc9461108f85d"
			},
			MintingManager: {
				address: "0xdAAf99A920D31F4f5720e4667b12b24e54A03070",
				implementation: "0x38Fa95a0AC0E59D6e2845eFADBc17aF0FF9c7089",
				legacyAddresses: [
				],
				deploymentBlock: "0x85e629",
				forwarder: "0xfB13e29C4D31a48B4Cd61131Cf3b681416e11681"
			},
			ProxyAdmin: {
				address: "0xaf9815005A208d1460b6fC60B4f90B9f2185E88c",
				legacyAddresses: [
				],
				deploymentBlock: "0x85e627"
			},
			SignatureController: {
				address: "0x66a5e3e2C27B4ce4F46BBd975270BE154748D164",
				legacyAddresses: [
				],
				deploymentBlock: "0x7232be"
			},
			MintingController: {
				address: "0x51765307AeB3Df2E647014a2C501d5324212467c",
				legacyAddresses: [
				],
				deploymentBlock: "0x7232bf",
				deprecated: true
			},
			WhitelistedMinter: {
				address: "0xbcB32f13f90978a9e059E8Cb40FaA9e6619d98e7",
				legacyAddresses: [
				],
				deploymentBlock: "0x7232c6",
				deprecated: true
			},
			URIPrefixController: {
				address: "0xe1d2e4B9f0518CA5c803073C3dFa886470627237",
				legacyAddresses: [
				],
				deploymentBlock: "0x7232c0",
				deprecated: true
			},
			DomainZoneController: {
				address: "0x6f8F96A566663C1d4fEe70edD37E9b62Fe39dE5D",
				legacyAddresses: [
				],
				deploymentBlock: "0x7232c2",
				deprecated: true
			},
			Resolver: {
				address: "0x95AE1515367aa64C462c71e87157771165B1287A",
				legacyAddresses: [
				],
				deploymentBlock: "0x7232cf",
				forwarder: "0xE172D8557d6F342b1b2976dE784F6Dff6ABC0a37"
			},
			ProxyReader: {
				address: "0xE6729D224D00b3dd4FC731C4Ee3274E35Da06578",
				legacyAddresses: [
					"0x299974AeD8911bcbd2C61262605b89F591a53E83",
					"0x9F19473F6a98a715176291c930558E1954fd3D1e",
					"0x3A2e74CF832cbA3d77E72708d55370119E4323a6"
				],
				deploymentBlock: "0x8dc79a"
			},
			TwitterValidationOperator: {
				address: "0x9ea4A63184ebE9CBA55CD1af473D98075Aa02b4C",
				legacyAddresses: [
					"0x1CB337b3b208dc29a6AcE8d11Bb591b66c5Dd83d"
				],
				deploymentBlock: "0x86935e"
			},
			FreeMinter: {
				address: "0x84214215904cDEbA9044ECf95F3eBF009185AAf4",
				legacyAddresses: [
				],
				deploymentBlock: "0x740d93",
				deprecated: true
			}
		}
	},
	"5": {
		contracts: {
			UNSRegistry: {
				address: "0x070e83FCed225184E67c86302493ffFCDB953f71",
				implementation: "0x4473e84898E3F58feEFb7529dfF9E83Ff26CCae9",
				legacyAddresses: [
				],
				deploymentBlock: "0x5b57ea",
				forwarder: "0x070e83FCed225184E67c86302493ffFCDB953f71"
			},
			CNSRegistry: {
				address: "0x801452cFAC27e79a11c6b185986fdE09e8637589",
				legacyAddresses: [
				],
				deploymentBlock: "0x5b57d7",
				forwarder: "0x00443017FFaa4C840Caf5Dc7d3CB59147f363080"
			},
			MintingManager: {
				address: "0x9ee42D3EB042e06F8Cd241890C4fA0d51e4DA345",
				implementation: "0xFB11410f3067BB6Db61bC335f0de23bE87A1767e",
				legacyAddresses: [
				],
				deploymentBlock: "0x5b57ec",
				forwarder: "0x7F9F48cF94C69ce91D4b442DA186F31118ac0185"
			},
			ProxyAdmin: {
				address: "0xf4906E210523F9dA79E33811A44EE000441F4E04",
				legacyAddresses: [
				],
				deploymentBlock: "0x5b57e8"
			},
			SignatureController: {
				address: "0x5199dAE4B24B987ba18FcE1b64664D1B798d372B",
				legacyAddresses: [
				],
				deploymentBlock: "0x5b57d8"
			},
			MintingController: {
				address: "0xCEC41677be322049cC885c0DAe2fE0D52CA195ca",
				legacyAddresses: [
				],
				deploymentBlock: "0x5b57d9",
				deprecated: true
			},
			WhitelistedMinter: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			URIPrefixController: {
				address: "0x29465e3d2daA588E62375977bCe9b3f51406a794",
				legacyAddresses: [
				],
				deploymentBlock: "0x5b57da",
				deprecated: true
			},
			DomainZoneController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			Resolver: {
				address: "0x0555344A5F440Bd1d8cb6B42db46c5e5D4070437",
				legacyAddresses: [
				],
				deploymentBlock: "0x5b57dc",
				forwarder: "0xFCc1A95B7287Ae7a8B7cA813F12991dF5714d4C7"
			},
			ProxyReader: {
				address: "0xE3b961856C417d081a02cBa0161a051268F52677",
				legacyAddresses: [
					"0x9A70ff906D422C2FD0F7B94244D6b36DB62Ee982",
					"0xFc5f608149f4D9e2Ed0733efFe9DD57ee24BCF68"
				],
				deploymentBlock: "0x65bdfe"
			},
			TwitterValidationOperator: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			},
			FreeMinter: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			MintableERC721Predicate: {
				address: "0x56E14C4C1748a818a5564D33cF774c59EB3eDF59",
				legacyAddresses: [
				],
				deploymentBlock: "0x2fc240"
			},
			RootChainManager: {
				address: "0xBbD7cBFA79faee899Eaf900F13C9065bF03B1A74",
				legacyAddresses: [
				],
				deploymentBlock: "0x2dc9b9"
			}
		}
	},
	"137": {
		contracts: {
			UNSRegistry: {
				address: "0xa9a6A3626993D487d2Dbda3173cf58cA1a9D9e9f",
				legacyAddresses: [
				],
				deploymentBlock: "0x019d6188",
				implementation: "0x5442953b0BFFf69FC945f5f1387cbFD2e2673447",
				forwarder: "0xa9a6A3626993D487d2Dbda3173cf58cA1a9D9e9f"
			},
			CNSRegistry: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				forwarder: "0x0000000000000000000000000000000000000000"
			},
			MintingManager: {
				address: "0x7be83293BeeDc9Eba1bd76c66A65F10F3efaeC26",
				legacyAddresses: [
				],
				deploymentBlock: "0x01272f41",
				implementation: "0xBb45a6E10224Aa36EAcd812205F3763D353e9783",
				forwarder: "0xC37d3c4326ab0E1D2b9D8b916bBdf5715f780fcF"
			},
			ProxyAdmin: {
				address: "0xe1D668052D52388F52b90f4d1798DB2b04bC3b88",
				legacyAddresses: [
				],
				deploymentBlock: "0x01272d15"
			},
			SignatureController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			},
			MintingController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			WhitelistedMinter: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			URIPrefixController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			DomainZoneController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			Resolver: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				forwarder: "0x0000000000000000000000000000000000000000"
			},
			ProxyReader: {
				address: "0x3E67b8c702a1292d1CEb025494C84367fcb12b45",
				legacyAddresses: [
					"0x423F2531bd5d3C3D4EF7C318c2D1d9BEDE67c680",
					"0xA3f32c8cd786dc089Bd1fC175F2707223aeE5d00"
				],
				deploymentBlock: "0x019d61a9"
			},
			TwitterValidationOperator: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			},
			FreeMinter: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			MintableERC721Predicate: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			},
			RootChainManager: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			}
		}
	},
	"1337": {
		contracts: {
			UNSRegistry: {
				address: "0x58a175BEbc8ec21A94ea63Aa5a28743945940EE6",
				legacyAddresses: [
				],
				deploymentBlock: "0x0d",
				implementation: "0xe0aFC4e9E03e4aa67257Df7A2Eca77454309789D",
				forwarder: "0x58a175BEbc8ec21A94ea63Aa5a28743945940EE6"
			},
			CNSRegistry: {
				address: "0xC58206842E4030a3B2CaBC78780Ae7635173C533",
				legacyAddresses: [
				],
				deploymentBlock: "0x01",
				forwarder: "0xAc52F68f31577E44aE0C7E95A42dC9eb574B9383"
			},
			MintingManager: {
				address: "0x27935e7e85db3c4e7885eB828B9e889BA69a4e7f",
				legacyAddresses: [
				],
				deploymentBlock: "0x0f",
				implementation: "0xa1A2114B0C4bDF9AEe05fdd80801e6267639FAd9",
				forwarder: "0xC20631145b77a58018E2b10f2282Dd048E12fC81"
			},
			ProxyAdmin: {
				address: "0xbE5dEAC45dd1ca4ee18Dc2D585D84D3d3CB82B0D",
				legacyAddresses: [
				],
				deploymentBlock: "0x01"
			},
			SignatureController: {
				address: "0x7bB6Cd9be29fab783c0b494A06FED8b2E2596B7a",
				legacyAddresses: [
				],
				deploymentBlock: "0x02"
			},
			MintingController: {
				address: "0x4a3C194eB88966178bfDD81744ddDafED611B830",
				legacyAddresses: [
				],
				deploymentBlock: "0x03",
				deprecated: true
			},
			WhitelistedMinter: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			URIPrefixController: {
				address: "0x4872CC1be60A9DB9c880A0A437Da7a6AF134F08f",
				legacyAddresses: [
				],
				deploymentBlock: "0x04",
				deprecated: true
			},
			DomainZoneController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			Resolver: {
				address: "0xF8C26340C1eAeA6c7fF1760B25005e1306953572",
				legacyAddresses: [
				],
				deploymentBlock: "0x08",
				forwarder: "0x11dD97b7Ca847DfB6504e61B7B9Eb30F55E554a0"
			},
			ProxyReader: {
				address: "0x4e44E79e0cEc05D9e62e952B2088c02A3C450aeC",
				legacyAddresses: [
				],
				deploymentBlock: "0x14"
			},
			TwitterValidationOperator: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			},
			FreeMinter: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			MintableERC721Predicate: {
				address: "0x7c3c91245769c8B7450aD522792deC4bd4bf797f",
				legacyAddresses: [
				],
				deploymentBlock: "0x1b"
			},
			RootChainManager: {
				address: "0x2f5e6eed50C839835BD2873d428E1683793Ad09D",
				legacyAddresses: [
				],
				deploymentBlock: "0x1d"
			}
		}
	},
	"80001": {
		contracts: {
			UNSRegistry: {
				address: "0x2a93C52E7B6E7054870758e15A1446E769EdfB93",
				legacyAddresses: [
				],
				deploymentBlock: "0x0189f713",
				implementation: "0xAc1a1F2136BfDe3a353a95C0676Cd0d55f311ee3",
				forwarder: "0x2a93C52E7B6E7054870758e15A1446E769EdfB93"
			},
			CNSRegistry: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				forwarder: "0x0000000000000000000000000000000000000000"
			},
			MintingManager: {
				address: "0x428189346bb3CC52f031A1092fd47C919AC30A9f",
				legacyAddresses: [
				],
				deploymentBlock: "0x01213f4a",
				implementation: "0xCC17E698bA21bae4277579F22cA51135AaF00777",
				forwarder: "0xEf3a491A8750BEC2Dff5339CF6Df94436d432C4d"
			},
			ProxyAdmin: {
				address: "0x460d63117c7Ab1624b7474C45BF46eC6702f57ce",
				legacyAddresses: [
				],
				deploymentBlock: "0x01213b22"
			},
			SignatureController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			},
			MintingController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			WhitelistedMinter: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			URIPrefixController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			DomainZoneController: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			Resolver: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				forwarder: "0x0000000000000000000000000000000000000000"
			},
			ProxyReader: {
				address: "0x6fe7c857C1B0E54492C8762f27e0a45CA7ff264B",
				legacyAddresses: [
					"0xbd9e01F6513E7C05f71Bf21d419a3bDF1EA9104b",
					"0x332A8191905fA8E6eeA7350B5799F225B8ed30a9"
				],
				deploymentBlock: "0x0189f72d"
			},
			TwitterValidationOperator: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			},
			FreeMinter: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0",
				deprecated: true
			},
			MintableERC721Predicate: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			},
			RootChainManager: {
				address: "0x0000000000000000000000000000000000000000",
				legacyAddresses: [
				],
				deploymentBlock: "0x0"
			}
		}
	}
};
var require$$6 = {
	version: version$1,
	networks: networks
};

var __createBinding$5 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$5 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$5 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$5(result, mod, k);
    __setModuleDefault$5(result, mod);
    return result;
};
var __awaiter$4 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$4 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray$2 = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(UnsInternal$1, "__esModule", { value: true });
var types_1$1 = types;
var configurationError_1$2 = __importDefault$3(configurationError);
var configurationError_2 = configurationError;
var utils_1$3 = utils$n;
var FetchProvider_1$1 = __importDefault$3(FetchProvider$1);
var EthereumContract_1 = __importDefault$3(EthereumContract$1);
var proxyReader_1 = __importDefault$3(proxyReader);
var uns_config_json_1 = __importDefault$3(require$$6);
var resolutionError_1$5 = __importStar$5(resolutionError);
var namehash_1$3 = namehash;
var UnsInternal = /** @class */ (function () {
    function UnsInternal(unsLocation, source, blockchain) {
        this.unsLocation = unsLocation;
        this.checkNetworkConfig(unsLocation, source);
        this.network = source.network;
        this.blockchain = blockchain;
        this.url = source['url'] || UnsInternal.UrlMap[this.network];
        this.provider =
            source['provider'] || new FetchProvider_1$1.default(this.unsLocation, this.url);
        this.readerContract = new EthereumContract_1.default(proxyReader_1.default, source.proxyReaderAddress ||
            UnsInternal.ProxyReaderMap[utils_1$3.EthereumNetworks[this.network]], this.provider);
    }
    UnsInternal.prototype.exists = function (domain) {
        return __awaiter$4(this, void 0, void 0, function () {
            var exists;
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readerContract.call('exists', [
                            this.namehash(domain),
                        ])];
                    case 1:
                        exists = (_a.sent())[0];
                        return [2 /*return*/, exists];
                }
            });
        });
    };
    UnsInternal.prototype.reverseOf = function (addr) {
        return __awaiter$4(this, void 0, void 0, function () {
            var reverseHash;
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readerContract.call('reverseOf', [addr])];
                    case 1:
                        reverseHash = (_a.sent())[0];
                        return [2 /*return*/, reverseHash];
                }
            });
        });
    };
    UnsInternal.prototype.getTokenUri = function (tokenId) {
        return __awaiter$4(this, void 0, void 0, function () {
            var tokenURI;
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.readerContract.call('tokenURI', [tokenId])];
                    case 1:
                        tokenURI = (_a.sent())[0];
                        return [2 /*return*/, tokenURI];
                }
            });
        });
    };
    UnsInternal.prototype.registryAddress = function (domainOrNamehash) {
        return __awaiter$4(this, void 0, void 0, function () {
            var isNamehash, namehash, address;
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isNamehash = !domainOrNamehash.includes('.');
                        if (!this.checkDomain(domainOrNamehash, isNamehash)) {
                            throw new resolutionError_1$5.default(resolutionError_1$5.ResolutionErrorCode.UnsupportedDomain, {
                                domain: domainOrNamehash,
                            });
                        }
                        namehash = isNamehash
                            ? domainOrNamehash
                            : this.namehash(domainOrNamehash);
                        return [4 /*yield*/, this.readerContract.call('registryOf', [namehash])];
                    case 1:
                        address = (_a.sent())[0];
                        if ((0, utils_1$3.isNullAddress)(address)) {
                            throw new resolutionError_1$5.default(resolutionError_1$5.ResolutionErrorCode.UnregisteredDomain, {
                                domain: domainOrNamehash,
                            });
                        }
                        return [2 /*return*/, address];
                }
            });
        });
    };
    UnsInternal.prototype.resolver = function (domain) {
        return __awaiter$4(this, void 0, void 0, function () {
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getVerifiedData(domain)];
                    case 1: return [2 /*return*/, (_a.sent()).resolver];
                }
            });
        });
    };
    UnsInternal.prototype.get = function (tokenId, keys) {
        if (keys === void 0) { keys = []; }
        return __awaiter$4(this, void 0, void 0, function () {
            var _a, resolver, owner, values;
            return __generator$4(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.readerContract.call('getData', [keys, tokenId])];
                    case 1:
                        _a = _b.sent(), resolver = _a[0], owner = _a[1], values = _a[2];
                        return [2 /*return*/, {
                                owner: owner,
                                resolver: resolver,
                                records: (0, utils_1$3.constructRecords)(keys, values),
                                location: this.unsLocation,
                            }];
                }
            });
        });
    };
    UnsInternal.prototype.locations = function (domains) {
        return __awaiter$4(this, void 0, void 0, function () {
            var tokenIds, _a, _b, resolvers, owners, registries, locations;
            var _this = this;
            return __generator$4(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        tokenIds = domains.map(function (d) { return _this.namehash(d); });
                        return [4 /*yield*/, this.readerContract.multicall(__spreadArray$2([
                                {
                                    method: 'getDataForMany',
                                    args: [[], tokenIds],
                                }
                            ], tokenIds.map(function (id) { return ({
                                method: 'registryOf',
                                args: [id],
                            }); }), true))];
                    case 1:
                        _a = _c.sent(), _b = _a[0], resolvers = _b[0], owners = _b[1], registries = _a.slice(1);
                        locations = domains.reduce(function (locations, domain, i) {
                            locations[domain] = null;
                            if (owners && owners[i] !== types_1$1.NullAddress) {
                                locations[domain] = {
                                    resolverAddress: resolvers[i],
                                    registryAddress: registries[i][0],
                                    ownerAddress: owners[i],
                                    networkId: utils_1$3.EthereumNetworks[_this.network],
                                    blockchain: _this.blockchain,
                                    blockchainProviderUrl: _this.url,
                                };
                            }
                            return locations;
                        }, {});
                        return [2 /*return*/, locations];
                }
            });
        });
    };
    UnsInternal.prototype.namehash = function (domain) {
        if (!this.checkDomain(domain)) {
            throw new resolutionError_1$5.default(resolutionError_1$5.ResolutionErrorCode.UnsupportedDomain, {
                domain: domain,
            });
        }
        return (0, namehash_1$3.eip137Namehash)(domain);
    };
    UnsInternal.prototype.checkDomain = function (domain, passIfTokenID) {
        if (passIfTokenID === void 0) { passIfTokenID = false; }
        if (passIfTokenID) {
            return true;
        }
        var tokens = domain.split('.');
        return (!!tokens.length &&
            !(domain === 'eth' ||
                /^[^-]*[^-]*\.(eth|luxe|xyz|kred|addr\.reverse)$/.test(domain)) &&
            tokens.every(function (v) { return !!v.length; }));
    };
    UnsInternal.prototype.getVerifiedData = function (domain, keys) {
        return __awaiter$4(this, void 0, void 0, function () {
            var tokenId, data;
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenId = this.namehash(domain);
                        return [4 /*yield*/, this.get(tokenId, keys)];
                    case 1:
                        data = _a.sent();
                        if ((0, utils_1$3.isNullAddress)(data.resolver)) {
                            if ((0, utils_1$3.isNullAddress)(data.owner)) {
                                throw new resolutionError_1$5.default(resolutionError_1$5.ResolutionErrorCode.UnregisteredDomain, {
                                    domain: domain,
                                });
                            }
                            throw new resolutionError_1$5.default(resolutionError_1$5.ResolutionErrorCode.UnspecifiedResolver, {
                                location: this.unsLocation,
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, data];
                }
            });
        });
    };
    UnsInternal.prototype.checkNetworkConfig = function (location, source) {
        if (!source.network) {
            throw new configurationError_1$2.default(configurationError_2.ConfigurationErrorCode.UnsupportedNetwork, {
                method: location,
            });
        }
        if (source.proxyReaderAddress &&
            !this.isValidProxyReader(source.proxyReaderAddress)) {
            throw new configurationError_1$2.default(configurationError_2.ConfigurationErrorCode.InvalidConfigurationField, {
                method: this.unsLocation,
                field: 'proxyReaderAddress',
            });
        }
        if (!types_1$1.UnsSupportedNetwork.guard(source.network)) {
            this.checkCustomNetworkConfig(source);
        }
    };
    UnsInternal.prototype.checkCustomNetworkConfig = function (source) {
        if (!this.isValidProxyReader(source.proxyReaderAddress)) {
            throw new configurationError_1$2.default(configurationError_2.ConfigurationErrorCode.InvalidConfigurationField, {
                method: this.unsLocation,
                field: 'proxyReaderAddress',
            });
        }
        if (!source['url'] && !source['provider']) {
            throw new configurationError_1$2.default(configurationError_2.ConfigurationErrorCode.CustomNetworkConfigMissing, {
                method: this.unsLocation,
                config: 'url or provider',
            });
        }
    };
    UnsInternal.prototype.isValidProxyReader = function (address) {
        if (!address) {
            throw new configurationError_1$2.default(configurationError_2.ConfigurationErrorCode.CustomNetworkConfigMissing, {
                method: this.unsLocation,
                config: 'proxyReaderAddress',
            });
        }
        var ethLikePattern = new RegExp('^0x[a-fA-F0-9]{40}$');
        return ethLikePattern.test(address);
    };
    UnsInternal.ProxyReaderMap = getProxyReaderMap();
    UnsInternal.UrlMap = {
        mainnet: 'https://eth-mainnet.alchemyapi.io/v2/GmQ8X1FHf-WDEry0BBSn0RgjVhjHkRmS',
        rinkeby: 'https://eth-rinkeby.alchemyapi.io/v2/ZDERxOLIj120dh2-Io2Q9RTh9RfWEssT',
        goerli: 'https://eth-goerli.alchemyapi.io/v2/J-ff_OlmWzw41ocqwpkRccHdfqSZML4q',
        'polygon-mainnet': 'https://polygon-mainnet.g.alchemy.com/v2/iG-oHZ2FvjqC9D43O5q9sj62out5ubsy',
        'polygon-mumbai': 'https://polygon-mumbai.g.alchemy.com/v2/YtQwLH1UOmRGgQp_Rg1TXvFWSWeV5Y02',
    };
    return UnsInternal;
}());
UnsInternal$1.default = UnsInternal;
function getProxyReaderMap() {
    var map = {};
    for (var _i = 0, _a = Object.keys(uns_config_json_1.default.networks); _i < _a.length; _i++) {
        var id = _a[_i];
        map[id] =
            uns_config_json_1.default.networks[id].contracts.ProxyReader.address.toLowerCase();
    }
    return map;
}

var version = "2.1.1";
var information = {
	description: "This file desribes all resolver keys with a defined meaning and related metadata used by Unstoppable Domains UNS Registry",
	documentation: "https://docs.unstoppabledomains.com/domain-registry-essentials/records-reference",
	contribution: "https://github.com/unstoppabledomains/uns/blob/main/resolver-keys.json"
};
var keys = {
	"crypto.BTC.address": {
		deprecatedKeyName: "BTC",
		deprecated: false,
		validationRegex: "^bc1[ac-hj-np-z02-9]{6,87}$|^[13][a-km-zA-HJ-NP-Z1-9]{25,39}$"
	},
	"crypto.ETH.address": {
		deprecatedKeyName: "ETH",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.ZIL.address": {
		deprecatedKeyName: "ZIL",
		deprecated: false,
		validationRegex: "^zil1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$"
	},
	"crypto.LTC.address": {
		deprecatedKeyName: "LTC",
		deprecated: false,
		validationRegex: "^[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}$|^ltc1[a-zA-HJ-NP-Z0-9]{25,39}$"
	},
	"crypto.ETC.address": {
		deprecatedKeyName: "ETC",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.EQL.address": {
		deprecatedKeyName: "EQL",
		deprecated: false,
		validationRegex: "^bnb[0-9a-z]{39}$"
	},
	"crypto.LINK.address": {
		deprecatedKeyName: "LINK",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.USDC.address": {
		deprecatedKeyName: "USDC",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.BAT.address": {
		deprecatedKeyName: "BAT",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.REP.address": {
		deprecatedKeyName: "REP",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.ZRX.address": {
		deprecatedKeyName: "ZRX",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.DAI.address": {
		deprecatedKeyName: "DAI",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.BCH.address": {
		deprecatedKeyName: "BCH",
		deprecated: false,
		validationRegex: "^[13][a-km-zA-HJ-NP-Z1-9]{33}$|^((bitcoincash|bchreg|bchtest):)?(q|p)[a-z0-9]{41}$|^((BITCOINCASH:)?(Q|P)[A-Z0-9]{41})$"
	},
	"crypto.XMR.address": {
		deprecatedKeyName: "XMR",
		deprecated: false,
		validationRegex: "^[48]{1}[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$"
	},
	"crypto.DASH.address": {
		deprecatedKeyName: "DASH",
		deprecated: false,
		validationRegex: "^X[1-9A-HJ-NP-Za-km-z]{33}$"
	},
	"crypto.NEO.address": {
		deprecatedKeyName: "NEO",
		deprecated: false,
		validationRegex: "^A[0-9a-zA-Z]{33}$"
	},
	"crypto.SWTH.address": {
		deprecatedKeyName: "SWTH",
		deprecated: false,
		validationRegex: "^A[0-9a-zA-Z]{33}$"
	},
	"crypto.DOGE.address": {
		deprecatedKeyName: "DOGE",
		deprecated: false,
		validationRegex: "^D[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}$"
	},
	"crypto.XRP.address": {
		deprecatedKeyName: "XRP",
		deprecated: false,
		validationRegex: "^r[1-9a-km-zA-HJ-NP-Z]{24,34}$"
	},
	"crypto.ZEC.address": {
		deprecatedKeyName: "ZEC",
		deprecated: false,
		validationRegex: "^z([a-zA-Z0-9]){94}$|^zs1([a-zA-Z0-9]){75}$|^t([a-zA-Z0-9]){34}$"
	},
	"crypto.YEC.address": {
		deprecatedKeyName: "YEC",
		deprecated: false,
		validationRegex: "^y([a-zA-Z0-9]){94}$|^ys1([a-zA-Z0-9]){75}$|^s([a-zA-Z0-9]){34}$"
	},
	"crypto.ADA.address": {
		deprecatedKeyName: "ADA",
		deprecated: false,
		validationRegex: "^[1-9a-km-zA-HJ-NP-Z]{104}$|^A[1-9A-HJ-NP-Za-km-z]{58}$|^addr[0-9a-zA-Z]{99}$"
	},
	"crypto.EOS.address": {
		deprecatedKeyName: "EOS",
		deprecated: false,
		validationRegex: "^[a-z][a-z1-5.]{10}[a-z1-5]$"
	},
	"crypto.XLM.address": {
		deprecatedKeyName: "XLM",
		deprecated: false,
		validationRegex: "^G[A-Z2-7]{55}$"
	},
	"crypto.BNB.address": {
		deprecatedKeyName: "BNB",
		deprecated: false,
		validationRegex: "^bnb[0-9a-z]{39}$"
	},
	"crypto.BTG.address": {
		deprecatedKeyName: "BTG",
		deprecated: false,
		validationRegex: "^[GA][a-km-zA-HJ-NP-Z1-9]{33}$"
	},
	"crypto.NANO.address": {
		deprecatedKeyName: "NANO",
		deprecated: false,
		validationRegex: "^nano_[1-9a-z]{60}$"
	},
	"crypto.WAVES.address": {
		deprecatedKeyName: "WAVES",
		deprecated: false,
		validationRegex: "^3[a-km-zA-HJ-NP-Z1-9]{34}$"
	},
	"crypto.KMD.address": {
		deprecatedKeyName: "KMD",
		deprecated: false,
		validationRegex: "^R[a-km-zA-Z1-9]{33}$"
	},
	"crypto.AE.address": {
		deprecatedKeyName: "AE",
		deprecated: false,
		validationRegex: "^ak_[a-km-zA-Z1-9]{48,52}$"
	},
	"crypto.RSK.address": {
		deprecatedKeyName: "RSK",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.WAN.address": {
		deprecatedKeyName: "WAN",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.STRAT.address": {
		deprecatedKeyName: "STRAT",
		deprecated: false,
		validationRegex: "^S[a-km-zA-HJ-NP-Z1-9]{33}$"
	},
	"crypto.UBQ.address": {
		deprecatedKeyName: "UBQ",
		deprecated: false,
		validationRegex: "^0x[a-km-zA-HJ-NP-Z0-9]{40}$"
	},
	"crypto.XTZ.address": {
		deprecatedKeyName: "XTZ",
		deprecated: false,
		validationRegex: "^(tz|KT)[a-km-zA-HJ-NP-Z1-9]{34}$"
	},
	"crypto.IOTA.address": {
		deprecatedKeyName: "IOTA",
		deprecated: false,
		validationRegex: "^[A-Z0-9]{90}$|^iota1[a-z0-9]{59}$"
	},
	"crypto.VET.address": {
		deprecatedKeyName: "VET",
		deprecated: false,
		validationRegex: "^0x[a-km-zA-HJ-NP-Z0-9]{40}$"
	},
	"crypto.QTUM.address": {
		deprecatedKeyName: "QTUM",
		deprecated: false,
		validationRegex: "^Q[a-km-zA-HJ-NP-Z1-9]{33}$"
	},
	"crypto.ICX.address": {
		deprecatedKeyName: "ICX",
		deprecated: false,
		validationRegex: "^[a-km-zA-HJ-NP-Z0-9]{42}$"
	},
	"crypto.DGB.address": {
		deprecatedKeyName: "DGB",
		deprecated: false,
		validationRegex: "(^[a-km-zA-HJ-NP-Z1-9]{34}$)|(^[a-zA-Z1-9]{42}$)|(^dgb1[a-zA-Z0-9]{39}$)"
	},
	"crypto.XZC.address": {
		deprecatedKeyName: "XZC",
		deprecated: false,
		validationRegex: "^[a-km-zA-HJ-NP-Z1-9]{34}$"
	},
	"crypto.BURST.address": {
		deprecatedKeyName: "BURST",
		deprecated: false,
		validationRegex: "^BURST-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{5}"
	},
	"crypto.DCR.address": {
		deprecatedKeyName: "DCR",
		deprecated: false,
		validationRegex: null
	},
	"crypto.XEM.address": {
		deprecatedKeyName: "XEM",
		deprecated: false,
		validationRegex: "^N[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{39}$"
	},
	"crypto.LSK.address": {
		deprecatedKeyName: "LSK",
		deprecated: false,
		validationRegex: "^\\d{1,21}[L]$"
	},
	"crypto.ATOM.address": {
		deprecatedKeyName: "ATOM",
		deprecated: false,
		validationRegex: "^(cosmos)1([qpzry9x8gf2tvdw0s3jn54khce6mua7l]+)$"
	},
	"crypto.ONG.address": {
		deprecatedKeyName: "ONG",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.ONT.address": {
		deprecatedKeyName: "ONT",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.SMART.address": {
		deprecatedKeyName: "SMART",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.TPAY.address": {
		deprecatedKeyName: "TPAY",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.GRS.address": {
		deprecatedKeyName: "GRS",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.BSV.address": {
		deprecatedKeyName: "BSV",
		deprecated: false,
		validationRegex: "^bitcoincash:[a-zA-Z0-9]{42}$"
	},
	"crypto.GAS.address": {
		deprecatedKeyName: "GAS",
		deprecated: false,
		validationRegex: null
	},
	"crypto.TRX.address": {
		deprecatedKeyName: "TRX",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.VTHO.address": {
		deprecatedKeyName: "VTHO",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{42}$"
	},
	"crypto.BCD.address": {
		deprecatedKeyName: "BCD",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.BTT.address": {
		deprecatedKeyName: "BTT",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.KIN.address": {
		deprecatedKeyName: "KIN",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{56}$"
	},
	"crypto.RVN.address": {
		deprecatedKeyName: "RVN",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.ARK.address": {
		deprecatedKeyName: "ARK",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.XVG.address": {
		deprecatedKeyName: "XVG",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.ALGO.address": {
		deprecatedKeyName: "ALGO",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{58}$"
	},
	"crypto.NEBL.address": {
		deprecatedKeyName: "NEBL",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.XPM.address": {
		deprecatedKeyName: "XPM",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.ONE.address": {
		deprecatedKeyName: "ONE",
		deprecated: false,
		validationRegex: "^one[a-zA-Z0-9]{39}$"
	},
	"crypto.BNTY.address": {
		deprecatedKeyName: "BNTY",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.CRO.address": {
		deprecatedKeyName: "CRO",
		deprecated: false,
		validationRegex: "^0x[a-fA-F0-9]{40}$"
	},
	"crypto.TWT.address": {
		deprecatedKeyName: "TWT",
		deprecated: false,
		validationRegex: "^bnb[0-9a-z]{39}$"
	},
	"crypto.SIERRA.address": {
		deprecatedKeyName: "SIERRA",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{34}$"
	},
	"crypto.VSYS.address": {
		deprecatedKeyName: "VSYS",
		deprecated: false,
		validationRegex: "^[a-zA-Z0-9]{35}$"
	},
	"crypto.HIVE.address": {
		deprecatedKeyName: "HIVE",
		validationRegex: "^(?!s*$).+",
		deprecated: false
	},
	"crypto.HT.address": {
		deprecatedKeyName: "HT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ENJ.address": {
		deprecatedKeyName: "ENJ",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.YFI.address": {
		deprecatedKeyName: "YFI",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MTA.address": {
		deprecatedKeyName: "MTA",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.COMP.address": {
		deprecatedKeyName: "COMP",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.BAL.address": {
		deprecatedKeyName: "BAL",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.AMPL.address": {
		deprecatedKeyName: "AMPL",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.LEND.address": {
		deprecatedKeyName: "LEND",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.TLOS.address": {
		deprecatedKeyName: "TLOS",
		validationRegex: "^[a-z][a-z1-5.]{10}[a-z1-5]$",
		deprecated: false
	},
	"crypto.XDC.address": {
		deprecatedKeyName: "XDC",
		validationRegex: "^xdc[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.XST.address": {
		deprecatedKeyName: "XST",
		validationRegex: "(?:RwxQ3jUs2BjKhseNX1em4msn2GyV5XAec[PQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]|RwxQ3jUs2BjKhseNX1em4msn2GyV5XAe[defghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]|RwxQ3jUs2BjKhseNX1em4msn2GyV5XA[fghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{2}|RwxQ3jUs2BjKhseNX1em4msn2GyV5X[BCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{3}|RwxQ3jUs2BjKhseNX1em4msn2GyV5[YZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{4}|RwxQ3jUs2BjKhseNX1em4msn2GyV[6789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{5}|RwxQ3jUs2BjKhseNX1em4msn2Gy[WXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{6}|RwxQ3jUs2BjKhseNX1em4msn2G[z][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{7}|RwxQ3jUs2BjKhseNX1em4msn2[HJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{8}|RwxQ3jUs2BjKhseNX1em4msn[3456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{9}|RwxQ3jUs2BjKhseNX1em4ms[opqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{10}|RwxQ3jUs2BjKhseNX1em4m[tuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{11}|RwxQ3jUs2BjKhseNX1em4[nopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{12}|RwxQ3jUs2BjKhseNX1em[56789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{13}|RwxQ3jUs2BjKhseNX1e[nopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{14}|RwxQ3jUs2BjKhseNX1[fghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{15}|RwxQ3jUs2BjKhseNX[23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{16}|RwxQ3jUs2BjKhseN[YZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{17}|RwxQ3jUs2BjKhse[PQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{18}|RwxQ3jUs2BjKhs[fghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{19}|RwxQ3jUs2BjKh[tuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{20}|RwxQ3jUs2BjK[ijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{21}|RwxQ3jUs2Bj[LMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{22}|RwxQ3jUs2B[kmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{23}|RwxQ3jUs2[CDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{24}|RwxQ3jUs[3456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{25}|RwxQ3jU[tuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{26}|RwxQ3j[VWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{27}|RwxQ3[kmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{28}|RwxQ[456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{29}|Rwx[RSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{30}|Rw[yz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{31}|R[xyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{32}|S[123456789ABCDEFGHJKL][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{32}|SM[123456789ABCDEFGH][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{31}|SMJ11[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{29}|SMJ11[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{29}|SMJ12[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnop][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{28}|SMJ12q[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkm][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{27}|SMJ12qn[12345678][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{26}|SMJ12qn9[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghi][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{25}|SMJ12qn9j[123456789ABCDEFGHJKLM][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{24}|SMJ12qn9jN[123456789AB][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{23}|SMJ12qn9jNC[123456789AB][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{22}|SMJ12qn9jNCC[123456789ABCDEFGHJKLMNPQRSTUVW][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{21}|SMJ12qn9jNCCX[123456789ABCDEFGH][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{20}|SMJ12qn9jNCCXJ[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkm][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{19}|SMJ12qn9jNCCXJn[123456789ABCDEFGHJKLMNPQRS][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{18}|SMJ12qn9jNCCXJnT[123456789ABCDEFGHJKLMNPQRSTUVWX][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{17}|SMJ12qn9jNCCXJnTY[123456789ABCDEFGHJKLMNPQ][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{16}|SMJ12qn9jNCCXJnTYR[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxy][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{15}|SMJ12qn9jNCCXJnTYRz[1234][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{14}|SMJ12qn9jNCCXJnTYRz5[123456789ABCDEFGHJKLMNPQRSTUVWX][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{13}|SMJ12qn9jNCCXJnTYRz5Y[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrst][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{12}|SMJ12qn9jNCCXJnTYRz5Yu[12345678][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{11}|SMJ12qn9jNCCXJnTYRz5Yu9[123456789ABCDEFGHJKLMNPQRSTUVWXY][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{10}|SMJ12qn9jNCCXJnTYRz5Yu9Z[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcd][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{9}|SMJ12qn9jNCCXJnTYRz5Yu9Ze[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkm][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{8}|SMJ12qn9jNCCXJnTYRz5Yu9Zen[123456789ABCD][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{7}|SMJ12qn9jNCCXJnTYRz5Yu9ZenE[123456789ABCDEFGHJKLMNPQ][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{6}|SMJ12qn9jNCCXJnTYRz5Yu9ZenER[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkm][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{5}|SMJ12qn9jNCCXJnTYRz5Yu9ZenERn[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghij][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{4}|SMJ12qn9jNCCXJnTYRz5Yu9ZenERnk[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghij][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{3}|SMJ12qn9jNCCXJnTYRz5Yu9ZenERnkk[123456789ABCDEFGHJKLMNPQRST][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{2}|SMJ12qn9jNCCXJnTYRz5Yu9ZenERnkkU[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstu][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]|SMJ12qn9jNCCXJnTYRz5Yu9ZenERnkkUv[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghi])",
		deprecated: false
	},
	"crypto.STRAX.address": {
		deprecatedKeyName: "STRAX",
		validationRegex: "^X[a-km-zA-HJ-NP-Z1-9]{33}$",
		deprecated: false
	},
	"crypto.SIGNA.address": {
		deprecatedKeyName: "SIGNA",
		validationRegex: "^S-((?=[A-Z2-9]{4})(?:[^IO]{4})-){3}(?=[A-Z2-9]{5})(?:[^IO]{5})$",
		deprecated: false
	},
	"crypto.NIM.address": {
		deprecatedKeyName: "NIM",
		validationRegex: "^NQ[0-9]{2} ([A-Z0-9]{4} ){7}[A-Z0-9]{4}$",
		deprecated: false
	},
	"crypto.GUAP.address": {
		deprecatedKeyName: "GUAP",
		validationRegex: "^(G|P)[a-zA-HJ-NP-Z0-9]{25,39}$",
		deprecated: false
	},
	"crypto.ELA.version.ELA.address": {
		deprecatedKeyName: "ELA_ELA",
		validationRegex: "E[a-zA-HJ-NP-Z0-9]{33}",
		deprecated: false
	},
	"crypto.ELA.version.ESC.address": {
		deprecatedKeyName: "ELA_ESC",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.USDT.version.ERC20.address": {
		deprecatedKeyName: "USDT_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.USDT.version.TRON.address": {
		deprecatedKeyName: "USDT_TRON",
		validationRegex: "^[T][a-zA-HJ-NP-Z0-9]{33}$",
		deprecated: false
	},
	"crypto.USDT.version.EOS.address": {
		deprecatedKeyName: "USDT_EOS",
		validationRegex: "^[a-z][a-z1-5.]{10}[a-z1-5]$",
		deprecated: false
	},
	"crypto.USDT.version.OMNI.address": {
		deprecatedKeyName: "USDT_OMNI",
		validationRegex: "^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$",
		deprecated: false
	},
	"crypto.FTM.version.ERC20.address": {
		deprecatedKeyName: "FTM_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.FTM.version.BEP2.address": {
		deprecatedKeyName: "FTM_BEP2",
		validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
		deprecated: false
	},
	"crypto.FTM.version.OPERA.address": {
		deprecatedKeyName: "FTM_OPERA",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.FUSE.version.ERC20.address": {
		deprecatedKeyName: "FUSE_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.FUSE.version.FUSE.address": {
		deprecatedKeyName: "FUSE_FUSE",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MATIC.version.MATIC.address": {
		deprecatedKeyName: "MATIC_MATIC",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MATIC.version.BEP20.address": {
		deprecatedKeyName: "MATIC_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MATIC.version.ERC20.address": {
		deprecatedKeyName: "MATIC_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"social.payid.name": {
		deprecatedKeyName: "payid",
		validationRegex: "^[0-9a-zA-Z]+\\$[0-9a-zA-Z]+\\.[0-9a-zA-Z]+$",
		deprecated: false
	},
	"social.picture.value": {
		deprecatedKeyName: "picture",
		validationRegex: null,
		deprecated: false
	},
	"whois.email.value": {
		deprecatedKeyName: "email",
		validationRegex: "^[^@]+@[^\\.]+\\..+$",
		deprecated: false
	},
	"whois.for_sale.value": {
		deprecatedKeyName: "for_sale",
		validationRegex: "(true)|(false)",
		deprecated: false
	},
	"ipfs.html.value": {
		deprecatedKeyName: "html",
		validationRegex: ".{0,100}",
		deprecated: false
	},
	"ipfs.redirect_domain.value": {
		deprecatedKeyName: "redirect_domain",
		validationRegex: ".{0,253}",
		deprecated: false
	},
	"dweb.ipfs.hash": {
		deprecatedKeyName: "dweb_hash",
		validationRegex: ".{0,100}",
		deprecated: false
	},
	"browser.redirect_url": {
		deprecatedKeyName: "browser_redirect",
		validationRegex: ".{0,253}",
		deprecated: false
	},
	"browser.preferred_protocols": {
		deprecatedKeyName: "browser_preferred_protocols",
		validationRegex: null,
		deprecated: false
	},
	"gundb.username.value": {
		deprecatedKeyName: "gundb_username",
		validationRegex: null,
		deprecated: false
	},
	"gundb.public_key.value": {
		deprecatedKeyName: "gundb_public_key",
		validationRegex: null,
		deprecated: false
	},
	"social.image.value": {
		deprecatedKeyName: "image",
		validationRegex: null,
		deprecated: false
	},
	"social.twitter.username": {
		deprecatedKeyName: "twitter_username",
		validationRegex: null,
		deprecated: false
	},
	"validation.social.twitter.username": {
		deprecatedKeyName: "validation_twitter_username",
		validationRegex: null,
		deprecated: false
	},
	"forwarding.url": {
		deprecatedKeyName: "forwarding_url",
		validationRegex: "^(https?)://[^\\s/$.?#].[^\\s]*$",
		deprecated: false
	},
	"dns.ttl": {
		deprecatedKeyName: "dns_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.A": {
		deprecatedKeyName: "dns_A",
		validationRegex: null,
		deprecated: false
	},
	"dns.A.ttl": {
		deprecatedKeyName: "dns_A_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.AAAA": {
		deprecatedKeyName: "dns_AAAA",
		validationRegex: null,
		deprecated: false
	},
	"dns.AAAA.ttl": {
		deprecatedKeyName: "dns_AAAA_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.AFSDB": {
		deprecatedKeyName: "dns_AFSDB",
		validationRegex: null,
		deprecated: false
	},
	"dns.AFSDB.ttl": {
		deprecatedKeyName: "dns_AFSDB_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.APL": {
		deprecatedKeyName: "dns_APL",
		validationRegex: null,
		deprecated: false
	},
	"dns.APL.ttl": {
		deprecatedKeyName: "dns_APL_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.CAA": {
		deprecatedKeyName: "dns_CAA",
		validationRegex: null,
		deprecated: false
	},
	"dns.CAA.ttl": {
		deprecatedKeyName: "dns_CAA_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.CDNSKEY": {
		deprecatedKeyName: "dns_CDNSKEY",
		validationRegex: null,
		deprecated: false
	},
	"dns.CDNSKEY.ttl": {
		deprecatedKeyName: "dns_CDNSKEY_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.CDS": {
		deprecatedKeyName: "dns_CDS",
		validationRegex: null,
		deprecated: false
	},
	"dns.CDS.ttl": {
		deprecatedKeyName: "dns_CDS_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.CERT": {
		deprecatedKeyName: "dns_CERT",
		validationRegex: null,
		deprecated: false
	},
	"dns.CERT.ttl": {
		deprecatedKeyName: "dns_CERT_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.CNAME": {
		deprecatedKeyName: "dns_CNAME",
		validationRegex: null,
		deprecated: false
	},
	"dns.CNAME.ttl": {
		deprecatedKeyName: "dns_CNAME_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.CSYNC": {
		deprecatedKeyName: "dns_CSYNC",
		validationRegex: null,
		deprecated: false
	},
	"dns.CSYNC.ttl": {
		deprecatedKeyName: "dns_CSYNC_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.DHCID": {
		deprecatedKeyName: "dns_DHCID",
		validationRegex: null,
		deprecated: false
	},
	"dns.DHCID.ttl": {
		deprecatedKeyName: "dns_DHCID_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.DLV": {
		deprecatedKeyName: "dns_DLV",
		validationRegex: null,
		deprecated: false
	},
	"dns.DLV.ttl": {
		deprecatedKeyName: "dns_DLV_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.DNAME": {
		deprecatedKeyName: "dns_DNAME",
		validationRegex: null,
		deprecated: false
	},
	"dns.DNAME.ttl": {
		deprecatedKeyName: "dns_DNAME_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.DNSKEY": {
		deprecatedKeyName: "dns_DNSKEY",
		validationRegex: null,
		deprecated: false
	},
	"dns.DNSKEY.ttl": {
		deprecatedKeyName: "dns_DNSKEY_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.DS": {
		deprecatedKeyName: "dns_DS",
		validationRegex: null,
		deprecated: false
	},
	"dns.DS.ttl": {
		deprecatedKeyName: "dns_DS_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.EUI48": {
		deprecatedKeyName: "dns_EUI48",
		validationRegex: null,
		deprecated: false
	},
	"dns.EUI48.ttl": {
		deprecatedKeyName: "dns_EUI48_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.EUI64": {
		deprecatedKeyName: "dns_EUI64",
		validationRegex: null,
		deprecated: false
	},
	"dns.EUI64.ttl": {
		deprecatedKeyName: "dns_EUI64_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.HINFO": {
		deprecatedKeyName: "dns_HINFO",
		validationRegex: null,
		deprecated: false
	},
	"dns.HINFO.ttl": {
		deprecatedKeyName: "dns_HINFO_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.HIP": {
		deprecatedKeyName: "dns_HIP",
		validationRegex: null,
		deprecated: false
	},
	"dns.HIP.ttl": {
		deprecatedKeyName: "dns_HIP_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.HTTPS": {
		deprecatedKeyName: "dns_HTTPS",
		validationRegex: null,
		deprecated: false
	},
	"dns.HTTPS.ttl": {
		deprecatedKeyName: "dns_HTTPS_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.IPSECKEY": {
		deprecatedKeyName: "dns_IPSECKEY",
		validationRegex: null,
		deprecated: false
	},
	"dns.IPSECKEY.ttl": {
		deprecatedKeyName: "dns_IPSECKEY_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.KEY": {
		deprecatedKeyName: "dns_KEY",
		validationRegex: null,
		deprecated: false
	},
	"dns.KEY.ttl": {
		deprecatedKeyName: "dns_KEY_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.KX": {
		deprecatedKeyName: "dns_KX",
		validationRegex: null,
		deprecated: false
	},
	"dns.KX.ttl": {
		deprecatedKeyName: "dns_KX_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.LOC": {
		deprecatedKeyName: "dns_LOC",
		validationRegex: null,
		deprecated: false
	},
	"dns.LOC.ttl": {
		deprecatedKeyName: "dns_LOC_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.MX": {
		deprecatedKeyName: "dns_MX",
		validationRegex: null,
		deprecated: false
	},
	"dns.MX.ttl": {
		deprecatedKeyName: "dns_MX_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.NAPTR": {
		deprecatedKeyName: "dns_NAPTR",
		validationRegex: null,
		deprecated: false
	},
	"dns.NAPTR.ttl": {
		deprecatedKeyName: "dns_NAPTR_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.NS": {
		deprecatedKeyName: "dns_NS",
		validationRegex: null,
		deprecated: false
	},
	"dns.NS.ttl": {
		deprecatedKeyName: "dns_NS_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.NSEC": {
		deprecatedKeyName: "dns_NSEC",
		validationRegex: null,
		deprecated: false
	},
	"dns.NSEC.ttl": {
		deprecatedKeyName: "dns_NSEC_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.NSEC3": {
		deprecatedKeyName: "dns_NSEC3",
		validationRegex: null,
		deprecated: false
	},
	"dns.NSEC3.ttl": {
		deprecatedKeyName: "dns_NSEC3_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.NSEC3PARAM": {
		deprecatedKeyName: "dns_NSEC3PARAM",
		validationRegex: null,
		deprecated: false
	},
	"dns.NSEC3PARAM.ttl": {
		deprecatedKeyName: "dns_NSEC3PARAM_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.OPENPGPKEY": {
		deprecatedKeyName: "dns_OPENPGPKEY",
		validationRegex: null,
		deprecated: false
	},
	"dns.OPENPGPKEY.ttl": {
		deprecatedKeyName: "dns_OPENPGPKEY_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.PTR": {
		deprecatedKeyName: "dns_PTR",
		validationRegex: null,
		deprecated: false
	},
	"dns.PTR.ttl": {
		deprecatedKeyName: "dns_PTR_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.RP": {
		deprecatedKeyName: "dns_RP",
		validationRegex: null,
		deprecated: false
	},
	"dns.RP.ttl": {
		deprecatedKeyName: "dns_RP_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.RRSIG": {
		deprecatedKeyName: "dns_RRSIG",
		validationRegex: null,
		deprecated: false
	},
	"dns.RRSIG.ttl": {
		deprecatedKeyName: "dns_RRSIG_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.SIG": {
		deprecatedKeyName: "dns_SIG",
		validationRegex: null,
		deprecated: false
	},
	"dns.SIG.ttl": {
		deprecatedKeyName: "dns_SIG_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.SMIMEA": {
		deprecatedKeyName: "dns_SMIMEA",
		validationRegex: null,
		deprecated: false
	},
	"dns.SMIMEA.ttl": {
		deprecatedKeyName: "dns_SMIMEA_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.SOA": {
		deprecatedKeyName: "dns_SOA",
		validationRegex: null,
		deprecated: false
	},
	"dns.SOA.ttl": {
		deprecatedKeyName: "dns_SOA_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.SRV": {
		deprecatedKeyName: "dns_SRV",
		validationRegex: null,
		deprecated: false
	},
	"dns.SRV.ttl": {
		deprecatedKeyName: "dns_SRV_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.SSHFP": {
		deprecatedKeyName: "dns_SSHFP",
		validationRegex: null,
		deprecated: false
	},
	"dns.SSHFP.ttl": {
		deprecatedKeyName: "dns_SSHFP_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.SVCB": {
		deprecatedKeyName: "dns_SVCB",
		validationRegex: null,
		deprecated: false
	},
	"dns.SVCB.ttl": {
		deprecatedKeyName: "dns_SVCB_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.TA": {
		deprecatedKeyName: "dns_TA",
		validationRegex: null,
		deprecated: false
	},
	"dns.TA.ttl": {
		deprecatedKeyName: "dns_TA_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.TKEY": {
		deprecatedKeyName: "dns_TKEY",
		validationRegex: null,
		deprecated: false
	},
	"dns.TKEY.ttl": {
		deprecatedKeyName: "dns_TKEY_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.TLSA": {
		deprecatedKeyName: "dns_TLSA",
		validationRegex: null,
		deprecated: false
	},
	"dns.TLSA.ttl": {
		deprecatedKeyName: "dns_TLSA_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.TSIG": {
		deprecatedKeyName: "dns_TSIG",
		validationRegex: null,
		deprecated: false
	},
	"dns.TSIG.ttl": {
		deprecatedKeyName: "dns_TSIG_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.TXT": {
		deprecatedKeyName: "dns_TXT",
		validationRegex: null,
		deprecated: false
	},
	"dns.TXT.ttl": {
		deprecatedKeyName: "dns_TXT_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.URI": {
		deprecatedKeyName: "dns_URI",
		validationRegex: null,
		deprecated: false
	},
	"dns.URI.ttl": {
		deprecatedKeyName: "dns_URI_ttl",
		validationRegex: null,
		deprecated: false
	},
	"dns.ZONEMD": {
		deprecatedKeyName: "dns_ZONEMD",
		validationRegex: null,
		deprecated: false
	},
	"dns.ZONEMD.ttl": {
		deprecatedKeyName: "dns_ZONEMD_ttl",
		validationRegex: null,
		deprecated: false
	},
	"crypto.DOT.address": {
		deprecatedKeyName: "DOT",
		validationRegex: null,
		deprecated: false
	},
	"crypto.UNI.version.ERC20.address": {
		deprecatedKeyName: "UNI_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.UNI.version.BEP20.address": {
		deprecatedKeyName: "UNI_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.UNI.version.MATIC.address": {
		deprecatedKeyName: "UNI_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.UNI.version.HRC20.address": {
		deprecatedKeyName: "UNI_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.UNI.version.XDAI.address": {
		deprecatedKeyName: "UNI_XDAI",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SOL.address": {
		deprecatedKeyName: "SOL",
		validationRegex: null,
		deprecated: false
	},
	"crypto.BUSD.version.ERC20.address": {
		deprecatedKeyName: "BUSD_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.BUSD.version.BEP20.address": {
		deprecatedKeyName: "BUSD_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.BUSD.version.HRC20.address": {
		deprecatedKeyName: "BUSD_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ICP.address": {
		deprecatedKeyName: "ICP",
		validationRegex: null,
		deprecated: false
	},
	"crypto.THETA.address": {
		deprecatedKeyName: "THETA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.WBTC.version.ERC20.address": {
		deprecatedKeyName: "WBTC_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.WBTC.version.MATIC.address": {
		deprecatedKeyName: "WBTC_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.WBTC.version.FANTOM.address": {
		deprecatedKeyName: "WBTC_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.WBTC.version.HRC20.address": {
		deprecatedKeyName: "WBTC_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.WBTC.version.XDAI.address": {
		deprecatedKeyName: "WBTC_XDAI",
		validationRegex: null,
		deprecated: false
	},
	"crypto.FIL.address": {
		deprecatedKeyName: "FIL",
		validationRegex: null,
		deprecated: false
	},
	"crypto.CDAI.address": {
		deprecatedKeyName: "CDAI",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.KSM.address": {
		deprecatedKeyName: "KSM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.OKB.address": {
		deprecatedKeyName: "OKB",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.AAVE.version.ERC20.address": {
		deprecatedKeyName: "AAVE_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.AAVE.version.MATIC.address": {
		deprecatedKeyName: "AAVE_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.AAVE.version.FANTOM.address": {
		deprecatedKeyName: "AAVE_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.AAVE.version.HRC20.address": {
		deprecatedKeyName: "AAVE_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SHIB.version.ERC20.address": {
		deprecatedKeyName: "SHIB_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SHIB.version.MATIC.address": {
		deprecatedKeyName: "SHIB_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SHIB.version.FANTOM.address": {
		deprecatedKeyName: "SHIB_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.CEL.version.ERC20.address": {
		deprecatedKeyName: "CEL_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CEL.version.MATIC.address": {
		deprecatedKeyName: "CEL_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.CEL.version.FANTOM.address": {
		deprecatedKeyName: "CEL_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.CEL.version.HRC20.address": {
		deprecatedKeyName: "CEL_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CUSDC.address": {
		deprecatedKeyName: "CUSDC",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CETH.address": {
		deprecatedKeyName: "CETH",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.AMP.address": {
		deprecatedKeyName: "AMP",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CAKE.version.BEP20.address": {
		deprecatedKeyName: "CAKE_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CAKE.version.HRC20.address": {
		deprecatedKeyName: "CAKE_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MIOTA.address": {
		deprecatedKeyName: "MIOTA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.FTT.address": {
		deprecatedKeyName: "FTT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MKR.address": {
		deprecatedKeyName: "MKR",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.TFUEL.address": {
		deprecatedKeyName: "TFUEL",
		validationRegex: null,
		deprecated: false
	},
	"crypto.KLAY.address": {
		deprecatedKeyName: "KLAY",
		validationRegex: null,
		deprecated: false
	},
	"crypto.LUNA.address": {
		deprecatedKeyName: "LUNA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.AVAX.address": {
		deprecatedKeyName: "AVAX",
		validationRegex: null,
		deprecated: false
	},
	"crypto.LEO.address": {
		deprecatedKeyName: "LEO",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SAFEMOON.version.BEP20.address": {
		deprecatedKeyName: "SAFEMOON_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SAFEMOON.version.HRC20.address": {
		deprecatedKeyName: "SAFEMOON_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.UST.address": {
		deprecatedKeyName: "UST",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.RUNE.address": {
		deprecatedKeyName: "RUNE",
		validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
		deprecated: false
	},
	"crypto.HBAR.address": {
		deprecatedKeyName: "HBAR",
		validationRegex: null,
		deprecated: false
	},
	"crypto.TEL.version.ERC20.address": {
		deprecatedKeyName: "TEL_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.TEL.version.MATIC.address": {
		deprecatedKeyName: "TEL_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.CHZ.address": {
		deprecatedKeyName: "CHZ",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SUSHI.version.ERC20.address": {
		deprecatedKeyName: "SUSHI_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SUSHI.version.BEP20.address": {
		deprecatedKeyName: "SUSHI_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SUSHI.version.MATIC.address": {
		deprecatedKeyName: "SUSHI_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SUSHI.version.FANTOM.address": {
		deprecatedKeyName: "SUSHI_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SUSHI.version.HRC20.address": {
		deprecatedKeyName: "SUSHI_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.EGLD.address": {
		deprecatedKeyName: "EGLD",
		validationRegex: null,
		deprecated: false
	},
	"crypto.TUSD.version.ERC20.address": {
		deprecatedKeyName: "TUSD_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.TUSD.version.BEP20.address": {
		deprecatedKeyName: "TUSD_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.TUSD.version.AVAX.address": {
		deprecatedKeyName: "TUSD_AVAX",
		validationRegex: null,
		deprecated: false
	},
	"crypto.TUSD.version.HRC20.address": {
		deprecatedKeyName: "TUSD_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.TUSD.version.BEP2.address": {
		deprecatedKeyName: "TUSD_BEP2",
		validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
		deprecated: false
	},
	"crypto.TUSD.version.TRON.address": {
		deprecatedKeyName: "TUSD_TRON",
		validationRegex: "^[T][a-zA-HJ-NP-Z0-9]{33}$",
		deprecated: false
	},
	"crypto.HBTC.version.ERC20.address": {
		deprecatedKeyName: "HBTC_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.HBTC.version.HRC20.address": {
		deprecatedKeyName: "HBTC_HRC20",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SNX.version.ERC20.address": {
		deprecatedKeyName: "SNX_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SNX.version.MATIC.address": {
		deprecatedKeyName: "SNX_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SNX.version.FANTOM.address": {
		deprecatedKeyName: "SNX_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SNX.version.HRC20.address": {
		deprecatedKeyName: "SNX_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.HOT.version.ERC20.address": {
		deprecatedKeyName: "HOT_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.HOT.version.HRC20.address": {
		deprecatedKeyName: "HOT_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.NEAR.address": {
		deprecatedKeyName: "NEAR",
		validationRegex: null,
		deprecated: false
	},
	"crypto.HNT.address": {
		deprecatedKeyName: "HNT",
		validationRegex: null,
		deprecated: false
	},
	"crypto.STETH.address": {
		deprecatedKeyName: "STETH",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.NEXO.version.ERC20.address": {
		deprecatedKeyName: "NEXO_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.NEXO.version.FANTOM.address": {
		deprecatedKeyName: "NEXO_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.PAX.address": {
		deprecatedKeyName: "PAX",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.STX.address": {
		deprecatedKeyName: "STX",
		validationRegex: null,
		deprecated: false
	},
	"crypto.MANA.version.ERC20.address": {
		deprecatedKeyName: "MANA_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MANA.version.MATIC.address": {
		deprecatedKeyName: "MANA_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.MDX.version.HRC20.address": {
		deprecatedKeyName: "MDX_HRC20",
		validationRegex: null,
		deprecated: false
	},
	"crypto.MDX.version.BEP20.address": {
		deprecatedKeyName: "MDX_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ZEN.address": {
		deprecatedKeyName: "ZEN",
		validationRegex: null,
		deprecated: false
	},
	"crypto.ARRR.address": {
		deprecatedKeyName: "ARRR",
		validationRegex: null,
		deprecated: false
	},
	"crypto.BNT.address": {
		deprecatedKeyName: "BNT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.LUSD.version.ERC20.address": {
		deprecatedKeyName: "LUSD_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.LUSD.version.MATIC.address": {
		deprecatedKeyName: "LUSD_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.GRT.version.ERC20.address": {
		deprecatedKeyName: "GRT_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.GRT.version.MATIC.address": {
		deprecatedKeyName: "GRT_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.GRT.version.HRC20.address": {
		deprecatedKeyName: "GRT_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SC.address": {
		deprecatedKeyName: "SC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.HUSD.version.ERC20.address": {
		deprecatedKeyName: "HUSD_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.HUSD.version.HRC20.address": {
		deprecatedKeyName: "HUSD_HRC20",
		validationRegex: null,
		deprecated: false
	},
	"crypto.CRV.version.ERC20.address": {
		deprecatedKeyName: "CRV_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CRV.version.MATIC.address": {
		deprecatedKeyName: "CRV_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.CRV.version.FANTOM.address": {
		deprecatedKeyName: "CRV_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.UMA.address": {
		deprecatedKeyName: "UMA",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.WRX.version.BEP2.address": {
		deprecatedKeyName: "WRX_BEP2",
		validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
		deprecated: false
	},
	"crypto.WRX.version.MATIC.address": {
		deprecatedKeyName: "WRX_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.AR.address": {
		deprecatedKeyName: "AR",
		validationRegex: null,
		deprecated: false
	},
	"crypto.OMG.address": {
		deprecatedKeyName: "OMG",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.GT.address": {
		deprecatedKeyName: "GT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.QNT.address": {
		deprecatedKeyName: "QNT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CHSB.address": {
		deprecatedKeyName: "CHSB",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.IOST.address": {
		deprecatedKeyName: "IOST",
		validationRegex: null,
		deprecated: false
	},
	"crypto.NXM.address": {
		deprecatedKeyName: "NXM",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.KCS.address": {
		deprecatedKeyName: "KCS",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.LPT.version.ERC20.address": {
		deprecatedKeyName: "LPT_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.LPT.version.HRC20.address": {
		deprecatedKeyName: "LPT_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.XSUSHI.address": {
		deprecatedKeyName: "XSUSHI",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CUSDT.address": {
		deprecatedKeyName: "CUSDT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.FLOW.address": {
		deprecatedKeyName: "FLOW",
		validationRegex: null,
		deprecated: false
	},
	"crypto.ANKR.address": {
		deprecatedKeyName: "ANKR",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.HBC.address": {
		deprecatedKeyName: "HBC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.VGX.address": {
		deprecatedKeyName: "VGX",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.FEI.address": {
		deprecatedKeyName: "FEI",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.BAKE.version.BEP20.address": {
		deprecatedKeyName: "BAKE_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.BAKE.version.HRC20.address": {
		deprecatedKeyName: "BAKE_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.1INCH.version.ERC20.address": {
		deprecatedKeyName: "1INCH_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.1INCH.version.BEP20.address": {
		deprecatedKeyName: "1INCH_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.1INCH.version.MATIC.address": {
		deprecatedKeyName: "1INCH_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.1INCH.version.HRC20.address": {
		deprecatedKeyName: "1INCH_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CKB.address": {
		deprecatedKeyName: "CKB",
		validationRegex: null,
		deprecated: false
	},
	"crypto.WOO.version.ERC20.address": {
		deprecatedKeyName: "WOO_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.WOO.version.HRC20.address": {
		deprecatedKeyName: "WOO_HRC20",
		validationRegex: null,
		deprecated: false
	},
	"crypto.TITAN.address": {
		deprecatedKeyName: "TITAN",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.OMI.address": {
		deprecatedKeyName: "OMI",
		validationRegex: null,
		deprecated: false
	},
	"crypto.MINA.address": {
		deprecatedKeyName: "MINA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SETH.address": {
		deprecatedKeyName: "SETH",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.RSR.address": {
		deprecatedKeyName: "RSR",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.OXY.version.SOLANA.address": {
		deprecatedKeyName: "OXY_SOLANA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.OXY.version.ERC20.address": {
		deprecatedKeyName: "OXY_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.REN.version.ERC20.address": {
		deprecatedKeyName: "REN_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.REN.version.HRC20.address": {
		deprecatedKeyName: "REN_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.XCH.address": {
		deprecatedKeyName: "XCH",
		validationRegex: null,
		deprecated: false
	},
	"crypto.RENBTC.version.ERC20.address": {
		deprecatedKeyName: "RENBTC_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.RENBTC.version.BEP20.address": {
		deprecatedKeyName: "RENBTC_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.RENBTC.version.HRC20.address": {
		deprecatedKeyName: "RENBTC_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.USDN.address": {
		deprecatedKeyName: "USDN",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.BCHA.address": {
		deprecatedKeyName: "BCHA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.LRC.address": {
		deprecatedKeyName: "LRC",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.PUNDIX.address": {
		deprecatedKeyName: "PUNDIX",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ERG.address": {
		deprecatedKeyName: "ERG",
		validationRegex: null,
		deprecated: false
	},
	"crypto.WIN.address": {
		deprecatedKeyName: "WIN",
		validationRegex: "^[T][a-zA-HJ-NP-Z0-9]{33}$",
		deprecated: false
	},
	"crypto.NPXS.address": {
		deprecatedKeyName: "NPXS",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.TRIBE.address": {
		deprecatedKeyName: "TRIBE",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MAID.address": {
		deprecatedKeyName: "MAID",
		validationRegex: "^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$",
		deprecated: false
	},
	"crypto.ASD.address": {
		deprecatedKeyName: "ASD",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CUNI.address": {
		deprecatedKeyName: "CUNI",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CELO.address": {
		deprecatedKeyName: "CELO",
		validationRegex: null,
		deprecated: false
	},
	"crypto.DENT.address": {
		deprecatedKeyName: "DENT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SNT.address": {
		deprecatedKeyName: "SNT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.FEG.version.ERC20.address": {
		deprecatedKeyName: "FEG_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.FEG.version.HRC20.address": {
		deprecatedKeyName: "FEG_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SKL.address": {
		deprecatedKeyName: "SKL",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ALUSD.address": {
		deprecatedKeyName: "ALUSD",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MIR.version.ERC20.address": {
		deprecatedKeyName: "MIR_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MIR.version.BEP20.address": {
		deprecatedKeyName: "MIR_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.GLM.address": {
		deprecatedKeyName: "GLM",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.PAXG.version.ERC20.address": {
		deprecatedKeyName: "PAXG_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.PAXG.version.HRC20.address": {
		deprecatedKeyName: "PAXG_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CFX.address": {
		deprecatedKeyName: "CFX",
		validationRegex: null,
		deprecated: false
	},
	"crypto.UOS.address": {
		deprecatedKeyName: "UOS",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SVCS.address": {
		deprecatedKeyName: "SVCS",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.REEF.version.ERC20.address": {
		deprecatedKeyName: "REEF_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.REEF.version.BEP20.address": {
		deprecatedKeyName: "REEF_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.REEF.version.HRC20.address": {
		deprecatedKeyName: "REEF_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.GNO.address": {
		deprecatedKeyName: "GNO",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.USDP.address": {
		deprecatedKeyName: "USDP",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.KAVA.address": {
		deprecatedKeyName: "KAVA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.ALCX.address": {
		deprecatedKeyName: "ALCX",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.EWT.address": {
		deprecatedKeyName: "EWT",
		validationRegex: null,
		deprecated: false
	},
	"crypto.TON.address": {
		deprecatedKeyName: "TON",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.RLC.address": {
		deprecatedKeyName: "RLC",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.AXS.address": {
		deprecatedKeyName: "AXS",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.AUDIO.address": {
		deprecatedKeyName: "AUDIO",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.XVS.address": {
		deprecatedKeyName: "XVS",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.BAND.version.ERC20.address": {
		deprecatedKeyName: "BAND_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.BAND.version.FANTOM.address": {
		deprecatedKeyName: "BAND_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.NMR.address": {
		deprecatedKeyName: "NMR",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.INJ.version.ERC20.address": {
		deprecatedKeyName: "INJ_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.INJ.version.BEP20.address": {
		deprecatedKeyName: "INJ_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.WAXP.address": {
		deprecatedKeyName: "WAXP",
		validationRegex: null,
		deprecated: false
	},
	"crypto.UQC.address": {
		deprecatedKeyName: "UQC",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.IOTX.address": {
		deprecatedKeyName: "IOTX",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.FUN.address": {
		deprecatedKeyName: "FUN",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.OCEAN.address": {
		deprecatedKeyName: "OCEAN",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SAND.version.ERC20.address": {
		deprecatedKeyName: "SAND_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SAND.version.HRC20.address": {
		deprecatedKeyName: "SAND_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CTSI.version.ERC20.address": {
		deprecatedKeyName: "CTSI_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CTSI.version.BEP20.address": {
		deprecatedKeyName: "CTSI_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CTSI.version.MATIC.address": {
		deprecatedKeyName: "CTSI_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.RAY.address": {
		deprecatedKeyName: "RAY",
		validationRegex: null,
		deprecated: false
	},
	"crypto.ANC.version.TERRA.address": {
		deprecatedKeyName: "ANC_TERRA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.ANC.version.ERC20.address": {
		deprecatedKeyName: "ANC_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.IQ.version.ERC20.address": {
		deprecatedKeyName: "IQ_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.IQ.version.BEP20.address": {
		deprecatedKeyName: "IQ_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.IQ.version.MATIC.address": {
		deprecatedKeyName: "IQ_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SUSD.version.ERC20.address": {
		deprecatedKeyName: "SUSD_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SUSD.version.FANTOM.address": {
		deprecatedKeyName: "SUSD_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.KLV.address": {
		deprecatedKeyName: "KLV",
		validationRegex: "^[T][a-zA-HJ-NP-Z0-9]{33}$",
		deprecated: false
	},
	"crypto.BTCST.address": {
		deprecatedKeyName: "BTCST",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.TLM.address": {
		deprecatedKeyName: "TLM",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.AKT.address": {
		deprecatedKeyName: "AKT",
		validationRegex: null,
		deprecated: false
	},
	"crypto.STMX.address": {
		deprecatedKeyName: "STMX",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.PROM.address": {
		deprecatedKeyName: "PROM",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.XPRT.address": {
		deprecatedKeyName: "XPRT",
		validationRegex: null,
		deprecated: false
	},
	"crypto.SRM.version.ERC20.address": {
		deprecatedKeyName: "SRM_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SRM.version.SOLANA.address": {
		deprecatedKeyName: "SRM_SOLANA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.RPL.address": {
		deprecatedKeyName: "RPL",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.AGIX.address": {
		deprecatedKeyName: "AGIX",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CELR.address": {
		deprecatedKeyName: "CELR",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.FET.address": {
		deprecatedKeyName: "FET",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.OXT.address": {
		deprecatedKeyName: "OXT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ARDR.address": {
		deprecatedKeyName: "ARDR",
		validationRegex: null,
		deprecated: false
	},
	"crypto.MATH.address": {
		deprecatedKeyName: "MATH",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.10SET.address": {
		deprecatedKeyName: "10SET",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.POLY.address": {
		deprecatedKeyName: "POLY",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.GUSD.address": {
		deprecatedKeyName: "GUSD",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.NKN.address": {
		deprecatedKeyName: "NKN",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CVC.address": {
		deprecatedKeyName: "CVC",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.GTC.address": {
		deprecatedKeyName: "GTC",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.STEEM.address": {
		deprecatedKeyName: "STEEM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.ORN.address": {
		deprecatedKeyName: "ORN",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.KEEP.version.ERC20.address": {
		deprecatedKeyName: "KEEP_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.KEEP.version.HRC20.address": {
		deprecatedKeyName: "KEEP_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.HXRO.address": {
		deprecatedKeyName: "HXRO",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ORBS.address": {
		deprecatedKeyName: "ORBS",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ALPHA.version.ERC20.address": {
		deprecatedKeyName: "ALPHA_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ALPHA.version.BEP20.address": {
		deprecatedKeyName: "ALPHA_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.DODO.version.ERC20.address": {
		deprecatedKeyName: "DODO_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.DODO.version.BEP20.address": {
		deprecatedKeyName: "DODO_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.OGN.address": {
		deprecatedKeyName: "OGN",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.KNCL.version.ERC20.address": {
		deprecatedKeyName: "KNCL_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.KNCL.version.FANTOM.address": {
		deprecatedKeyName: "KNCL_FANTOM",
		validationRegex: null,
		deprecated: false
	},
	"crypto.KNCL.version.HRC20.address": {
		deprecatedKeyName: "KNCL_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MED.address": {
		deprecatedKeyName: "MED",
		validationRegex: null,
		deprecated: false
	},
	"crypto.XAUT.address": {
		deprecatedKeyName: "XAUT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.VLX.address": {
		deprecatedKeyName: "VLX",
		validationRegex: null,
		deprecated: false
	},
	"crypto.PHA.address": {
		deprecatedKeyName: "PHA",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.KOBE.address": {
		deprecatedKeyName: "KOBE",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.PERP.address": {
		deprecatedKeyName: "PERP",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.XHV.address": {
		deprecatedKeyName: "XHV",
		validationRegex: null,
		deprecated: false
	},
	"crypto.META.address": {
		deprecatedKeyName: "META",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SEUR.address": {
		deprecatedKeyName: "SEUR",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.MONA.address": {
		deprecatedKeyName: "MONA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.ANT.address": {
		deprecatedKeyName: "ANT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.HYDRA.address": {
		deprecatedKeyName: "HYDRA",
		validationRegex: null,
		deprecated: false
	},
	"crypto.ZKS.address": {
		deprecatedKeyName: "ZKS",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SXP.version.ERC20.address": {
		deprecatedKeyName: "SXP_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SXP.version.BEP20.address": {
		deprecatedKeyName: "SXP_BEP20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.SXP.version.HRC20.address": {
		deprecatedKeyName: "SXP_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.CSPR.address": {
		deprecatedKeyName: "CSPR",
		validationRegex: null,
		deprecated: false
	},
	"crypto.MTL.address": {
		deprecatedKeyName: "MTL",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.NU.address": {
		deprecatedKeyName: "NU",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ZMT.address": {
		deprecatedKeyName: "ZMT",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.LOC.address": {
		deprecatedKeyName: "LOC",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.TKO.address": {
		deprecatedKeyName: "TKO",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.ETN.address": {
		deprecatedKeyName: "ETN",
		validationRegex: null,
		deprecated: false
	},
	"crypto.UBT.version.ERC20.address": {
		deprecatedKeyName: "UBT_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.UBT.version.MATIC.address": {
		deprecatedKeyName: "UBT_MATIC",
		validationRegex: null,
		deprecated: false
	},
	"crypto.EXRD.address": {
		deprecatedKeyName: "EXRD",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.NMX.address": {
		deprecatedKeyName: "NMX",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.RIF.address": {
		deprecatedKeyName: "RIF",
		validationRegex: null,
		deprecated: false
	},
	"crypto.STORJ.version.ERC20.address": {
		deprecatedKeyName: "STORJ_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.STORJ.version.HRC20.address": {
		deprecatedKeyName: "STORJ_HRC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.AVA.address": {
		deprecatedKeyName: "AVA",
		validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
		deprecated: false
	},
	"crypto.DPI.version.ERC20.address": {
		deprecatedKeyName: "DPI_ERC20",
		validationRegex: "^0x[a-fA-F0-9]{40}$",
		deprecated: false
	},
	"crypto.DPI.version.MATIC.address": {
		deprecatedKeyName: "DPI_MATIC",
		validationRegex: null,
		deprecated: false
	}
};
var require$$11 = {
	version: version,
	information: information,
	keys: keys
};

var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding$4 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$4 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$4 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$4(result, mod, k);
    __setModuleDefault$4(result, mod);
    return result;
};
var __awaiter$3 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$3 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __asyncValues = (commonjsGlobal && commonjsGlobal.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __spreadArray$1 = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(Uns$1, "__esModule", { value: true });
var types_1 = types;
var resolutionError_1$4 = __importStar$4(resolutionError);
var utils_1$2 = utils$n;
var publicTypes_1$3 = publicTypes;
var TwitterSignatureValidator_1$1 = TwitterSignatureValidator;
var FetchProvider_1 = __importDefault$2(FetchProvider$1);
var namehash_1$2 = namehash;
var NamingService_1$1 = NamingService$1;
var configurationError_1$1 = __importStar$4(configurationError);
var UnsInternal_1 = __importDefault$2(UnsInternal$1);
var Networking_1$2 = __importDefault$2(Networking$1);
var resolver_keys_json_1 = __importDefault$2(require$$11);
/**
 * @internal
 */
var Uns = /** @class */ (function (_super) {
    __extends$1(Uns, _super);
    function Uns(source) {
        var _this = _super.call(this) || this;
        _this.name = publicTypes_1$3.NamingServiceName.UNS;
        if (source &&
            source.locations &&
            (!source.locations.Layer1 || !source.locations.Layer2)) {
            throw new configurationError_1$1.default(configurationError_1$1.ConfigurationErrorCode.NetworkConfigMissing, {
                method: publicTypes_1$3.NamingServiceName.UNS,
                config: !source.locations.Layer1 ? 'Layer1' : 'Layer2',
            });
        }
        if (!source) {
            source = {
                locations: {
                    Layer1: {
                        url: UnsInternal_1.default.UrlMap['mainnet'],
                        network: 'mainnet',
                    },
                    Layer2: {
                        url: UnsInternal_1.default.UrlMap['polygon-mainnet'],
                        network: 'polygon-mainnet',
                    },
                },
            };
        }
        _this.unsl1 = new UnsInternal_1.default(publicTypes_1$3.UnsLocation.Layer1, source.locations.Layer1, publicTypes_1$3.BlockchainType.ETH);
        _this.unsl2 = new UnsInternal_1.default(publicTypes_1$3.UnsLocation.Layer2, source.locations.Layer2, publicTypes_1$3.BlockchainType.MATIC);
        return _this;
    }
    Uns.autoNetwork = function (config) {
        return __awaiter$3(this, void 0, void 0, function () {
            var providerLayer1, providerLayer2, networkIdLayer1, networkIdLayer2, networkNameLayer1, networkNameLayer2;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if ((0, types_1.hasProvider)(config.locations.Layer1) &&
                            (0, types_1.hasProvider)(config.locations.Layer2)) {
                            providerLayer1 = config.locations.Layer1.provider;
                            providerLayer2 = config.locations.Layer2.provider;
                        }
                        else {
                            if (!config.locations.Layer1['url'] || !config.locations.Layer2['url']) {
                                throw new configurationError_1$1.default(configurationError_1$1.ConfigurationErrorCode.UnspecifiedUrl, {
                                    method: publicTypes_1$3.NamingServiceName.UNS,
                                });
                            }
                            providerLayer1 = FetchProvider_1.default.factory(publicTypes_1$3.NamingServiceName.UNS, config.locations.Layer1['url']);
                            providerLayer2 = FetchProvider_1.default.factory(publicTypes_1$3.NamingServiceName.UNS, config.locations.Layer2['url']);
                        }
                        return [4 /*yield*/, providerLayer1.request({
                                method: 'net_version',
                            })];
                    case 1:
                        networkIdLayer1 = (_a.sent());
                        return [4 /*yield*/, providerLayer2.request({
                                method: 'net_version',
                            })];
                    case 2:
                        networkIdLayer2 = (_a.sent());
                        networkNameLayer1 = utils_1$2.EthereumNetworksInverted[networkIdLayer1];
                        networkNameLayer2 = utils_1$2.EthereumNetworksInverted[networkIdLayer2];
                        if (!networkNameLayer1 ||
                            !types_1.UnsSupportedNetwork.guard(networkNameLayer1) ||
                            !networkNameLayer2 ||
                            !types_1.UnsSupportedNetwork.guard(networkNameLayer2)) {
                            throw new configurationError_1$1.default(configurationError_1$1.ConfigurationErrorCode.UnsupportedNetwork, {
                                method: publicTypes_1$3.NamingServiceName.UNS,
                            });
                        }
                        return [2 /*return*/, new this({
                                locations: {
                                    Layer1: { network: networkNameLayer1, provider: providerLayer1 },
                                    Layer2: { network: networkNameLayer2, provider: providerLayer2 },
                                },
                            })];
                }
            });
        });
    };
    Uns.prototype.namehash = function (domain) {
        if (!this.checkDomain(domain)) {
            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.UnsupportedDomain, {
                domain: domain,
            });
        }
        return (0, namehash_1$2.eip137Namehash)(domain);
    };
    Uns.prototype.childhash = function (parentHash, label) {
        return (0, namehash_1$2.eip137Childhash)(parentHash, label);
    };
    Uns.prototype.isSupportedDomain = function (domain) {
        return __awaiter$3(this, void 0, void 0, function () {
            var tld, _a, existsL1, existsL2;
            return __generator$3(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.checkDomain(domain)) {
                            return [2 /*return*/, false];
                        }
                        tld = domain.split('.').pop();
                        if (!tld) {
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, Promise.all([
                                this.unsl1.exists(tld),
                                this.unsl2.exists(tld),
                            ])];
                    case 1:
                        _a = _b.sent(), existsL1 = _a[0], existsL2 = _a[1];
                        return [2 /*return*/, existsL1 || existsL2];
                }
            });
        });
    };
    Uns.prototype.owner = function (domain) {
        return __awaiter$3(this, void 0, void 0, function () {
            var tokenId, data;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenId = this.namehash(domain);
                        return [4 /*yield*/, this.get(tokenId, [])];
                    case 1:
                        data = _a.sent();
                        if ((0, utils_1$2.isNullAddress)(data.owner)) {
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.UnregisteredDomain, {
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, data.owner];
                }
            });
        });
    };
    Uns.prototype.resolver = function (domain) {
        return __awaiter$3(this, void 0, void 0, function () {
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getVerifiedData(domain)];
                    case 1: return [2 /*return*/, (_a.sent()).resolver];
                }
            });
        });
    };
    Uns.prototype.record = function (domain, key) {
        return __awaiter$3(this, void 0, void 0, function () {
            var returnee;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.records(domain, [key])];
                    case 1:
                        returnee = (_a.sent())[key];
                        if (!returnee) {
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.RecordNotFound, {
                                recordName: key,
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, returnee];
                }
            });
        });
    };
    Uns.prototype.records = function (domain, keys) {
        return __awaiter$3(this, void 0, void 0, function () {
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getVerifiedData(domain, keys)];
                    case 1: return [2 /*return*/, (_a.sent()).records];
                }
            });
        });
    };
    Uns.prototype.allRecords = function (domain) {
        return __awaiter$3(this, void 0, void 0, function () {
            var tokenId, metadata;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenId = this.namehash(domain);
                        return [4 /*yield*/, this.getMetadata(tokenId)];
                    case 1:
                        metadata = _a.sent();
                        return [2 /*return*/, this.records(domain, __spreadArray$1(__spreadArray$1([], Object.keys(resolver_keys_json_1.default.keys), true), Object.keys(metadata.properties.records), true))];
                }
            });
        });
    };
    Uns.prototype.twitter = function (domain) {
        return __awaiter$3(this, void 0, void 0, function () {
            var tokenId, keys, data, records, location, validationSignature, twitterHandle, owner;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenId = this.namehash(domain);
                        keys = [
                            'validation.social.twitter.username',
                            'social.twitter.username',
                        ];
                        return [4 /*yield*/, this.getVerifiedData(domain, keys)];
                    case 1:
                        data = _a.sent();
                        records = data.records, location = data.location;
                        validationSignature = records['validation.social.twitter.username'];
                        twitterHandle = records['social.twitter.username'];
                        if ((0, utils_1$2.isNullAddress)(validationSignature)) {
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.RecordNotFound, {
                                domain: domain,
                                location: location,
                                recordName: 'validation.social.twitter.username',
                            });
                        }
                        if (!twitterHandle) {
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.RecordNotFound, {
                                domain: domain,
                                location: location,
                                recordName: 'social.twitter.username',
                            });
                        }
                        owner = data.owner;
                        if (!(0, TwitterSignatureValidator_1$1.isValidTwitterSignature)({
                            tokenId: tokenId,
                            owner: owner,
                            twitterHandle: twitterHandle,
                            validationSignature: validationSignature,
                        })) {
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.InvalidTwitterVerification, {
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, twitterHandle];
                }
            });
        });
    };
    Uns.prototype.reverse = function (address, currencyTicker) {
        return __awaiter$3(this, void 0, void 0, function () {
            return __generator$3(this, function (_a) {
                throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'reverse',
                });
            });
        });
    };
    Uns.prototype.isRegistered = function (domain) {
        return __awaiter$3(this, void 0, void 0, function () {
            var tokenId, data;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenId = this.namehash(domain);
                        return [4 /*yield*/, this.get(tokenId, [])];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, !(0, utils_1$2.isNullAddress)(data.owner)];
                }
            });
        });
    };
    Uns.prototype.getTokenUri = function (tokenId) {
        var e_1, _a;
        return __awaiter$3(this, void 0, void 0, function () {
            var _b, _c, result, tokenUri, e_1_1;
            var _this = this;
            return __generator$3(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 5, 6, 11]);
                        _b = __asyncValues([
                            (0, utils_1$2.wrapResult)(function () { return _this.unsl2.getTokenUri(tokenId); }),
                            (0, utils_1$2.wrapResult)(function () { return _this.unsl1.getTokenUri(tokenId); }),
                        ]);
                        _d.label = 1;
                    case 1: return [4 /*yield*/, _b.next()];
                    case 2:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 4];
                        result = _c.value;
                        tokenUri = (0, utils_1$2.unwrapResult)(result);
                        if (tokenUri) {
                            return [2 /*return*/, tokenUri];
                        }
                        _d.label = 3;
                    case 3: return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 11];
                    case 5:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 11];
                    case 6:
                        _d.trys.push([6, , 9, 10]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 8];
                        return [4 /*yield*/, _a.call(_b)];
                    case 7:
                        _d.sent();
                        _d.label = 8;
                    case 8: return [3 /*break*/, 10];
                    case 9:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 10: return [7 /*endfinally*/];
                    case 11: 
                    // Note: if a token doesn't exist, ProxyReader returns an empty string. If both responses are empty,
                    // we know for sure that the domain isn't registered.
                    throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.UnregisteredDomain, {
                        domain: "with tokenId ".concat(tokenId),
                    });
                }
            });
        });
    };
    Uns.prototype.isAvailable = function (domain) {
        return __awaiter$3(this, void 0, void 0, function () {
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isRegistered(domain)];
                    case 1: return [2 /*return*/, !(_a.sent())];
                }
            });
        });
    };
    Uns.prototype.registryAddress = function (domainOrNamehash) {
        return __awaiter$3(this, void 0, void 0, function () {
            var _a, resultOrErrorL1, resultOrErrorL2;
            return __generator$3(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.unsl1.registryAddress(domainOrNamehash).catch(function (err) { return err; }),
                            this.unsl2.registryAddress(domainOrNamehash).catch(function (err) { return err; }),
                        ])];
                    case 1:
                        _a = _b.sent(), resultOrErrorL1 = _a[0], resultOrErrorL2 = _a[1];
                        if (resultOrErrorL2 instanceof Error) {
                            validResolutionErrorOrThrow(resultOrErrorL2, resolutionError_1$4.ResolutionErrorCode.UnregisteredDomain);
                        }
                        else if (!(0, utils_1$2.isNullAddress)(resultOrErrorL2)) {
                            return [2 /*return*/, resultOrErrorL2];
                        }
                        return [2 /*return*/, validResultOrThrow(resultOrErrorL1)];
                }
            });
        });
    };
    Uns.prototype.locations = function (domains) {
        return __awaiter$3(this, void 0, void 0, function () {
            var _a, resultL1, resultL2, nonEmptyRecordsFromL2;
            return __generator$3(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.unsl1.locations(domains),
                            this.unsl2.locations(domains),
                        ])];
                    case 1:
                        _a = _b.sent(), resultL1 = _a[0], resultL2 = _a[1];
                        nonEmptyRecordsFromL2 = Object.keys(resultL2)
                            .filter(function (k) { return resultL2[k] != null; })
                            .reduce(function (a, k) {
                            var _a;
                            return (__assign(__assign({}, a), (_a = {}, _a[k] = resultL2[k], _a)));
                        }, {});
                        return [2 /*return*/, __assign(__assign({}, resultL1), nonEmptyRecordsFromL2)];
                }
            });
        });
    };
    Uns.prototype.reverseOf = function (addr, location) {
        return __awaiter$3(this, void 0, void 0, function () {
            var _a, resultOrErrorL1, resultOrErrorL2, reverseL1, reverseL2, reversedL1, reversedL2;
            return __generator$3(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.unsl1.reverseOf(addr).catch(function (err) { return err; }),
                            this.unsl2.reverseOf(addr).catch(function (err) { return err; }),
                        ])];
                    case 1:
                        _a = _b.sent(), resultOrErrorL1 = _a[0], resultOrErrorL2 = _a[1];
                        reverseL1 = function () {
                            validResultOrThrow(resultOrErrorL1);
                            if (resultOrErrorL1._hex !== '0x00') {
                                return (0, namehash_1$2.fromHexStringToDecimals)(resultOrErrorL1._hex);
                            }
                            else {
                                return null;
                            }
                        };
                        reverseL2 = function () {
                            validResultOrThrow(resultOrErrorL2);
                            if (resultOrErrorL2._hex !== '0x00') {
                                return (0, namehash_1$2.fromHexStringToDecimals)(resultOrErrorL2._hex);
                            }
                            else {
                                return null;
                            }
                        };
                        if (location === publicTypes_1$3.UnsLocation.Layer1) {
                            return [2 /*return*/, reverseL1()];
                        }
                        if (location === publicTypes_1$3.UnsLocation.Layer2) {
                            return [2 /*return*/, reverseL2()];
                        }
                        reversedL1 = reverseL1();
                        if (reversedL1) {
                            return [2 /*return*/, reversedL1];
                        }
                        reversedL2 = reverseL2();
                        if (reversedL2) {
                            return [2 /*return*/, reversedL2];
                        }
                        return [2 /*return*/, null];
                }
            });
        });
    };
    Uns.prototype.getDomainFromTokenId = function (tokenId) {
        return __awaiter$3(this, void 0, void 0, function () {
            var metadata;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getMetadata(tokenId)];
                    case 1:
                        metadata = _a.sent();
                        if (this.namehash(metadata.name) !== tokenId) {
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.ServiceProviderError, {
                                methodName: 'unhash',
                                domain: metadata.name,
                                providerMessage: 'Service provider returned an invalid domain name',
                            });
                        }
                        return [2 /*return*/, metadata.name];
                }
            });
        });
    };
    Uns.prototype.getMetadata = function (tokenId) {
        return __awaiter$3(this, void 0, void 0, function () {
            var tokenUri, resp, metadata;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getTokenUri(tokenId)];
                    case 1:
                        tokenUri = _a.sent();
                        return [4 /*yield*/, Networking_1$2.default.fetch(tokenUri, {}).catch(function (err) {
                                throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.MetadataEndpointError, {
                                    tokenUri: tokenUri || 'undefined',
                                    errorMessage: err.message,
                                });
                            })];
                    case 2:
                        resp = _a.sent();
                        if (!resp.ok) {
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.MetadataEndpointError, {
                                tokenUri: tokenUri || 'undefined',
                            });
                        }
                        return [4 /*yield*/, resp.json()];
                    case 3:
                        metadata = _a.sent();
                        if (!metadata.name) {
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.UnregisteredDomain, {
                                domain: "with tokenId ".concat(tokenId),
                            });
                        }
                        if (this.namehash(metadata.name) !== tokenId) {
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.ServiceProviderError, {
                                methodName: 'unhash',
                                domain: metadata.name,
                                providerMessage: 'Service provider returned an invalid domain name',
                            });
                        }
                        return [2 /*return*/, metadata];
                }
            });
        });
    };
    Uns.prototype.getVerifiedData = function (domain, keys) {
        return __awaiter$3(this, void 0, void 0, function () {
            var tokenId, data;
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenId = this.namehash(domain);
                        return [4 /*yield*/, this.get(tokenId, keys)];
                    case 1:
                        data = _a.sent();
                        if ((0, utils_1$2.isNullAddress)(data.resolver)) {
                            if ((0, utils_1$2.isNullAddress)(data.owner)) {
                                throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.UnregisteredDomain, {
                                    domain: domain,
                                });
                            }
                            throw new resolutionError_1$4.default(resolutionError_1$4.ResolutionErrorCode.UnspecifiedResolver, {
                                location: data.location,
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, data];
                }
            });
        });
    };
    Uns.prototype.get = function (tokenId, keys) {
        if (keys === void 0) { keys = []; }
        return __awaiter$3(this, void 0, void 0, function () {
            var _a, resultOrErrorL1, resultOrErrorL2, resolverL2, ownerL2, recordsL2, resolverL1, ownerL1, recordsL1;
            return __generator$3(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.unsl1.get(tokenId, keys).catch(function (err) { return err; }),
                            this.unsl2.get(tokenId, keys).catch(function (err) { return err; }),
                        ])];
                    case 1:
                        _a = _b.sent(), resultOrErrorL1 = _a[0], resultOrErrorL2 = _a[1];
                        validResultOrThrow(resultOrErrorL2);
                        resolverL2 = resultOrErrorL2.resolver, ownerL2 = resultOrErrorL2.owner, recordsL2 = resultOrErrorL2.records;
                        if (!(0, utils_1$2.isNullAddress)(ownerL2)) {
                            return [2 /*return*/, {
                                    resolver: resolverL2,
                                    owner: ownerL2,
                                    records: (0, utils_1$2.constructRecords)(keys, recordsL2),
                                    location: publicTypes_1$3.UnsLocation.Layer2,
                                }];
                        }
                        validResultOrThrow(resultOrErrorL1);
                        resolverL1 = resultOrErrorL1.resolver, ownerL1 = resultOrErrorL1.owner, recordsL1 = resultOrErrorL1.records;
                        return [2 /*return*/, {
                                resolver: resolverL1,
                                owner: ownerL1,
                                records: (0, utils_1$2.constructRecords)(keys, recordsL1),
                                location: publicTypes_1$3.UnsLocation.Layer1,
                            }];
                }
            });
        });
    };
    Uns.prototype.checkDomain = function (domain, passIfTokenID) {
        if (passIfTokenID === void 0) { passIfTokenID = false; }
        if (passIfTokenID) {
            return true;
        }
        var tokens = domain.split('.');
        return (!!tokens.length &&
            !(domain === 'eth' ||
                /^[^-]*[^-]*\.(eth|luxe|xyz|kred|addr\.reverse)$/.test(domain)) &&
            tokens.every(function (v) { return !!v.length; }));
    };
    return Uns;
}(NamingService_1$1.NamingService));
Uns$1.default = Uns;
function validResultOrThrow(resultOrError) {
    if (resultOrError instanceof Error) {
        throw resultOrError;
    }
    return resultOrError;
}
function validResolutionErrorOrThrow(error, validCode) {
    if (!(error instanceof resolutionError_1$4.default)) {
        throw error;
    }
    if (error.code === validCode) {
        return true;
    }
    throw error;
}

var UdApi$1 = {};

var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter$2 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$2 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(UdApi$1, "__esModule", { value: true });
var znsUtils_1 = znsUtils;
var resolutionError_1$3 = resolutionError;
var TwitterSignatureValidator_1 = TwitterSignatureValidator;
var publicTypes_1$2 = publicTypes;
var Networking_1$1 = __importDefault$1(Networking$1);
var utils_1$1 = utils$n;
var namehash_1$1 = namehash;
var NamingService_1 = NamingService$1;
/**
 * @internal
 */
var UdApi = /** @class */ (function (_super) {
    __extends(UdApi, _super);
    function UdApi(api) {
        var _this = _super.call(this) || this;
        _this.url = (api === null || api === void 0 ? void 0 : api.url) || 'https://unstoppabledomains.com/api/v1';
        var DefaultUserAgent = 'cross-fetch/3.1.4 (+https://github.com/lquixada/cross-fetch)';
        var CustomUserAgent = "".concat(DefaultUserAgent, " Resolution");
        _this.headers = { 'X-user-agent': CustomUserAgent };
        return _this;
    }
    UdApi.prototype.isSupportedDomain = function (_domain) {
        return __awaiter$2(this, void 0, void 0, function () {
            return __generator$2(this, function (_a) {
                throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'isSupportedDomain',
                });
            });
        });
    };
    UdApi.prototype.namehash = function (_domain) {
        throw new Error('Unsupported method when using UD Resolution API');
    };
    UdApi.prototype.childhash = function (_parentHash, _label) {
        throw new Error('Unsupported method when using UD Resolution API');
    };
    UdApi.prototype.record = function (domain, key) {
        return __awaiter$2(this, void 0, void 0, function () {
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.records(domain, [key])];
                    case 1: return [2 /*return*/, (_a.sent())[key]];
                }
            });
        });
    };
    UdApi.prototype.records = function (domain, keys) {
        return __awaiter$2(this, void 0, void 0, function () {
            var records;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.allRecords(domain)];
                    case 1:
                        records = _a.sent();
                        return [2 /*return*/, (0, utils_1$1.constructRecords)(keys, records)];
                }
            });
        });
    };
    UdApi.prototype.owner = function (domain) {
        return __awaiter$2(this, void 0, void 0, function () {
            var response, _a, owner, blockchain;
            return __generator$2(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.resolve(domain)];
                    case 1:
                        response = _b.sent();
                        _a = response.meta, owner = _a.owner, blockchain = _a.blockchain;
                        if (!owner) {
                            throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnregisteredDomain, {
                                domain: domain,
                            });
                        }
                        if (blockchain === publicTypes_1$2.BlockchainType.ZIL && !owner.startsWith('zil1')) {
                            return [2 /*return*/, (0, znsUtils_1.toBech32Address)(owner)];
                        }
                        return [2 /*return*/, owner];
                }
            });
        });
    };
    UdApi.prototype.twitter = function (domain) {
        return __awaiter$2(this, void 0, void 0, function () {
            var serviceName, domainMetaData, owner, records, validationSignature, twitterHandle;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        serviceName = (0, utils_1$1.findNamingServiceName)(domain);
                        if (serviceName !== publicTypes_1$2.NamingServiceName.UNS) {
                            throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnsupportedMethod, {
                                domain: domain,
                                methodName: 'twitter',
                            });
                        }
                        return [4 /*yield*/, this.resolve(domain)];
                    case 1:
                        domainMetaData = _a.sent();
                        if (!domainMetaData.meta.owner) {
                            throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnregisteredDomain, {
                                domain: domain,
                            });
                        }
                        owner = domainMetaData.meta.owner;
                        records = domainMetaData.records || {};
                        validationSignature = records['validation.social.twitter.username'];
                        twitterHandle = records['social.twitter.username'];
                        if (!validationSignature) {
                            throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.RecordNotFound, {
                                recordName: 'validation.social.twitter.username',
                                domain: domain,
                            });
                        }
                        if (!twitterHandle) {
                            throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.RecordNotFound, {
                                recordName: 'social.twitter.username',
                                domain: domain,
                            });
                        }
                        if (!(0, TwitterSignatureValidator_1.isValidTwitterSignature)({
                            tokenId: domainMetaData.meta.namehash,
                            owner: owner,
                            twitterHandle: twitterHandle,
                            validationSignature: validationSignature,
                        })) {
                            throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.InvalidTwitterVerification, {
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, twitterHandle];
                }
            });
        });
    };
    UdApi.prototype.allRecords = function (domain) {
        return __awaiter$2(this, void 0, void 0, function () {
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.resolve(domain)];
                    case 1: return [2 /*return*/, (_a.sent()).records || {}];
                }
            });
        });
    };
    UdApi.prototype.getDomainFromTokenId = function (tokenId) {
        return __awaiter$2(this, void 0, void 0, function () {
            var metadata;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenId = (0, namehash_1$1.fromDecStringToHex)(tokenId);
                        return [4 /*yield*/, this.getMetadata(tokenId)];
                    case 1:
                        metadata = _a.sent();
                        return [2 /*return*/, metadata.meta.domain];
                }
            });
        });
    };
    UdApi.prototype.getMetadata = function (tokenId) {
        return __awaiter$2(this, void 0, void 0, function () {
            var tokenUri, resp, metadata, namehash;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenUri = "".concat(this.url, "/").concat(tokenId);
                        return [4 /*yield*/, Networking_1$1.default.fetch(tokenUri, {}).catch(function (err) {
                                throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.MetadataEndpointError, {
                                    tokenUri: tokenUri || 'undefined',
                                    errorMessage: err.message,
                                });
                            })];
                    case 1:
                        resp = _a.sent();
                        return [4 /*yield*/, resp.json()];
                    case 2:
                        metadata = _a.sent();
                        if (!metadata.meta || !metadata.meta.domain) {
                            throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnregisteredDomain, {
                                domain: "with tokenId ".concat(tokenId),
                            });
                        }
                        namehash = metadata.meta.blockchain === publicTypes_1$2.BlockchainType.ZIL
                            ? (0, namehash_1$1.znsNamehash)(metadata.meta.domain)
                            : (0, namehash_1$1.eip137Namehash)(metadata.meta.domain);
                        if (namehash !== tokenId) {
                            throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.ServiceProviderError, {
                                methodName: 'unhash',
                                domain: metadata.meta.domain,
                                providerMessage: 'Service provider returned an invalid domain name',
                            });
                        }
                        return [2 /*return*/, metadata];
                }
            });
        });
    };
    UdApi.prototype.resolve = function (domain) {
        return __awaiter$2(this, void 0, void 0, function () {
            var response;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Networking_1$1.default.fetch("".concat(this.url, "/").concat(domain), {
                            method: 'GET',
                            headers: this.headers,
                        })];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.json()];
                }
            });
        });
    };
    UdApi.prototype.resolver = function (domain) {
        return __awaiter$2(this, void 0, void 0, function () {
            var record;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.resolve(domain)];
                    case 1:
                        record = _a.sent();
                        return [2 /*return*/, record.meta.resolver];
                }
            });
        });
    };
    UdApi.prototype.reverse = function (_address, _currencyTicker) {
        return __awaiter$2(this, void 0, void 0, function () {
            return __generator$2(this, function (_a) {
                throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'reverse',
                });
            });
        });
    };
    UdApi.prototype.reverseOf = function (_address, _location) {
        return __awaiter$2(this, void 0, void 0, function () {
            return __generator$2(this, function (_a) {
                throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'reverseOf',
                });
            });
        });
    };
    UdApi.prototype.isRegistered = function (domain) {
        return __awaiter$2(this, void 0, void 0, function () {
            var record;
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.resolve(domain)];
                    case 1:
                        record = _a.sent();
                        return [2 /*return*/, !(0, utils_1$1.isNullAddress)(record.meta.owner)];
                }
            });
        });
    };
    UdApi.prototype.getTokenUri = function (_tokenId) {
        return __awaiter$2(this, void 0, void 0, function () {
            return __generator$2(this, function (_a) {
                throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'getTokenUri',
                });
            });
        });
    };
    UdApi.prototype.isAvailable = function (domain) {
        return __awaiter$2(this, void 0, void 0, function () {
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isRegistered(domain)];
                    case 1: return [2 /*return*/, !(_a.sent())];
                }
            });
        });
    };
    UdApi.prototype.registryAddress = function (domain) {
        return __awaiter$2(this, void 0, void 0, function () {
            return __generator$2(this, function (_a) {
                throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnsupportedMethod, {
                    domain: domain,
                    methodName: 'registryAddress',
                });
            });
        });
    };
    UdApi.prototype.locations = function (_domains) {
        return __awaiter$2(this, void 0, void 0, function () {
            return __generator$2(this, function (_a) {
                throw new resolutionError_1$3.ResolutionError(resolutionError_1$3.ResolutionErrorCode.UnsupportedMethod, {
                    methodName: 'locations',
                });
            });
        });
    };
    return UdApi;
}(NamingService_1.NamingService));
UdApi$1.default = UdApi;

var DnsUtils$1 = {};

var dnsRecordsError = {};

(function (exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var _a;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DnsRecordsError = exports.DnsRecordsErrorCode = void 0;
	var DnsRecordsErrorCode;
	(function (DnsRecordsErrorCode) {
	    DnsRecordsErrorCode["InconsistentTtl"] = "InconsistentTtl";
	    DnsRecordsErrorCode["DnsRecordCorrupted"] = "DnsRecordCorrupted";
	})(DnsRecordsErrorCode = exports.DnsRecordsErrorCode || (exports.DnsRecordsErrorCode = {}));
	/**
	 * @internal
	 * Internal Mapping object from DnsRecordsErrorCode to a DnsRecordsErrorHandler
	 */
	var HandlersByCode = (_a = {},
	    _a[DnsRecordsErrorCode.InconsistentTtl] = function (params) {
	        return "ttl for record ".concat(params.recordType, " is different for other records of the same type");
	    },
	    _a[DnsRecordsErrorCode.DnsRecordCorrupted] = function (params) {
	        return "dns record ".concat(params.recordType, " is invalid json-string");
	    },
	    _a);
	/**
	 * Configuration Error class is designed to control every error being thrown by wrong configurations for objects
	 * @param code - Error Code
	 * - IncorrectProvider - When provider doesn't have implemented send or sendAsync methods
	 * - UnsupportedNetwork - When network is not specified or not supported
	 * - UnspecifiedUrl - When url is not specified for custom naming service configurations
	 * @param method - optional param to specify which namingService errored out
	 */
	var DnsRecordsError = /** @class */ (function (_super) {
	    __extends(DnsRecordsError, _super);
	    function DnsRecordsError(code, options) {
	        if (options === void 0) { options = {}; }
	        var _this = this;
	        var DnsRecordsErrorHandler = HandlersByCode[code];
	        _this = _super.call(this, DnsRecordsErrorHandler(options)) || this;
	        _this.code = code;
	        _this.name = 'DnsRecordsError';
	        Object.setPrototypeOf(_this, DnsRecordsError.prototype);
	        return _this;
	    }
	    return DnsRecordsError;
	}(Error));
	exports.DnsRecordsError = DnsRecordsError;
	exports.default = DnsRecordsError;
} (dnsRecordsError));

var __createBinding$3 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$3 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$3 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
    __setModuleDefault$3(result, mod);
    return result;
};
Object.defineProperty(DnsUtils$1, "__esModule", { value: true });
var dnsRecordsError_1 = __importStar$3(dnsRecordsError);
var publicTypes_1$1 = publicTypes;
var DnsUtils = /** @class */ (function () {
    function DnsUtils() {
    }
    DnsUtils.prototype.toList = function (record) {
        var _a;
        var _this = this;
        var dnsTypes = this.getAllDnsTypes(record);
        return (_a = []).concat.apply(_a, dnsTypes.map(function (type) { return _this.constructDnsRecords(record, type); }));
    };
    DnsUtils.prototype.toCrypto = function (records) {
        var cryptoRecords = {};
        for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {
            var record = records_1[_i];
            var type = record.type, TTL = record.TTL, data = record.data;
            var ttlInRecord = this.getJsonNumber(cryptoRecords["dns.".concat(type, ".ttl")]);
            var dnsInRecord = this.getJsonArray(cryptoRecords, "dns.".concat(type));
            if (dnsInRecord) {
                dnsInRecord.push(data);
                cryptoRecords["dns.".concat(type)] = JSON.stringify(dnsInRecord);
            }
            else {
                cryptoRecords["dns.".concat(type)] = JSON.stringify([data]);
                cryptoRecords["dns.".concat(type, ".ttl")] = TTL.toString(10);
            }
            if (!!ttlInRecord && ttlInRecord !== TTL) {
                throw new dnsRecordsError_1.default(dnsRecordsError_1.DnsRecordsErrorCode.InconsistentTtl, {
                    recordType: type,
                });
            }
        }
        return cryptoRecords;
    };
    DnsUtils.prototype.protectFromCorruptRecord = function (rawRecord, type) {
        try {
            return rawRecord ? JSON.parse(rawRecord) : undefined;
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                throw new dnsRecordsError_1.default(dnsRecordsError_1.DnsRecordsErrorCode.DnsRecordCorrupted, {
                    recordType: type,
                });
            }
            throw err;
        }
    };
    DnsUtils.prototype.getJsonArray = function (cryptoRecrods, key) {
        var rawRecord = cryptoRecrods[key];
        var type = key.split('.')[1];
        return this.protectFromCorruptRecord(rawRecord, type);
    };
    DnsUtils.prototype.getJsonNumber = function (rawRecord) {
        return rawRecord ? parseInt(rawRecord, 10) : undefined;
    };
    DnsUtils.prototype.getAllDnsTypes = function (records) {
        var keys = new Set();
        Object.keys(records).forEach(function (key) {
            var chunks = key.split('.');
            var type = chunks[1] && chunks[1] !== 'ttl';
            if (type) {
                keys.add(publicTypes_1$1.DnsRecordType[chunks[1]]);
            }
        });
        return Array.from(keys);
    };
    DnsUtils.prototype.constructDnsRecords = function (cryptoData, type) {
        var TTL = this.parseTtl(cryptoData, type);
        var jsonValueString = cryptoData["dns.".concat(type)];
        if (!jsonValueString) {
            return [];
        }
        var typeData = this.protectFromCorruptRecord(jsonValueString, type);
        if (!this.isStringArray(typeData)) {
            return [];
        }
        return typeData.map(function (data) { return ({ TTL: TTL, data: data, type: type }); });
    };
    DnsUtils.prototype.parseTtl = function (data, type) {
        var defaultTtl = data['dns.ttl'];
        var recordTtl = data["dns.".concat(type, ".ttl")];
        if (recordTtl) {
            var parsedInt = this.parseIfNumber(recordTtl);
            if (parsedInt) {
                return parsedInt;
            }
        }
        if (defaultTtl) {
            var parsedInt = this.parseIfNumber(defaultTtl);
            if (parsedInt) {
                return parsedInt;
            }
        }
        return DnsUtils.DefaultTtl;
    };
    DnsUtils.prototype.parseIfNumber = function (str) {
        var parsedInt = parseInt(str, 10);
        if (!isNaN(parsedInt)) {
            return parsedInt;
        }
    };
    DnsUtils.prototype.isStringArray = function (value) {
        if (value instanceof Array) {
            return value.every(function (item) { return typeof item === 'string'; });
        }
        return false;
    };
    DnsUtils.DefaultTtl = 300; // 5 minutes
    return DnsUtils;
}());
DnsUtils$1.default = DnsUtils;

var Eip1993Factories = {};

var __createBinding$2 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$2 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$2 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
    __setModuleDefault$2(result, mod);
    return result;
};
var __awaiter$1 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$1 = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(Eip1993Factories, "__esModule", { value: true });
Eip1993Factories.Eip1993Factories = void 0;
var configurationError_1 = configurationError;
var resolutionError_1$2 = __importStar$2(resolutionError);
Eip1993Factories.Eip1993Factories = {
    fromWeb3Version0Provider: fromWeb3Version0Provider,
    fromWeb3Version1Provider: fromWeb3Version1Provider,
    fromEthersProvider: fromEthersProvider,
    fromZilliqaProvider: fromZilliqaProvider,
};
/**
 * Create a Provider instance from web3 0.x version provider
 * @param provider - an 0.x version provider from web3 ( must implement sendAsync(payload, callback) )
 * @see https://github.com/ethereum/web3.js/blob/0.20.7/lib/web3/httpprovider.js#L116
 */
function fromWeb3Version0Provider(provider) {
    if (provider.sendAsync === undefined) {
        throw new configurationError_1.ConfigurationError(configurationError_1.ConfigurationErrorCode.IncorrectProvider);
    }
    return {
        request: function (request) {
            return new Promise(function (resolve, reject) {
                provider.sendAsync({
                    jsonrpc: '2.0',
                    method: request.method,
                    params: wrapArray(request.params),
                    id: 1,
                }, function (error, result) {
                    if (error) {
                        reject(error);
                    }
                    if (result.error) {
                        reject(new resolutionError_1$2.default(resolutionError_1$2.ResolutionErrorCode.ServiceProviderError, {
                            providerMessage: result.error,
                        }));
                    }
                    resolve(result.result);
                });
            });
        },
    };
}
/**
 * Create a Provider instance from web3 1.x version provider
 * @param provider - an 1.x version provider from web3 ( must implement send(payload, callback) )
 * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-core-helpers/types/index.d.ts#L165
 * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-providers-http/src/index.js#L95
 */
function fromWeb3Version1Provider(provider) {
    if (provider.send === undefined) {
        throw new configurationError_1.ConfigurationError(configurationError_1.ConfigurationErrorCode.IncorrectProvider);
    }
    return {
        request: function (request) {
            return new Promise(function (resolve, reject) {
                provider.send({
                    jsonrpc: '2.0',
                    method: request.method,
                    params: wrapArray(request.params),
                    id: 1,
                }, function (error, result) {
                    if (error) {
                        reject(error);
                    }
                    if (result.error) {
                        reject(new resolutionError_1$2.default(resolutionError_1$2.ResolutionErrorCode.ServiceProviderError, {
                            providerMessage: result.error,
                        }));
                    }
                    resolve(result.result);
                });
            });
        },
    };
}
/**
 * Creates a Provider instance from a provider that implements Ethers Provider#call interface.
 * This wrapper support only `eth_call` method for now, which is enough for all the current Resolution functionality
 * @param provider - provider object
 * @see https://github.com/ethers-io/ethers.js/blob/v4-legacy/providers/abstract-provider.d.ts#L91
 * @see https://github.com/ethers-io/ethers.js/blob/v5.0.4/packages/abstract-provider/src.ts/index.ts#L224
 * @see https://docs.ethers.io/ethers.js/v5-beta/api-providers.html#jsonrpcprovider-inherits-from-provider
 * @see https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
 */
function fromEthersProvider(provider) {
    var _this = this;
    if (provider.call === undefined) {
        throw new configurationError_1.ConfigurationError(configurationError_1.ConfigurationErrorCode.IncorrectProvider);
    }
    return {
        request: function (request) { return __awaiter$1(_this, void 0, void 0, function () {
            var _a, error_1;
            return __generator$1(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 7, , 8]);
                        _a = request.method;
                        switch (_a) {
                            case 'eth_call': return [3 /*break*/, 1];
                            case 'eth_getLogs': return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 5];
                    case 1: return [4 /*yield*/, provider.call(request.params[0])];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3: return [4 /*yield*/, provider.getLogs(request.params[0])];
                    case 4: return [2 /*return*/, _b.sent()];
                    case 5: throw new resolutionError_1$2.default(resolutionError_1$2.ResolutionErrorCode.ServiceProviderError, {
                        providerMessage: "Unsupported provider method ".concat(request.method),
                    });
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        error_1 = _b.sent();
                        throw new resolutionError_1$2.default(resolutionError_1$2.ResolutionErrorCode.ServiceProviderError, {
                            providerMessage: error_1.message,
                        });
                    case 8: return [2 /*return*/];
                }
            });
        }); },
    };
}
/**
 * Creates a Provider instance from @zilliqa-js/core Provider
 * @param provider - provider object
 */
function fromZilliqaProvider(provider) {
    var _this = this;
    if (provider.middleware === undefined || provider.send === undefined) {
        throw new configurationError_1.ConfigurationError(configurationError_1.ConfigurationErrorCode.IncorrectProvider);
    }
    return {
        request: function (request) { return __awaiter$1(_this, void 0, void 0, function () {
            var resp, error_2;
            return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, provider.send.apply(provider, __spreadArray([request.method], (request.params || []), false))];
                    case 1:
                        resp = _a.sent();
                        if (resp.error) {
                            throw new Error(resp.error.message);
                        }
                        return [2 /*return*/, resp.result];
                    case 2:
                        error_2 = _a.sent();
                        throw new resolutionError_1$2.default(resolutionError_1$2.ResolutionErrorCode.ServiceProviderError, {
                            providerMessage: error_2.message,
                        });
                    case 3: return [2 /*return*/];
                }
            });
        }); },
    };
}
function wrapArray(params) {
    if (params === void 0) { params = []; }
    return params instanceof Array ? params : [params];
}

var prepareAndValidate = {};

var __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(prepareAndValidate, "__esModule", { value: true });
prepareAndValidate.prepareAndValidateDomain = void 0;
var resolutionError_1$1 = __importStar$1(resolutionError);
/**
 * Checks domain name for special symbols and returns address in lowercase without spaces
 * @throws Will throw an error if domain address contains special symbols
 * @param domain - a domain address
 */
var reg = RegExp('^[.a-z0-9-]+$');
function prepareAndValidateDomain(domain) {
    var retVal = domain ? domain.trim().toLowerCase() : '';
    if (!reg.test(retVal)) {
        throw new resolutionError_1$1.default(resolutionError_1$1.ResolutionErrorCode.InvalidDomainAddress, {
            domain: domain,
        });
    }
    return retVal;
}
prepareAndValidate.prepareAndValidateDomain = prepareAndValidateDomain;

var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(Resolution$1, "__esModule", { value: true });
Resolution$1.Resolution = void 0;
var bn_js_1 = __importDefault(bnExports$1);
var Zns_1 = __importDefault(Zns$1);
var Uns_1 = __importDefault(Uns$1);
var UdApi_1 = __importDefault(UdApi$1);
var publicTypes_1 = publicTypes;
var resolutionError_1 = __importStar(resolutionError);
var DnsUtils_1 = __importDefault(DnsUtils$1);
var utils_1 = utils$n;
var Eip1993Factories_1 = Eip1993Factories;
var Networking_1 = __importDefault(Networking$1);
var prepareAndValidate_1 = prepareAndValidate;
var namehash_1 = namehash;
/**
 * Blockchain domain Resolution library - Resolution.
 * @example
 * ```
 * import Resolution from '@unstoppabledomains/resolution';
 *
 * let resolution = new Resolution({ blockchain: {
 *        uns: {
 *           url: "https://eth-mainnet.alchemyapi.io/v2/GmQ8X1FHf-WDEry0BBSn0RgjVhjHkRmS",
 *           network: "mainnet"
 *        }
 *      }
 *   });
 *
 * let domain = "brad.zil";
 * resolution.addr(domain, "eth").then(addr => console.log(addr));;
 * ```
 */
var Resolution = /** @class */ (function () {
    function Resolution(_a) {
        var _b;
        var _c = _a === void 0 ? {} : _a, _d = _c.sourceConfig, sourceConfig = _d === void 0 ? undefined : _d;
        var uns = isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns)
            ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns)
            : new Uns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns);
        var zns = isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns)
            ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns)
            : new Zns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns);
        // If both UNS and ZNS use the same UdApi providers, we don't want to call the API twice as it would return same
        // responses. It should be enough to compare just the URLs, as the network param isn't actually used in the calls.
        var equalUdApiProviders = uns instanceof UdApi_1.default && zns instanceof UdApi_1.default && uns.url === zns.url;
        // If a user configures the lib with an API source, we still want to initialise native blockchain services to access
        // some non-async methods such as namehash, as they are unavailable in the UdApi service.
        this.serviceMap = (_b = {},
            _b[publicTypes_1.NamingServiceName.UNS] = {
                usedServices: [uns],
                native: isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns) ? new Uns_1.default() : uns,
            },
            _b[publicTypes_1.NamingServiceName.ZNS] = {
                usedServices: equalUdApiProviders ? [uns] : [uns, zns],
                native: isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns) ? new Zns_1.default() : zns,
            },
            _b);
    }
    /**
     * AutoConfigure the blockchain network for UNS
     * We make a "net_version" JSON RPC call to the blockchain either via url or with the help of given provider.
     * @param sourceConfig - configuration object for uns
     * @returns configured Resolution object
     */
    Resolution.autoNetwork = function (sourceConfig) {
        return __awaiter(this, void 0, void 0, function () {
            var resolution, uns;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        resolution = new this();
                        if (!sourceConfig.uns) return [3 /*break*/, 2];
                        return [4 /*yield*/, Uns_1.default.autoNetwork(sourceConfig.uns)];
                    case 1:
                        uns = _a.sent();
                        resolution.serviceMap[publicTypes_1.NamingServiceName.UNS] = {
                            usedServices: [uns],
                            native: uns,
                        };
                        _a.label = 2;
                    case 2: return [2 /*return*/, resolution];
                }
            });
        });
    };
    /**
     * Creates a resolution with configured infura id for uns
     * @param infura - infura project id
     * @param networks - an optional object that describes what network to use when connecting UNS default is mainnet
     */
    Resolution.infura = function (infura, networks) {
        var _a, _b, _c, _d;
        return new this({
            sourceConfig: {
                uns: {
                    locations: {
                        Layer1: {
                            url: (0, utils_1.signedLink)(infura, ((_a = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _a === void 0 ? void 0 : _a.locations.Layer1.network) || 'mainnet', 'infura'),
                            network: ((_b = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _b === void 0 ? void 0 : _b.locations.Layer1.network) || 'mainnet',
                        },
                        Layer2: {
                            url: (0, utils_1.signedLink)(infura, ((_c = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _c === void 0 ? void 0 : _c.locations.Layer2.network) || 'polygon-mainnet', 'infura'),
                            network: ((_d = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _d === void 0 ? void 0 : _d.locations.Layer2.network) || 'polygon-mainnet',
                        },
                    },
                },
            },
        });
    };
    /**
     * Creates a resolution with configured alchemy API keys for uns
     * @param alchemy - alchemy API keys
     * @param networks - an optional object that describes what network to use when connecting UNS default is mainnet
     */
    Resolution.alchemy = function (alchemy, networks) {
        var _a, _b, _c, _d;
        return new this({
            sourceConfig: {
                uns: {
                    locations: {
                        Layer1: {
                            url: (0, utils_1.signedLink)(alchemy, ((_a = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _a === void 0 ? void 0 : _a.locations.Layer1.network) || 'mainnet'),
                            network: ((_b = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _b === void 0 ? void 0 : _b.locations.Layer1.network) || 'mainnet',
                        },
                        Layer2: {
                            url: (0, utils_1.signedLink)(alchemy, ((_c = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _c === void 0 ? void 0 : _c.locations.Layer2.network) || 'polygon-mainnet'),
                            network: ((_d = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _d === void 0 ? void 0 : _d.locations.Layer2.network) || 'polygon-mainnet',
                        },
                    },
                },
            },
        });
    };
    /**
     * Creates a resolution instance with configured provider
     * @param networks - an object that describes what network to use when connecting UNS or ZNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    Resolution.fromResolutionProvider = function (networks) {
        if (networks.uns) {
            return this.fromEthereumEip1193Provider({
                uns: networks.uns,
            });
        }
        if (networks.zns) {
            return this.fromZilliqaProvider(networks.zns.provider, networks);
        }
        throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
            providerMessage: 'Must specify network for uns or zns',
        });
    };
    /**
     * Creates a resolution instance with configured provider
     * @param networks - an object that describes what network to use when connecting UNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    Resolution.fromEthereumEip1193Provider = function (networks) {
        var sourceConfig = {};
        if (networks.uns) {
            sourceConfig.uns = {
                locations: {
                    Layer1: {
                        provider: networks.uns.locations.Layer1.provider,
                        network: networks.uns.locations.Layer1.network || 'mainnet',
                    },
                    Layer2: {
                        provider: networks.uns.locations.Layer2.provider,
                        network: networks.uns.locations.Layer2.network || 'polygon-mainnet',
                    },
                },
            };
        }
        return new this({
            sourceConfig: sourceConfig,
        });
    };
    /**
     * Creates a resolution instance with configured provider
     * @param provider - any provider compatible with EIP-1193
     * @param networks - an optional object that describes what network to use when connecting ZNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    Resolution.fromZilliqaProvider = function (provider, networks) {
        var _a;
        return new this({
            sourceConfig: {
                zns: { provider: provider, network: ((_a = networks === null || networks === void 0 ? void 0 : networks.zns) === null || _a === void 0 ? void 0 : _a.network) || 'mainnet' },
            },
        });
    };
    /**
     * Create a resolution instance from web3 0.x version provider
     * @param networks - Ethereum network configuration with 0.x version provider from web3 ( must implement sendAsync(payload, callback) )
     * @see https://github.com/ethereum/web3.js/blob/0.20.7/lib/web3/httpprovider.js#L116
     */
    Resolution.fromWeb3Version0Provider = function (networks) {
        return this.fromEthereumEip1193Provider({
            uns: networks.uns
                ? {
                    locations: {
                        Layer1: {
                            network: networks.uns.locations.Layer1.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version0Provider(networks.uns.locations.Layer1.provider),
                        },
                        Layer2: {
                            network: networks.uns.locations.Layer2.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version0Provider(networks.uns.locations.Layer2.provider),
                        },
                    },
                }
                : undefined,
        });
    };
    /**
     * Create a resolution instance from web3 1.x version provider
     * @param networks - an optional object with 1.x version provider from web3 ( must implement send(payload, callback) ) that describes what network to use when connecting UNS default is mainnet
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-core-helpers/types/index.d.ts#L165
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-providers-http/src/index.js#L95
     */
    Resolution.fromWeb3Version1Provider = function (networks) {
        return this.fromEthereumEip1193Provider({
            uns: networks.uns
                ? {
                    locations: {
                        Layer1: {
                            network: networks.uns.locations.Layer1.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version1Provider(networks.uns.locations.Layer1.provider),
                        },
                        Layer2: {
                            network: networks.uns.locations.Layer2.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version1Provider(networks.uns.locations.Layer2.provider),
                        },
                    },
                }
                : undefined,
        });
    };
    /**
     * Creates instance of resolution from provider that implements Ethers Provider#call interface.
     * This wrapper support only `eth_call` method for now, which is enough for all the current Resolution functionality
     * @param networks - an object that describes what network to use when connecting UNS default is mainnet
     * @see https://github.com/ethers-io/ethers.js/blob/v4-legacy/providers/abstract-provider.d.ts#L91
     * @see https://github.com/ethers-io/ethers.js/blob/v5.0.4/packages/abstract-provider/src.ts/index.ts#L224
     * @see https://docs.ethers.io/ethers.js/v5-beta/api-providers.html#jsonrpcprovider-inherits-from-provider
     * @see https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
     */
    Resolution.fromEthersProvider = function (networks) {
        return this.fromEthereumEip1193Provider({
            uns: networks.uns
                ? {
                    locations: {
                        Layer1: {
                            network: networks.uns.locations.Layer1.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromEthersProvider(networks.uns.locations.Layer1.provider),
                        },
                        Layer2: {
                            network: networks.uns.locations.Layer2.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromEthersProvider(networks.uns.locations.Layer2.provider),
                        },
                    },
                }
                : undefined,
        });
    };
    /**
     * Resolves given domain name to a specific currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker like BTC, ETH, ZIL
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an address
     */
    Resolution.prototype.addr = function (domain, ticker) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.record(domain, "crypto.".concat(ticker.toUpperCase(), ".address"))];
            });
        });
    };
    /**
     * Read multi-chain currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker (USDT, FTM, etc.)
     * @param chain - chain version, usually means blockchain ( ERC20, BEP2, OMNI, etc. )
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an adress
     */
    Resolution.prototype.multiChainAddr = function (domain, ticker, chain) {
        return __awaiter(this, void 0, void 0, function () {
            var recordKey;
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                recordKey = "crypto.".concat(ticker.toUpperCase(), ".version.").concat(chain.toUpperCase(), ".address");
                return [2 /*return*/, this.callServiceForDomain(domain, function (service) {
                        return service.record(domain, recordKey);
                    })];
            });
        });
    };
    /**
     * Resolves given domain name to a verified twitter handle
     * @async
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]] if twitter is not found
     * @returns A promise that resolves in a verified twitter handle
     */
    Resolution.prototype.twitter = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.callServiceForDomain(domain, function (service) {
                        return service.twitter(domain);
                    })];
            });
        });
    };
    /**
     * Resolve a chat id from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns A promise that resolves in chatId
     */
    Resolution.prototype.chatId = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.record(domain, 'gundb.username.value')];
            });
        });
    };
    /**
     * Resolve a gundb public key from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns a promise that resolves in gundb public key
     */
    Resolution.prototype.chatPk = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.record(domain, 'gundb.public_key.value')];
            });
        });
    };
    /**
     * Resolves the IPFS hash configured for domain records on ZNS
     * @param domain - domain name
     * @throws [[ResolutionError]]
     */
    Resolution.prototype.ipfsHash = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.getPreferableNewRecord(domain, 'dweb.ipfs.hash', 'ipfs.html.value')];
            });
        });
    };
    /**
     * Resolves the httpUrl attached to domain
     * @param domain - domain name
     */
    Resolution.prototype.httpUrl = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.getPreferableNewRecord(domain, 'browser.redirect_url', 'ipfs.redirect_domain.value')];
            });
        });
    };
    /**
     * Resolves the ipfs email field from whois configurations
     * @param domain - domain name
     * @throws [[ResolutionError]]
     * @returns A Promise that resolves in an email address configured for this domain whois
     */
    Resolution.prototype.email = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.record(domain, 'whois.email.value')];
            });
        });
    };
    /**
     * @returns the resolver address for a specific domain
     * @param domain - domain to look for
     */
    Resolution.prototype.resolver = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var resolver;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                        return [4 /*yield*/, this.callServiceForDomain(domain, function (service) {
                                return service.resolver(domain);
                            })];
                    case 1:
                        resolver = _a.sent();
                        if (!resolver) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver, {
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, resolver];
                }
            });
        });
    };
    /**
     * @param domain - domain name
     * @returns An owner address of the domain
     */
    Resolution.prototype.owner = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.callServiceForDomain(domain, function (service) {
                        return service.owner(domain);
                    })];
            });
        });
    };
    /**
     * @param domain - domain name
     * @param recordKey - a name of a record to be resolved
     * @returns A record value promise for a given record name
     */
    Resolution.prototype.record = function (domain, recordKey) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.callServiceForDomain(domain, function (service) {
                        return service.record(domain, recordKey);
                    })];
            });
        });
    };
    /**
     * @param domain domain name
     * @param keys Array of record keys to be resolved
     * @returns A Promise with key-value mapping of domain records
     */
    Resolution.prototype.records = function (domain, keys) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.callServiceForDomain(domain, function (service) {
                        return service.records(domain, keys);
                    })];
            });
        });
    };
    /**
     * @param domain domain name
     * @returns A Promise of whether or not the domain belongs to a wallet
     */
    Resolution.prototype.isRegistered = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.callServiceForDomainBoolean(domain, function (service) { return service.isRegistered(domain); }, {
                        throwIfUnsupportedDomain: true,
                        expectedValue: true,
                    })];
            });
        });
    };
    /**
     * @param domain domain name
     * @returns A Promise of whether or not the domain is available
     */
    Resolution.prototype.isAvailable = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.callServiceForDomainBoolean(domain, function (service) { return service.isAvailable(domain); }, {
                        throwIfUnsupportedDomain: true,
                        expectedValue: false,
                    })];
            });
        });
    };
    /**
     * @returns Produces a namehash from supported naming service in hex format with 0x prefix.
     * Corresponds to ERC721 token id in case of Ethereum based naming service like UNS.
     * @param domain domain name to be converted
     * @param namingService "UNS" or "ZNS" (uses keccak256 or sha256 algorithm respectively)
     * @param options formatting options
     * @throws [[ResolutionError]] with UnsupportedDomain error code if domain extension is unknown
     */
    Resolution.prototype.namehash = function (domain, namingService, options) {
        if (options === void 0) { options = publicTypes_1.NamehashOptionsDefault; }
        var service = this.serviceMap[namingService];
        if (!service) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {
                namingService: namingService,
            });
        }
        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
        return this.formatNamehash(service.native.namehash(domain), options);
    };
    /**
     * @returns a namehash of a subdomain with name label
     * @param parent namehash of a parent domain
     * @param label subdomain name
     * @param namingService "UNS" or "ZNS" (uses keccak256 or sha256 algorithm respectively)
     * @param options formatting options
     */
    Resolution.prototype.childhash = function (parent, label, namingService, options) {
        if (options === void 0) { options = publicTypes_1.NamehashOptionsDefault; }
        var service = this.serviceMap[namingService];
        if (!service) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {
                namingService: namingService,
            });
        }
        return this.formatNamehash(service.native.childhash(parent, label), options);
    };
    Resolution.prototype.formatNamehash = function (hash, options) {
        hash = hash.replace('0x', '');
        if (options.format === 'dec') {
            return new bn_js_1.default(hash, 'hex').toString(10);
        }
        else {
            return options.prefix ? '0x' + hash : hash;
        }
    };
    /**
     * Checks weather the domain name matches the hash
     * @param domain - domain name to check against
     * @param hash - hash obtained from the blockchain
     * @param namingService - "UNS" or "ZNS" (uses keccak256 or sha256 algorithm respectively)
     */
    Resolution.prototype.isValidHash = function (domain, hash, namingService) {
        var service = this.serviceMap[namingService];
        if (!service) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {
                namingService: namingService,
            });
        }
        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
        return service.native.namehash(domain) === hash;
    };
    /**
     * Checks if the domain name is valid according to naming service rules
     * for valid domain names.
     * @param domain - domain name to be checked
     */
    Resolution.prototype.isSupportedDomain = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.callServiceForDomainBoolean(domain, function (service) { return service.isSupportedDomain(domain); }, {
                        throwIfUnsupportedDomain: false,
                        expectedValue: true,
                    })];
            });
        });
    };
    /**
     * Returns all record keys of the domain.
     * This method is strongly unrecommended for production use due to lack of support for many ethereum service providers and low performance
     * @param domain - domain name
     */
    Resolution.prototype.allRecords = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                return [2 /*return*/, this.callServiceForDomain(domain, function (service) {
                        return service.allRecords(domain);
                    })];
            });
        });
    };
    Resolution.prototype.allNonEmptyRecords = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var records, nonEmptyRecords, _i, _a, _b, key, value;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.allRecords(domain)];
                    case 1:
                        records = _c.sent();
                        nonEmptyRecords = {};
                        for (_i = 0, _a = Object.entries(records); _i < _a.length; _i++) {
                            _b = _a[_i], key = _b[0], value = _b[1];
                            if (value) {
                                nonEmptyRecords[key] = value;
                            }
                        }
                        return [2 /*return*/, nonEmptyRecords];
                }
            });
        });
    };
    Resolution.prototype.dns = function (domain, types) {
        return __awaiter(this, void 0, void 0, function () {
            var dnsUtils, dnsRecordKeys, blockchainData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dnsUtils = new DnsUtils_1.default();
                        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                        dnsRecordKeys = this.getDnsRecordKeys(types);
                        return [4 /*yield*/, this.callServiceForDomain(domain, function (service) {
                                return service.records(domain, dnsRecordKeys);
                            })];
                    case 1:
                        blockchainData = _a.sent();
                        return [2 /*return*/, dnsUtils.toList(blockchainData)];
                }
            });
        });
    };
    /**
     * Retrieves the tokenURI from the registry smart contract.
     * @returns the ERC721Metadata#tokenURI contract method result
     * @param domain - domain name
     */
    Resolution.prototype.tokenURI = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var namehash;
            return __generator(this, function (_a) {
                namehash = this.namehash(domain, publicTypes_1.NamingServiceName.UNS);
                return [2 /*return*/, this.callServiceForDomain(domain, function (service) {
                        return service.getTokenUri(namehash);
                    })];
            });
        });
    };
    /**
     * Retrieves the data from the endpoint provided by tokenURI from the registry smart contract.
     * @returns the JSON response of the token URI endpoint
     * @param domain - domain name
     */
    Resolution.prototype.tokenURIMetadata = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenUri;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.tokenURI(domain)];
                    case 1:
                        tokenUri = _a.sent();
                        return [2 /*return*/, this.getMetadataFromTokenURI(tokenUri)];
                }
            });
        });
    };
    /**
     * Retrieves address of registry contract used for domain
     * @param domain - domain name
     * @returns Registry contract address
     */
    Resolution.prototype.registryAddress = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.callServiceForDomain(domain, function (service) {
                        return service.registryAddress(domain);
                    })];
            });
        });
    };
    /**
     * Retrieves the domain name from tokenId by parsing registry smart contract event logs.
     * @throws {ResolutionError} if returned domain name doesn't match the original namhash.
     * @returns the domain name retrieved from token metadata
     * @param hash - domain hash
     * @param service - nameservice which is used for lookup
     */
    Resolution.prototype.unhash = function (hash, service) {
        return __awaiter(this, void 0, void 0, function () {
            var services, method;
            return __generator(this, function (_a) {
                hash = (0, namehash_1.fromDecStringToHex)(hash);
                services = this.serviceMap[service].usedServices;
                method = services[services.length - 1];
                return [2 /*return*/, method.getDomainFromTokenId(hash)];
            });
        });
    };
    /**
     * Retrieves address of registry contract used for domain
     * @param domains - domain name
     * @returns Promise<Locations> - A map of domain name and Location (a set of attributes like blockchain,
     */
    Resolution.prototype.locations = function (domains) {
        return __awaiter(this, void 0, void 0, function () {
            var zilDomains, unsPromise, znsServices, znsService, znsPromise, unsLocations, emptyZilEntries, znsLocations, _i, emptyZilEntries_1, domain;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        zilDomains = domains.filter(function (domain) { return domain.endsWith('.zil'); });
                        unsPromise = this.serviceMap.UNS.usedServices[0].locations(domains);
                        if (!zilDomains.length) {
                            return [2 /*return*/, unsPromise];
                        }
                        znsServices = this.serviceMap.ZNS.usedServices;
                        znsService = znsServices[znsServices.length - 1];
                        znsPromise = (0, utils_1.wrapResult)(function () { return znsService.locations(zilDomains); });
                        return [4 /*yield*/, unsPromise];
                    case 1:
                        unsLocations = _a.sent();
                        emptyZilEntries = Object.entries(unsLocations).filter(function (_a) {
                            var domain = _a[0], location = _a[1];
                            return domain.endsWith('.zil') && !location;
                        });
                        if (!emptyZilEntries.length) {
                            return [2 /*return*/, unsLocations];
                        }
                        return [4 /*yield*/, znsPromise.then(utils_1.unwrapResult)];
                    case 2:
                        znsLocations = _a.sent();
                        for (_i = 0, emptyZilEntries_1 = emptyZilEntries; _i < emptyZilEntries_1.length; _i++) {
                            domain = emptyZilEntries_1[_i][0];
                            unsLocations[domain] = znsLocations[domain];
                        }
                        return [2 /*return*/, unsLocations];
                }
            });
        });
    };
    /**
     * Returns the token ID that is the primary resolution of the provided address
     * @param address - owner's address
     * @returns Promise<tokenId> - token ID that is the primary resolution of the provided address
     */
    Resolution.prototype.reverseTokenId = function (address, options) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenId;
            return __generator(this, function (_a) {
                tokenId = this.reverseGetTokenId(address, options === null || options === void 0 ? void 0 : options.location);
                return [2 /*return*/, tokenId];
            });
        });
    };
    /**
     * Returns the domain that is the primary resolution of the provided address
     * @param address - owner's address
     * @returns Promise<URL> - domain URL that is the primary resolution of the provided addresss
     */
    Resolution.prototype.reverse = function (address, options) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenId;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.reverseGetTokenId(address, options === null || options === void 0 ? void 0 : options.location)];
                    case 1:
                        tokenId = _a.sent();
                        if (tokenId) {
                            return [2 /*return*/, this.unhash(tokenId, publicTypes_1.NamingServiceName.UNS)];
                        }
                        return [2 /*return*/, null];
                }
            });
        });
    };
    Resolution.prototype.getMetadataFromTokenURI = function (tokenUri) {
        return __awaiter(this, void 0, void 0, function () {
            var resp, _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, Networking_1.default.fetch(tokenUri, {})];
                    case 1:
                        resp = _d.sent();
                        if (resp.ok) {
                            return [2 /*return*/, resp.json()];
                        }
                        _a = resolutionError_1.default.bind;
                        _b = [void 0, resolutionError_1.ResolutionErrorCode.ServiceProviderError];
                        _c = {};
                        return [4 /*yield*/, resp.text()];
                    case 2: throw new (_a.apply(resolutionError_1.default, _b.concat([(_c.providerMessage = _d.sent(),
                            _c.method = 'UDAPI',
                            _c.methodName = 'tokenURIMetadata',
                            _c)])))();
                }
            });
        });
    };
    Resolution.prototype.getDnsRecordKeys = function (types) {
        var records = ['dns.ttl'];
        types.forEach(function (type) {
            records.push("dns.".concat(type));
            records.push("dns.".concat(type, ".ttl"));
        });
        return records;
    };
    Resolution.prototype.getPreferableNewRecord = function (domain, newRecord, oldRecord) {
        return __awaiter(this, void 0, void 0, function () {
            var records;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.records(domain, [newRecord, oldRecord])];
                    case 1:
                        records = _a.sent();
                        if (!records[newRecord] && !records[oldRecord]) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                                recordName: newRecord,
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, records[newRecord] || records[oldRecord]];
                }
            });
        });
    };
    Resolution.prototype.callServiceForDomain = function (domain, func) {
        return __awaiter(this, void 0, void 0, function () {
            var serviceName, servicePromises, _i, servicePromises_1, servicePromise, serviceCallResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        serviceName = (0, utils_1.findNamingServiceName)(domain);
                        if (!serviceName) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                                domain: domain,
                            });
                        }
                        servicePromises = this.serviceMap[serviceName].usedServices.map(function (service) { return (0, utils_1.wrapResult)(function () { return func(service); }); });
                        _i = 0, servicePromises_1 = servicePromises;
                        _a.label = 1;
                    case 1:
                        if (!(_i < servicePromises_1.length)) return [3 /*break*/, 4];
                        servicePromise = servicePromises_1[_i];
                        return [4 /*yield*/, servicePromise];
                    case 2:
                        serviceCallResult = _a.sent();
                        if (serviceCallResult.error !== null) {
                            if (!(serviceCallResult.error instanceof resolutionError_1.default &&
                                serviceCallResult.error.code ===
                                    resolutionError_1.ResolutionErrorCode.UnregisteredDomain)) {
                                throw serviceCallResult.error;
                            }
                        }
                        else {
                            return [2 /*return*/, serviceCallResult.result];
                        }
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                        domain: domain,
                    });
                }
            });
        });
    };
    // Expects that a called method never throws the `ResolutionErrorCode.UnregisteredDomain` (it doesn't handle it).
    Resolution.prototype.callServiceForDomainBoolean = function (domain, func, options) {
        return __awaiter(this, void 0, void 0, function () {
            var serviceName, servicePromises, _i, servicePromises_2, servicePromise, _a, result, error;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        serviceName = (0, utils_1.findNamingServiceName)(domain);
                        if (!serviceName) {
                            if (!options.throwIfUnsupportedDomain) {
                                return [2 /*return*/, !options.expectedValue];
                            }
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                                domain: domain,
                            });
                        }
                        servicePromises = this.serviceMap[serviceName].usedServices.map(function (service) { return (0, utils_1.wrapResult)(function () { return func(service); }); });
                        _i = 0, servicePromises_2 = servicePromises;
                        _b.label = 1;
                    case 1:
                        if (!(_i < servicePromises_2.length)) return [3 /*break*/, 4];
                        servicePromise = servicePromises_2[_i];
                        return [4 /*yield*/, servicePromise];
                    case 2:
                        _a = _b.sent(), result = _a.result, error = _a.error;
                        if (error) {
                            if (!(error instanceof resolutionError_1.default &&
                                error.code === resolutionError_1.ResolutionErrorCode.UnregisteredDomain)) {
                                throw error;
                            }
                        }
                        else if (result === options.expectedValue) {
                            // If the result is not the one which is expected, we don't want to return it immediately.
                            return [2 /*return*/, result];
                        }
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, !options.expectedValue];
                }
            });
        });
    };
    Resolution.prototype.reverseGetTokenId = function (address, location) {
        return __awaiter(this, void 0, void 0, function () {
            var service, tokenId;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        service = this.serviceMap['UNS'].native;
                        return [4 /*yield*/, service.reverseOf(address, location)];
                    case 1:
                        tokenId = _a.sent();
                        return [2 /*return*/, tokenId];
                }
            });
        });
    };
    return Resolution;
}());
Resolution$1.Resolution = Resolution;
Resolution$1.default = Resolution;
function isApi(obj) {
    return obj && obj.api;
}

(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ProviderFactories = exports.Eip1193Factories = exports.Eip1993Factories = exports.DnsRecordsErrorCode = exports.DnsRecordsError = exports.ConfigurationErrorCode = exports.ConfigurationError = exports.ResolutionErrorCode = exports.ResolutionError = exports.DnsUtils = exports.default = exports.Resolution = void 0;
	var Resolution_1 = Resolution$1;
	Object.defineProperty(exports, "Resolution", { enumerable: true, get: function () { return Resolution_1.Resolution; } });
	Object.defineProperty(exports, "default", { enumerable: true, get: function () { return Resolution_1.Resolution; } });
	__exportStar(publicTypes, exports);
	var DnsUtils_1 = DnsUtils$1;
	Object.defineProperty(exports, "DnsUtils", { enumerable: true, get: function () { return __importDefault(DnsUtils_1).default; } });
	var resolutionError_1 = resolutionError;
	Object.defineProperty(exports, "ResolutionError", { enumerable: true, get: function () { return resolutionError_1.ResolutionError; } });
	Object.defineProperty(exports, "ResolutionErrorCode", { enumerable: true, get: function () { return resolutionError_1.ResolutionErrorCode; } });
	var configurationError_1 = configurationError;
	Object.defineProperty(exports, "ConfigurationError", { enumerable: true, get: function () { return configurationError_1.ConfigurationError; } });
	Object.defineProperty(exports, "ConfigurationErrorCode", { enumerable: true, get: function () { return configurationError_1.ConfigurationErrorCode; } });
	var dnsRecordsError_1 = dnsRecordsError;
	Object.defineProperty(exports, "DnsRecordsError", { enumerable: true, get: function () { return dnsRecordsError_1.DnsRecordsError; } });
	Object.defineProperty(exports, "DnsRecordsErrorCode", { enumerable: true, get: function () { return dnsRecordsError_1.DnsRecordsErrorCode; } });
	var Eip1993Factories_1 = Eip1993Factories;
	Object.defineProperty(exports, "Eip1993Factories", { enumerable: true, get: function () { return Eip1993Factories_1.Eip1993Factories; } });
	var Eip1993Factories_2 = Eip1993Factories;
	Object.defineProperty(exports, "Eip1193Factories", { enumerable: true, get: function () { return Eip1993Factories_2.Eip1993Factories; } });
	var Eip1993Factories_3 = Eip1993Factories;
	Object.defineProperty(exports, "ProviderFactories", { enumerable: true, get: function () { return Eip1993Factories_3.Eip1993Factories; } });
} (build));

const ethersProviders = {};
function getProvider(chain) {
    if (!chain)
        return null;
    if (!ethersProviders[chain.rpcUrl]) {
        ethersProviders[chain.rpcUrl] = new providers.StaticJsonRpcProvider(chain.providerConnectionInfo && chain.providerConnectionInfo.url
            ? chain.providerConnectionInfo
            : chain.rpcUrl);
    }
    return ethersProviders[chain.rpcUrl];
}
function requestAccounts(provider) {
    const args = { method: 'eth_requestAccounts' };
    return provider.request(args);
}
function selectAccounts(provider) {
    const args = { method: 'eth_selectAccounts' };
    return provider.request(args);
}
function getChainId(provider) {
    return provider.request({ method: 'eth_chainId' });
}
function listenAccountsChanged(args) {
    const { provider, disconnected$ } = args;
    const addHandler = (handler) => {
        provider.on('accountsChanged', handler);
    };
    const removeHandler = (handler) => {
        provider.removeListener('accountsChanged', handler);
    };
    return fromEventPattern(addHandler, removeHandler).pipe(takeUntil(disconnected$));
}
function listenChainChanged(args) {
    const { provider, disconnected$ } = args;
    const addHandler = (handler) => {
        provider.on('chainChanged', handler);
    };
    const removeHandler = (handler) => {
        provider.removeListener('chainChanged', handler);
    };
    return fromEventPattern(addHandler, removeHandler).pipe(takeUntil(disconnected$));
}
function trackWallet(provider, label) {
    const disconnected$ = disconnectWallet$.pipe(filter(wallet => wallet === label), take(1));
    const accountsChanged$ = listenAccountsChanged({
        provider,
        disconnected$
    }).pipe(share());
    // when account changed, set it to first account and subscribe to events
    accountsChanged$.subscribe(async ([address]) => {
        // sync accounts with internal state
        // in the case of an account has been manually disconnected
        try {
            await syncWalletConnectedAccounts(label);
        }
        catch (error) {
            console.warn('Web3Onboard: Error whilst trying to sync connected accounts:', error);
        }
        // no address, then no account connected, so disconnect wallet
        // this could happen if user locks wallet,
        // or if disconnects app from wallet
        if (!address) {
            disconnect({ label });
            return;
        }
        const { wallets } = state.get();
        const { accounts } = wallets.find(wallet => wallet.label === label);
        const [[existingAccount], restAccounts] = partition(accounts, account => account.address === address);
        // update accounts without ens/uns and balance first
        updateWallet(label, {
            accounts: [
                existingAccount || {
                    address: address,
                    ens: null,
                    uns: null,
                    balance: null
                },
                ...restAccounts
            ]
        });
        // if not existing account and notifications,
        // then subscribe to transaction events
        if (state.get().notify.enabled && !existingAccount) {
            const sdk = await getBNMulitChainSdk();
            if (sdk) {
                const wallet = state
                    .get()
                    .wallets.find(wallet => wallet.label === label);
                try {
                    sdk.subscribe({
                        id: address,
                        chainId: wallet.chains[0].id,
                        type: 'account'
                    });
                }
                catch (error) {
                    // unsupported network for transaction events
                }
            }
        }
    });
    // also when accounts change, update Balance and ENS/UNS
    accountsChanged$
        .pipe(switchMap(async ([address]) => {
        if (!address)
            return;
        const { wallets, chains } = state.get();
        const { chains: walletChains, accounts } = wallets.find(wallet => wallet.label === label);
        const [connectedWalletChain] = walletChains;
        const chain = chains.find(({ namespace, id }) => namespace === 'evm' && id === connectedWalletChain.id);
        const balanceProm = getBalance(address, chain);
        const account = accounts.find(account => account.address === address);
        const ensProm = account && account.ens
            ? Promise.resolve(account.ens)
            : validEnsChain(connectedWalletChain.id)
                ? getEns(address, chain)
                : Promise.resolve(null);
        const unsProm = account && account.uns
            ? Promise.resolve(account.uns)
            : getUns(address, chain);
        return Promise.all([
            Promise.resolve(address),
            balanceProm,
            ensProm,
            unsProm
        ]);
    }))
        .subscribe(res => {
        if (!res)
            return;
        const [address, balance, ens, uns] = res;
        updateAccount(label, address, { balance, ens, uns });
    });
    const chainChanged$ = listenChainChanged({ provider, disconnected$ }).pipe(share());
    // Update chain on wallet when chainId changed
    chainChanged$.subscribe(async (chainId) => {
        const { wallets } = state.get();
        const { chains, accounts } = wallets.find(wallet => wallet.label === label);
        const [connectedWalletChain] = chains;
        if (chainId === connectedWalletChain.id)
            return;
        if (state.get().notify.enabled) {
            const sdk = await getBNMulitChainSdk();
            if (sdk) {
                const wallet = state
                    .get()
                    .wallets.find(wallet => wallet.label === label);
                // Unsubscribe with timeout of 60 seconds
                // to allow for any currently inflight transactions
                wallet.accounts.forEach(({ address }) => {
                    sdk.unsubscribe({
                        id: address,
                        chainId: wallet.chains[0].id,
                        timeout: 60000
                    });
                });
                // resubscribe for new chainId
                wallet.accounts.forEach(({ address }) => {
                    try {
                        sdk.subscribe({
                            id: address,
                            chainId: chainId,
                            type: 'account'
                        });
                    }
                    catch (error) {
                        // unsupported network for transaction events
                    }
                });
            }
        }
        const resetAccounts = accounts.map(({ address }) => ({
            address,
            ens: null,
            uns: null,
            balance: null
        }));
        updateWallet(label, {
            chains: [{ namespace: 'evm', id: chainId }],
            accounts: resetAccounts
        });
    });
    // when chain changes get ens/uns and balance for each account for wallet
    chainChanged$
        .pipe(switchMap(async (chainId) => {
        const { wallets, chains } = state.get();
        const { accounts } = wallets.find(wallet => wallet.label === label);
        const chain = chains.find(({ namespace, id }) => namespace === 'evm' && id === chainId);
        return Promise.all(accounts.map(async ({ address }) => {
            const balanceProm = getBalance(address, chain);
            const ensProm = validEnsChain(chainId)
                ? getEns(address, chain)
                : Promise.resolve(null);
            const unsProm = validEnsChain(chainId)
                ? getUns(address, chain)
                : Promise.resolve(null);
            const [balance, ens, uns] = await Promise.all([
                balanceProm,
                ensProm,
                unsProm
            ]);
            return {
                address,
                balance,
                ens,
                uns
            };
        }));
    }))
        .subscribe(updatedAccounts => {
        updatedAccounts && updateWallet(label, { accounts: updatedAccounts });
    });
    disconnected$.subscribe(() => {
        provider.disconnect && provider.disconnect();
    });
}
async function getEns(address, chain) {
    // chain we don't recognize and don't have a rpcUrl for requests
    if (!chain)
        return null;
    const provider = getProvider(chain);
    try {
        const name = await provider.lookupAddress(address);
        let ens = null;
        if (name) {
            const resolver = await provider.getResolver(name);
            if (resolver) {
                const [contentHash, avatar] = await Promise.all([
                    resolver.getContentHash(),
                    resolver.getAvatar()
                ]);
                const getText = resolver.getText.bind(resolver);
                ens = {
                    name,
                    avatar,
                    contentHash,
                    getText
                };
            }
        }
        return ens;
    }
    catch (error) {
        console.error(error);
        return null;
    }
}
async function getUns(address, chain) {
    // check if address is valid ETH address before attempting to resolve
    // chain we don't recognize and don't have a rpcUrl for requests
    if (!utils$o.isAddress(address) || !chain)
        return null;
    const resolutionInstance = new build.Resolution();
    try {
        const name = await resolutionInstance.reverse(address);
        let uns = null;
        if (name) {
            uns = {
                name
            };
        }
        return uns;
    }
    catch (error) {
        console.error(error);
        return null;
    }
}
async function getBalance(address, chain) {
    // chain we don't recognize and don't have a rpcUrl for requests
    if (!chain)
        return null;
    const { wallets } = state.get();
    try {
        const wallet = wallets.find(wallet => !!wallet.provider);
        const provider = wallet.provider;
        const balanceHex = await provider.request({
            method: 'eth_getBalance',
            params: [address, 'latest']
        });
        return balanceHex ? { [chain.token || 'eth']: weiToEth(balanceHex) } : null;
    }
    catch (error) {
        console.error(error);
        return null;
    }
}
function switchChain(provider, chainId) {
    return provider.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId }]
    });
}
function addNewChain(provider, chain) {
    return provider.request({
        method: 'wallet_addEthereumChain',
        params: [
            {
                chainId: chain.id,
                chainName: chain.label,
                nativeCurrency: {
                    name: chain.label,
                    symbol: chain.token,
                    decimals: 18
                },
                rpcUrls: [chain.publicRpcUrl || chain.rpcUrl],
                blockExplorerUrls: chain.blockExplorerUrl
                    ? [chain.blockExplorerUrl]
                    : undefined
            }
        ]
    });
}
async function getPermissions(provider) {
    try {
        const permissions = (await provider.request({
            method: 'wallet_getPermissions'
        }));
        return Array.isArray(permissions) ? permissions : [];
    }
    catch (error) {
        return [];
    }
}
async function syncWalletConnectedAccounts(label) {
    const wallet = state.get().wallets.find(wallet => wallet.label === label);
    const permissions = await getPermissions(wallet.provider);
    const accountsPermissions = permissions.find(({ parentCapability }) => parentCapability === 'eth_accounts');
    if (accountsPermissions) {
        const { value: connectedAccounts } = accountsPermissions.caveats.find(({ type }) => type === 'restrictReturnedAccounts') || { value: null };
        if (connectedAccounts) {
            const syncedAccounts = wallet.accounts.filter(({ address }) => connectedAccounts.includes(address));
            updateWallet(wallet.label, { ...wallet, accounts: syncedAccounts });
        }
    }
}

async function updateBalances(addresses) {
    const { wallets, chains } = state.get();
    const updatedWallets = await Promise.all(wallets.map(async (wallet) => {
        const chain = chains.find(({ id }) => id === wallet.chains[0].id);
        const updatedAccounts = await Promise.all(wallet.accounts.map(async (account) => {
            // if no provided addresses, we want to update all balances
            // otherwise check if address is in addresses array
            if (!addresses ||
                addresses.some(address => address.toLowerCase() === account.address.toLowerCase())) {
                const updatedBalance = await getBalance(account.address, chain);
                return { ...account, balance: updatedBalance };
            }
            return account;
        }));
        return { ...wallet, accounts: updatedAccounts };
    }));
    updateAllWallets(updatedWallets);
}

function handleTransactionUpdates(transaction) {
    const customized = state.get().notify.transactionHandler(transaction);
    const invalid = validateTransactionHandlerReturn(customized);
    if (invalid) {
        throw invalid;
    }
    if (transaction.eventCode === 'txConfirmed') {
        updateBalances([transaction.watchedAddress, transaction.counterparty]);
    }
    const notification = transactionEventToNotification(transaction, customized);
    addNotification(notification);
    updateTransaction(transaction);
}
function transactionEventToNotification(transaction, customization) {
    const { id, hash, startTime, eventCode, direction, counterparty, value, asset, network } = transaction;
    const type = eventToType(eventCode);
    const key = `${id || hash}-${(typeof customization === 'object' && customization.eventCode) || eventCode}`;
    const counterpartyShortened = counterparty &&
        counterparty.substring(0, 4) +
            '...' +
            counterparty.substring(counterparty.length - 4);
    const formattedValue = new BigNumber$1(value || 0)
        .div(new BigNumber$1('1000000000000000000'))
        .toString(10);
    const formatterOptions = counterparty && value
        ? {
            messageId: `notify.watched['${eventCode}']`,
            values: {
                verb: eventCode === 'txConfirmed'
                    ? direction === 'incoming'
                        ? 'received'
                        : 'sent'
                    : direction === 'incoming'
                        ? 'receiving'
                        : 'sending',
                formattedValue,
                preposition: direction === 'incoming' ? 'from' : 'to',
                counterpartyShortened,
                asset
            }
        }
        : {
            messageId: `notify.transaction['${eventCode}']`,
            values: { formattedValue, asset }
        };
    const formatter = get$1(_);
    const notificationDefaultMessages = en.notify;
    const typeKey = counterparty
        ? 'watched'
        : 'transaction';
    const notificationMessageType = notificationDefaultMessages[typeKey];
    const defaultMessage = notificationMessageType[eventCode];
    const message = formatter(formatterOptions.messageId, {
        values: formatterOptions.values,
        default: defaultMessage
    });
    let notification = {
        id: id || hash,
        type,
        key,
        network,
        startTime: startTime || Date.now(),
        eventCode,
        message,
        autoDismiss: typeToDismissTimeout((typeof customization === 'object' && customization.type) || type)
    };
    if (typeof customization === 'object') {
        notification = { ...notification, ...customization };
    }
    return notification;
}
function eventToType(eventCode) {
    switch (eventCode) {
        case 'txSent':
        case 'txPool':
            return 'pending';
        case 'txSpeedUp':
        case 'txCancel':
        case 'txRequest':
        case 'txRepeat':
        case 'txAwaitingApproval':
        case 'txConfirmReminder':
        case 'txStuck':
            return 'hint';
        case 'txError':
        case 'txSendFail':
        case 'txFailed':
        case 'txDropped':
        case 'nsfFail':
        case 'txUnderpriced':
            return 'error';
        case 'txConfirmed':
            return 'success';
        default:
            return 'hint';
    }
}
function typeToDismissTimeout(type) {
    switch (type) {
        case 'success':
        case 'hint':
            return 4000;
        default:
            return 0;
    }
}

let blocknativeMultiChainSdk;
let blocknativeSdk;
/**
 *
 * @returns MultiChain SDK if apiKey
 */
async function getBNMulitChainSdk() {
    const { apiKey } = configuration;
    if (!apiKey)
        return null;
    if (!blocknativeMultiChainSdk) {
        const { default: Blocknative } = await import('bnc-sdk');
        blocknativeMultiChainSdk = Blocknative.multichain({
            apiKey: configuration.apiKey
        });
        blocknativeMultiChainSdk.transactions$.subscribe(handleTransactionUpdates);
    }
    return blocknativeMultiChainSdk;
}
/**
 *
 * @returns SDK if apiKey
 */
async function getBlocknativeSdk() {
    const { apiKey } = configuration;
    if (!apiKey)
        return null;
    if (!blocknativeSdk) {
        const { default: Blocknative } = await import('bnc-sdk');
        blocknativeSdk = new Blocknative({
            dappId: configuration.apiKey,
            networkId: 1
        });
        return blocknativeSdk;
    }
    return blocknativeSdk;
}

async function disconnect(options) {
    const error = validateDisconnectOptions(options);
    if (error) {
        throw error;
    }
    const { label } = options;
    if (state.get().notify.enabled) {
        // handle unwatching addresses
        const sdk = await getBNMulitChainSdk();
        if (sdk) {
            const wallet = state.get().wallets.find(wallet => wallet.label === label);
            wallet.accounts.forEach(({ address }) => {
                sdk.unsubscribe({
                    id: address,
                    chainId: wallet.chains[0].id,
                    timeout: 60000
                });
            });
        }
    }
    disconnectWallet$.next(label);
    removeWallet(label);
    return state.get().wallets;
}

async function setChain(options) {
    const error = validateSetChainOptions(options);
    if (error) {
        throw error;
    }
    const { wallets, chains } = state.get();
    const { chainId, chainNamespace = 'evm', wallet: walletToSet } = options;
    const chainIdHex = toHexString(chainId);
    // validate that chainId has been added to chains
    const chain = chains.find(({ namespace, id }) => namespace === chainNamespace && id === chainIdHex);
    if (!chain) {
        throw new Error(`Chain with chainId: ${chainId} and chainNamespace: ${chainNamespace} has not been set and must be added when Onboard is initialized.`);
    }
    const wallet = walletToSet
        ? wallets.find(({ label }) => label === walletToSet)
        : wallets[0];
    // validate a wallet is connected
    if (!wallet) {
        throw new Error(walletToSet
            ? `Wallet with label ${walletToSet} is not connected`
            : 'A wallet must be connected before a chain can be set');
    }
    const [walletConnectedChain] = wallet.chains;
    // check if wallet is already connected to chainId
    if (walletConnectedChain.namespace === chainNamespace &&
        walletConnectedChain.id === chainIdHex) {
        return true;
    }
    try {
        await switchChain(wallet.provider, chainIdHex);
        return true;
    }
    catch (error) {
        const { code } = error;
        const switchChainModalClosed$ = switchChainModal$.pipe(filter(x => x === null), map(() => false));
        if (code === ProviderRpcErrorCode.CHAIN_NOT_ADDED ||
            code === ProviderRpcErrorCode.UNRECOGNIZED_CHAIN_ID) {
            // chain has not been added to wallet
            return chainNotInWallet(wallet, chain, switchChainModalClosed$, chainIdHex);
        }
        if (code === ProviderRpcErrorCode.UNSUPPORTED_METHOD) {
            // method not supported
            switchChainModal$.next({ chain });
            return firstValueFrom(switchChainModalClosed$);
        }
    }
    return false;
}
const chainNotInWallet = async (wallet, chain, switchChainModalClosed$, chainIdHex) => {
    try {
        await addNewChain(wallet.provider, chain);
        await switchChain(wallet.provider, chainIdHex);
        return true;
    }
    catch (error) {
        const { code } = error;
        if (code === ProviderRpcErrorCode.ACCOUNT_ACCESS_REJECTED) {
            // add new chain rejected by user
            return false;
        }
        // display notification to user to switch chain
        switchChainModal$.next({ chain });
        return firstValueFrom(switchChainModalClosed$);
    }
};

function initialize(options) {
    if (options) {
        const { en: customizedEn } = options;
        const merged = merge(en, customizedEn || {});
        addMessages('en', merged);
        const customLocales = Object.keys(options).filter(key => key !== 'en');
        // Sync register all customLocales
        customLocales.forEach(locale => {
            const dictionary = options[locale];
            dictionary && addMessages(locale, dictionary);
        });
    }
    else {
        addMessages('en', en);
    }
    init$2({
        fallbackLocale: 'en',
        initialLocale: getLocaleFromNavigator()
    });
}

var closeIcon = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z" fill="currentColor"/>
  </svg>
`;

/* src/views/shared/CloseButton.svelte generated by Svelte v3.55.1 */

function add_css$i(target) {
	append_styles(target, "svelte-1bxilce", ".close-button.svelte-1bxilce{padding:0.25rem;border-radius:40px;color:var(\n      --onboard-close-button-color,\n      var(--onboard-gray-300, var(--gray-300))\n    )}");
}

function create_fragment$i(ctx) {
	let div2;
	let div1;
	let div0;
	let div1_style_value;

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			attr(div0, "class", "flex items-center");
			set_style(div0, "width", /*width*/ ctx[0]);
			attr(div1, "class", "close-button flex justify-center items-center svelte-1bxilce");
			attr(div1, "style", div1_style_value = `background:${/*backgroundColor*/ ctx[1]}`);
			attr(div2, "class", "flex justify-center items-center pointer");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, div0);
			div0.innerHTML = closeIcon;
		},
		p(ctx, [dirty]) {
			if (dirty & /*width*/ 1) {
				set_style(div0, "width", /*width*/ ctx[0]);
			}

			if (dirty & /*backgroundColor*/ 2 && div1_style_value !== (div1_style_value = `background:${/*backgroundColor*/ ctx[1]}`)) {
				attr(div1, "style", div1_style_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let { width = '24px' } = $$props;

	let { backgroundColor = `var(
      --onboard-close-button-background,
      var(--onboard-gray-100, var(--gray-100))
    );` } = $$props;

	$$self.$$set = $$props => {
		if ('width' in $$props) $$invalidate(0, width = $$props.width);
		if ('backgroundColor' in $$props) $$invalidate(1, backgroundColor = $$props.backgroundColor);
	};

	return [width, backgroundColor];
}

class CloseButton extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$i, create_fragment$i, safe_not_equal, { width: 0, backgroundColor: 1 }, add_css$i);
	}
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}
function quartOut(t) {
    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;
}

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}

/* src/views/shared/Modal.svelte generated by Svelte v3.55.1 */

function add_css$h(target) {
	append_styles(target, "svelte-b2sy1m", "section.svelte-b2sy1m{top:0;left:0;pointer-events:none;z-index:var(--onboard-modal-z-index, var(--modal-z-index))}.background.svelte-b2sy1m{width:100vw;height:100vh;background:var(--onboard-modal-backdrop, var(--modal-backdrop));pointer-events:all}.max-height.svelte-b2sy1m{max-height:calc(100vh - 2rem)}.modal-position.svelte-b2sy1m{top:var(--onboard-modal-top, var(--modal-top));bottom:var(--onboard-modal-bottom, var(--modal-bottom));left:var(--onboard-modal-left, var(--modal-left));right:var(--onboard-modal-right, var(--modal-right))}.modal-overflow.svelte-b2sy1m{overflow:hidden}.modal-styling.svelte-b2sy1m{border-radius:var(--onboard-modal-border-radius, var(--border-radius-1))\n      var(--onboard-modal-border-radius, var(--border-radius-1)) 0 0;box-shadow:var(--onboard-modal-box-shadow, var(--box-shadow-0))}.modal.svelte-b2sy1m{overflow-y:auto;background:var(--onboard-modal-background, white);color:var(--onboard-modal-color, initial);max-width:100vw}.modal-container-mobile.svelte-b2sy1m{bottom:0}@media all and (min-width: 768px){.modal-styling.svelte-b2sy1m{border-radius:var(--onboard-modal-border-radius, var(--border-radius-1))}.modal-container-mobile.svelte-b2sy1m{bottom:unset;margin:1rem}}");
}

function create_fragment$h(ctx) {
	let section;
	let div4;
	let div3;
	let div2;
	let div1;
	let div0;
	let section_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			section = element("section");
			div4 = element("div");
			div3 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "modal relative svelte-b2sy1m");
			attr(div1, "class", "modal-overflow modal-styling relative flex justify-center svelte-b2sy1m");
			attr(div2, "class", "flex relative max-height svelte-b2sy1m");
			attr(div3, "class", "modal-container-mobile modal-position flex absolute svelte-b2sy1m");
			attr(div4, "class", "background flex items-center justify-center relative svelte-b2sy1m");
			attr(section, "class", "fixed svelte-b2sy1m");
		},
		m(target, anchor) {
			insert(target, section, anchor);
			append(section, div4);
			append(div4, div3);
			append(div3, div2);
			append(div2, div1);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div2, "click", stop_propagation(/*click_handler*/ ctx[3])),
					listen(div4, "click", function () {
						if (is_function(/*close*/ ctx[0])) /*close*/ ctx[0].apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!section_transition) section_transition = create_bidirectional_transition(section, fade, {}, true);
				section_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			if (!section_transition) section_transition = create_bidirectional_transition(section, fade, {}, false);
			section_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(section);
			if (default_slot) default_slot.d(detaching);
			if (detaching && section_transition) section_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const html = document.documentElement;

	onMount(() => {
		html.style.position = 'sticky';
		html.style.overflow = 'hidden';
	});

	onDestroy(() => {
		html.style.position = '';
		html.style.removeProperty('overflow');
	});

	let { close } = $$props;

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('close' in $$props) $$invalidate(0, close = $$props.close);
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [close, $$scope, slots, click_handler];
}

class Modal extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$h, create_fragment$h, safe_not_equal, { close: 0 }, add_css$h);
	}
}

/* src/views/connect/Agreement.svelte generated by Svelte v3.55.1 */

function add_css$g(target) {
	append_styles(target, "svelte-tz7ru1", ".container.svelte-tz7ru1{padding:var(--onboard-spacing-4, var(--spacing-4));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:24px}input.svelte-tz7ru1{height:1rem;width:1rem;margin-right:0.5rem}");
}

// (39:0) {#if showTermsOfService}
function create_if_block$a(ctx) {
	let div;
	let label;
	let input;
	let t0;
	let span;
	let t1_value = /*$_*/ ctx[1]('connect.selectingWallet.agreement.agree') + "";
	let t1;
	let t2;
	let t3_value = ' ' + "";
	let t3;
	let t4;
	let t5;
	let mounted;
	let dispose;
	let if_block0 = /*termsUrl*/ ctx[2] && create_if_block_2$4(ctx);
	let if_block1 = /*privacyUrl*/ ctx[3] && create_if_block_1$4(ctx);

	return {
		c() {
			div = element("div");
			label = element("label");
			input = element("input");
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			t3 = text(t3_value);
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			if (if_block1) if_block1.c();
			attr(input, "class", " svelte-tz7ru1");
			attr(input, "type", "checkbox");
			attr(label, "class", "flex");
			attr(div, "class", "container flex items-center svelte-tz7ru1");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label);
			append(label, input);
			input.checked = /*agreed*/ ctx[0];
			append(label, t0);
			append(label, span);
			append(span, t1);
			append(span, t2);
			append(span, t3);
			append(span, t4);
			if (if_block0) if_block0.m(span, null);
			append(span, t5);
			if (if_block1) if_block1.m(span, null);

			if (!mounted) {
				dispose = listen(input, "change", /*input_change_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*agreed*/ 1) {
				input.checked = /*agreed*/ ctx[0];
			}

			if (dirty & /*$_*/ 2 && t1_value !== (t1_value = /*$_*/ ctx[1]('connect.selectingWallet.agreement.agree') + "")) set_data(t1, t1_value);
			if (/*termsUrl*/ ctx[2]) if_block0.p(ctx, dirty);
			if (/*privacyUrl*/ ctx[3]) if_block1.p(ctx, dirty);
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (46:8) {#if termsUrl}
function create_if_block_2$4(ctx) {
	let a;
	let t0_value = /*$_*/ ctx[1]('connect.selectingWallet.agreement.terms') + "";
	let t0;

	let t1_value = (/*privacyUrl*/ ctx[3]
	? ' ' + /*$_*/ ctx[1]('connect.selectingWallet.agreement.and') + ' '
	: '.') + "";

	let t1;

	return {
		c() {
			a = element("a");
			t0 = text(t0_value);
			t1 = text(t1_value);
			attr(a, "href", /*termsUrl*/ ctx[2]);
			attr(a, "target", "_blank");
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, t0);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]('connect.selectingWallet.agreement.terms') + "")) set_data(t0, t0_value);

			if (dirty & /*$_*/ 2 && t1_value !== (t1_value = (/*privacyUrl*/ ctx[3]
			? ' ' + /*$_*/ ctx[1]('connect.selectingWallet.agreement.and') + ' '
			: '.') + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(a);
			if (detaching) detach(t1);
		}
	};
}

// (52:8) {#if privacyUrl}
function create_if_block_1$4(ctx) {
	let a;
	let t0_value = /*$_*/ ctx[1]('connect.selectingWallet.agreement.privacy') + "";
	let t0;
	let t1;

	return {
		c() {
			a = element("a");
			t0 = text(t0_value);
			t1 = text(".");
			attr(a, "href", /*privacyUrl*/ ctx[3]);
			attr(a, "target", "_blank");
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, t0);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 2 && t0_value !== (t0_value = /*$_*/ ctx[1]('connect.selectingWallet.agreement.privacy') + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(a);
			if (detaching) detach(t1);
		}
	};
}

function create_fragment$g(ctx) {
	let if_block_anchor;
	let if_block = /*showTermsOfService*/ ctx[4] && create_if_block$a(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*showTermsOfService*/ ctx[4]) if_block.p(ctx, dirty);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(1, $_ = $$value));
	let { agreed } = $$props;
	const { terms: termsAgreed, privacy: privacyAgreed, version: versionAgreed } = JSON.parse(localStorage.getItem(STORAGE_KEYS.TERMS_AGREEMENT) || '{}');

	const blankAgreement = {
		termsUrl: '',
		privacyUrl: '',
		version: ''
	};

	const { appMetadata } = configuration;
	const { termsUrl, privacyUrl, version } = appMetadata && appMetadata.agreement || blankAgreement;
	const showTermsOfService = !!(termsUrl && !termsAgreed || privacyUrl && !privacyAgreed || version && version !== versionAgreed);
	agreed = !showTermsOfService;

	function input_change_handler() {
		agreed = this.checked;
		$$invalidate(0, agreed);
	}

	$$self.$$set = $$props => {
		if ('agreed' in $$props) $$invalidate(0, agreed = $$props.agreed);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*agreed*/ 1) {
			if (agreed) {
				localStorage.setItem(STORAGE_KEYS.TERMS_AGREEMENT, JSON.stringify({
					version,
					terms: !!termsUrl,
					privacy: !!privacyUrl
				}));
			} else if (agreed === false) {
				localStorage.removeItem(STORAGE_KEYS.TERMS_AGREEMENT);
			}
		}
	};

	return [agreed, $_, termsUrl, privacyUrl, showTermsOfService, input_change_handler];
}

class Agreement extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$g, create_fragment$g, safe_not_equal, { agreed: 0 }, add_css$g);
	}
}

/* src/views/shared/PendingStatusIcon.svelte generated by Svelte v3.55.1 */

function add_css$f(target) {
	append_styles(target, "svelte-2btye1", ".icon.svelte-2btye1{color:var(--onboard-white, var(--white));border-radius:50px;bottom:-0.25rem;right:-0.25rem}.yellow.svelte-2btye1{background:var(--onboard-warning-500, var(--warning-500))}");
}

function create_fragment$f(ctx) {
	let div;
	let div_class_value;
	let div_style_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = "" + (null_to_empty(`${/*className*/ ctx[2]} icon flex absolute`) + " svelte-2btye1"));
			attr(div, "style", div_style_value = `width: ${/*size*/ ctx[0]}px; height: ${/*size*/ ctx[0]}px; padding: ${/*size*/ ctx[0] / 6}px;`);
			toggle_class(div, "yellow", /*color*/ ctx[1] === 'yellow');
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = pendingIcon;
		},
		p(ctx, [dirty]) {
			if (dirty & /*className*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(`${/*className*/ ctx[2]} icon flex absolute`) + " svelte-2btye1"))) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*size*/ 1 && div_style_value !== (div_style_value = `width: ${/*size*/ ctx[0]}px; height: ${/*size*/ ctx[0]}px; padding: ${/*size*/ ctx[0] / 6}px;`)) {
				attr(div, "style", div_style_value);
			}

			if (dirty & /*className, color*/ 6) {
				toggle_class(div, "yellow", /*color*/ ctx[1] === 'yellow');
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = 'yellow' } = $$props;
	let { class: className = 'test' } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
		if ('class' in $$props) $$invalidate(2, className = $$props.class);
	};

	return [size, color, className];
}

class PendingStatusIcon extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$f, create_fragment$f, safe_not_equal, { size: 0, color: 1, class: 2 }, add_css$f);
	}
}

/* src/views/shared/SuccessStatusIcon.svelte generated by Svelte v3.55.1 */

function add_css$e(target) {
	append_styles(target, "svelte-1bikw7k", ".icon.svelte-1bikw7k{color:var(--onboard-white, var(--white));border-radius:50px}.green.svelte-1bikw7k{background:var(--onboard-success-600, var(--success-600))}.blue.svelte-1bikw7k{background:var(--onboard-primary-1, var(--primary-1))}");
}

function create_fragment$e(ctx) {
	let div;
	let div_style_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", "icon flex svelte-1bikw7k");
			attr(div, "style", div_style_value = `width: ${/*size*/ ctx[0]}px; height: ${/*size*/ ctx[0]}px; padding: ${/*size*/ ctx[0] / 5}px;`);
			toggle_class(div, "green", /*color*/ ctx[1] === 'green');
			toggle_class(div, "blue", /*color*/ ctx[1] === 'blue');
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = successIcon;
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1 && div_style_value !== (div_style_value = `width: ${/*size*/ ctx[0]}px; height: ${/*size*/ ctx[0]}px; padding: ${/*size*/ ctx[0] / 5}px;`)) {
				attr(div, "style", div_style_value);
			}

			if (dirty & /*color*/ 2) {
				toggle_class(div, "green", /*color*/ ctx[1] === 'green');
			}

			if (dirty & /*color*/ 2) {
				toggle_class(div, "blue", /*color*/ ctx[1] === 'blue');
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { size } = $$props;
	let { color = 'green' } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [size, color];
}

class SuccessStatusIcon extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$e, create_fragment$e, safe_not_equal, { size: 0, color: 1 }, add_css$e);
	}
}

/* src/views/shared/Spinner.svelte generated by Svelte v3.55.1 */

function add_css$d(target) {
	append_styles(target, "svelte-1le5672", ".loading-container.svelte-1le5672.svelte-1le5672{font-family:inherit;font-size:inherit;color:inherit}span.svelte-1le5672.svelte-1le5672{font-family:inherit;font-size:0.889em;margin-top:1rem}.loading.svelte-1le5672.svelte-1le5672{display:inline-block}.loading.svelte-1le5672 div.svelte-1le5672{font-size:inherit;display:block;position:absolute;border:3px solid;border-radius:50%;animation:svelte-1le5672-bn-loading 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:currentColor transparent transparent transparent}.loading.svelte-1le5672 .loading-first.svelte-1le5672{animation-delay:-0.45s}.loading.svelte-1le5672 .loading-second.svelte-1le5672{animation-delay:-0.3s}.loading.svelte-1le5672 .loading-third.svelte-1le5672{animation-delay:-0.15s}@keyframes svelte-1le5672-bn-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}");
}

// (63:2) {#if description}
function create_if_block$9(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*description*/ ctx[0]);
			attr(span, "class", "svelte-1le5672");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*description*/ 1) set_data(t, /*description*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$d(ctx) {
	let div4;
	let div3;
	let div0;
	let div0_style_value;
	let t0;
	let div1;
	let div1_style_value;
	let t1;
	let div2;
	let div2_style_value;
	let div3_style_value;
	let t2;
	let if_block = /*description*/ ctx[0] && create_if_block$9(ctx);

	return {
		c() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			t2 = space();
			if (if_block) if_block.c();
			attr(div0, "class", "loading-first svelte-1le5672");
			attr(div0, "style", div0_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`);
			attr(div1, "class", "loading-second svelte-1le5672");
			attr(div1, "style", div1_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`);
			attr(div2, "class", "loading-third svelte-1le5672");
			attr(div2, "style", div2_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`);
			attr(div3, "class", "loading relative svelte-1le5672");
			attr(div3, "style", div3_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`);
			attr(div4, "class", "loading-container flex flex-column justify-center items-center absolute svelte-1le5672");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div3);
			append(div3, div0);
			append(div3, t0);
			append(div3, div1);
			append(div3, t1);
			append(div3, div2);
			append(div4, t2);
			if (if_block) if_block.m(div4, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 2 && div0_style_value !== (div0_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`)) {
				attr(div0, "style", div0_style_value);
			}

			if (dirty & /*size*/ 2 && div1_style_value !== (div1_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`)) {
				attr(div1, "style", div1_style_value);
			}

			if (dirty & /*size*/ 2 && div2_style_value !== (div2_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`)) {
				attr(div2, "style", div2_style_value);
			}

			if (dirty & /*size*/ 2 && div3_style_value !== (div3_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`)) {
				attr(div3, "style", div3_style_value);
			}

			if (/*description*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					if_block.m(div4, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div4);
			if (if_block) if_block.d();
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { description = '' } = $$props;
	let { size = '2rem' } = $$props;

	$$self.$$set = $$props => {
		if ('description' in $$props) $$invalidate(0, description = $$props.description);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
	};

	return [description, size];
}

class Spinner extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$d, create_fragment$d, safe_not_equal, { description: 0, size: 1 }, add_css$d);
	}
}

/* src/views/shared/WalletAppBadge.svelte generated by Svelte v3.55.1 */

function add_css$c(target) {
	append_styles(target, "svelte-jzpbww", ".icon.svelte-jzpbww{height:100%}.border-yellow.svelte-jzpbww{border:1px solid var(--onboard-warning-500, var(--warning-500))}.border-gray.svelte-jzpbww{border:1px solid var(--onboard-gray-400, var(--gray-400))}.border-green.svelte-jzpbww{border:1px solid var(--onboard-success-500, var(--success-500))}.border-dark-green.svelte-jzpbww{border:1px solid var(--onboard-success-700, var(--success-700))}.border-blue.svelte-jzpbww{border:1px solid\n      var(\n        --onboard-wallet-app-icon-border-color,\n        var(--onboard-primary-300, var(--primary-300))\n      )}.border-dark-blue.svelte-jzpbww{border:1px solid\n      var(\n        --onboard-wallet-app-icon-border-color,\n        var(--onboard-primary-600, var(--primary-600))\n      )}.border-transparent.svelte-jzpbww{border:1px solid transparent}.border-black.svelte-jzpbww{border:1px solid var(--onboard-gray-600, var(--gray-600))}.background-gray.svelte-jzpbww{background:var(\n      --onboard-wallet-app-icon-background-gray,\n      var(--onboard-gray-500, var(--gray-500))\n    )}.background-light-gray.svelte-jzpbww{background:var(\n      --onboard-wallet-app-icon-background-light-gray,\n      var(--onboard-gray-100, var(--gray-100))\n    )}.background-light-blue.svelte-jzpbww{background:var(\n      --onboard-wallet-app-icon-background-light-blue,\n      var(--onboard-primary-100, var(--primary-100))\n    )}.background-green.svelte-jzpbww{background:var(\n      --onboard-wallet-app-icon-background-green,\n      var(--onboard-success-100, var(--success-100))\n    )}.background-white.svelte-jzpbww{background:var(\n      --onboard-wallet-app-icon-background-white,\n      var(--onboard-white, var(--white))\n    )}.background-transparent.svelte-jzpbww{background:var(\n      --onboard-wallet-app-icon-background-transparent,\n      transparent\n    )}@keyframes svelte-jzpbww-pulse{from{opacity:0}to{opacity:1}}.placeholder-icon.svelte-jzpbww{width:100%;height:100%;background:var(--onboard-gray-100, var(--gray-100));border-radius:32px;animation:svelte-jzpbww-pulse infinite 750ms alternate ease-in-out}.spinner-container.svelte-jzpbww{color:var(--onboard-primary-300, var(--primary-300))}img.svelte-jzpbww{max-width:100%;height:auto}.pending-status-icon{z-index:1;fill:white;box-shadow:0px 2px 12px 0px rgba(0, 0, 0, 0.1)}.status-icon-container.svelte-jzpbww{right:-0.25rem;bottom:-0.25rem;position:absolute}");
}

const get_status_slot_changes = dirty => ({});
const get_status_slot_context = ctx => ({});

// (173:2) {:else}
function create_else_block$4(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block$1,
		then: create_then_block$1,
		catch: create_catch_block$1,
		value: 13,
		blocks: [,,,]
	};

	handle_promise(promise = /*icon*/ ctx[1], info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*icon*/ 2 && promise !== (promise = /*icon*/ ctx[1]) && handle_promise(promise, info)) ; else {
				update_await_block_branch(info, ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (169:2) {#if loading && windowWidth >= MOBILE_WINDOW_WIDTH}
function create_if_block$8(ctx) {
	let div;
	let spinner;
	let current;
	spinner = new Spinner({ props: { size: "2rem" } });

	return {
		c() {
			div = element("div");
			create_component(spinner.$$.fragment);
			attr(div, "class", "spinner-container svelte-jzpbww");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(spinner, div, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(spinner);
		}
	};
}

// (1:0) <script lang="ts">import { fade }
function create_catch_block$1(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (176:4) {:then iconLoaded}
function create_then_block$1(ctx) {
	let div;
	let show_if;
	let div_intro;
	let t;
	let if_block1_anchor;
	let current;

	function select_block_type_1(ctx, dirty) {
		if (dirty & /*icon*/ 2) show_if = null;
		if (show_if == null) show_if = !!isSVG(/*iconLoaded*/ ctx[13]);
		if (show_if) return create_if_block_2$3;
		return create_else_block_1$2;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*loading*/ ctx[2] && /*windowWidth*/ ctx[9] <= MOBILE_WINDOW_WIDTH && create_if_block_1$3();

	return {
		c() {
			div = element("div");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(div, "class", "icon flex justify-center items-center svelte-jzpbww");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block0.m(div, null);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, null);
				}
			}

			if (/*loading*/ ctx[2] && /*windowWidth*/ ctx[9] <= MOBILE_WINDOW_WIDTH) {
				if (if_block1) {
					if (dirty & /*loading, windowWidth*/ 516) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$3();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, {});
					div_intro.start();
				});
			}

			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block0.d();
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (181:8) {:else}
function create_else_block_1$2(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*iconLoaded*/ ctx[13])) attr(img, "src", img_src_value);
			attr(img, "alt", "logo");
			attr(img, "class", "svelte-jzpbww");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 2 && !src_url_equal(img.src, img_src_value = /*iconLoaded*/ ctx[13])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (178:8) {#if isSVG(iconLoaded)}
function create_if_block_2$3(ctx) {
	let html_tag;
	let raw_value = /*iconLoaded*/ ctx[13] + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 2 && raw_value !== (raw_value = /*iconLoaded*/ ctx[13] + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (186:6) {#if loading && windowWidth <= MOBILE_WINDOW_WIDTH}
function create_if_block_1$3(ctx) {
	let div;
	let pendingstatusicon;
	let current;

	pendingstatusicon = new PendingStatusIcon({
			props: { class: "pending-status-icon", size: 20 }
		});

	return {
		c() {
			div = element("div");
			create_component(pendingstatusicon.$$.fragment);
			attr(div, "class", "status-icon-container svelte-jzpbww");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(pendingstatusicon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(pendingstatusicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(pendingstatusicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(pendingstatusicon);
		}
	};
}

// (174:17)        <div class="placeholder-icon" />     {:then iconLoaded}
function create_pending_block$1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "placeholder-icon svelte-jzpbww");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$c(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let t;
	let div_style_value;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[12]);
	const if_block_creators = [create_if_block$8, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*loading*/ ctx[2] && /*windowWidth*/ ctx[9] >= MOBILE_WINDOW_WIDTH) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const status_slot_template = /*#slots*/ ctx[11].status;
	const status_slot = create_slot(status_slot_template, ctx, /*$$scope*/ ctx[10], get_status_slot_context);

	return {
		c() {
			div = element("div");
			if_block.c();
			t = space();
			if (status_slot) status_slot.c();
			attr(div, "class", "relative svelte-jzpbww");

			attr(div, "style", div_style_value = `${/*background*/ ctx[6] === 'custom'
			? `background-color: ${/*customBackgroundColor*/ ctx[7]}`
			: ''}; padding: ${/*padding*/ ctx[3] - 1}px; width: ${/*size*/ ctx[0]}px; height: ${/*size*/ ctx[0]}px; border-radius: ${/*radius*/ ctx[8]}px; color: ${/*color*/ ctx[4]};`);

			toggle_class(div, "border-yellow", /*border*/ ctx[5] === 'yellow');
			toggle_class(div, "border-gray", /*border*/ ctx[5] === 'gray');
			toggle_class(div, "border-green", /*border*/ ctx[5] === 'green');
			toggle_class(div, "border-dark-green", /*border*/ ctx[5] === 'darkGreen');
			toggle_class(div, "border-blue", /*border*/ ctx[5] === 'blue');
			toggle_class(div, "border-dark-blue", /*border*/ ctx[5] === 'darkBlue');
			toggle_class(div, "border-transparent", /*border*/ ctx[5] === 'transparent');
			toggle_class(div, "border-black", /*border*/ ctx[5] === 'black');
			toggle_class(div, "background-gray", /*background*/ ctx[6] === 'gray');
			toggle_class(div, "background-light-gray", /*background*/ ctx[6] === 'lightGray');
			toggle_class(div, "background-light-blue", /*background*/ ctx[6] === 'lightBlue');
			toggle_class(div, "background-green", /*background*/ ctx[6] === 'green');
			toggle_class(div, "background-white", /*background*/ ctx[6] === 'white');
			toggle_class(div, "background-transparent", /*background*/ ctx[6] === 'transparent');
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t);

			if (status_slot) {
				status_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(window, "resize", /*onwindowresize*/ ctx[12]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t);
			}

			if (status_slot) {
				if (status_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						status_slot,
						status_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(status_slot_template, /*$$scope*/ ctx[10], dirty, get_status_slot_changes),
						get_status_slot_context
					);
				}
			}

			if (!current || dirty & /*background, customBackgroundColor, padding, size, radius, color*/ 473 && div_style_value !== (div_style_value = `${/*background*/ ctx[6] === 'custom'
			? `background-color: ${/*customBackgroundColor*/ ctx[7]}`
			: ''}; padding: ${/*padding*/ ctx[3] - 1}px; width: ${/*size*/ ctx[0]}px; height: ${/*size*/ ctx[0]}px; border-radius: ${/*radius*/ ctx[8]}px; color: ${/*color*/ ctx[4]};`)) {
				attr(div, "style", div_style_value);
			}

			if (!current || dirty & /*border*/ 32) {
				toggle_class(div, "border-yellow", /*border*/ ctx[5] === 'yellow');
			}

			if (!current || dirty & /*border*/ 32) {
				toggle_class(div, "border-gray", /*border*/ ctx[5] === 'gray');
			}

			if (!current || dirty & /*border*/ 32) {
				toggle_class(div, "border-green", /*border*/ ctx[5] === 'green');
			}

			if (!current || dirty & /*border*/ 32) {
				toggle_class(div, "border-dark-green", /*border*/ ctx[5] === 'darkGreen');
			}

			if (!current || dirty & /*border*/ 32) {
				toggle_class(div, "border-blue", /*border*/ ctx[5] === 'blue');
			}

			if (!current || dirty & /*border*/ 32) {
				toggle_class(div, "border-dark-blue", /*border*/ ctx[5] === 'darkBlue');
			}

			if (!current || dirty & /*border*/ 32) {
				toggle_class(div, "border-transparent", /*border*/ ctx[5] === 'transparent');
			}

			if (!current || dirty & /*border*/ 32) {
				toggle_class(div, "border-black", /*border*/ ctx[5] === 'black');
			}

			if (!current || dirty & /*background*/ 64) {
				toggle_class(div, "background-gray", /*background*/ ctx[6] === 'gray');
			}

			if (!current || dirty & /*background*/ 64) {
				toggle_class(div, "background-light-gray", /*background*/ ctx[6] === 'lightGray');
			}

			if (!current || dirty & /*background*/ 64) {
				toggle_class(div, "background-light-blue", /*background*/ ctx[6] === 'lightBlue');
			}

			if (!current || dirty & /*background*/ 64) {
				toggle_class(div, "background-green", /*background*/ ctx[6] === 'green');
			}

			if (!current || dirty & /*background*/ 64) {
				toggle_class(div, "background-white", /*background*/ ctx[6] === 'white');
			}

			if (!current || dirty & /*background*/ 64) {
				toggle_class(div, "background-transparent", /*background*/ ctx[6] === 'transparent');
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(status_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(status_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			if (status_slot) status_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { size } = $$props;
	let { icon } = $$props;
	let { loading = false } = $$props;
	let { padding = size / 6 } = $$props;
	let { color = 'black' } = $$props;
	let { border = 'transparent' } = $$props;
	let { background = 'transparent' } = $$props;
	let { customBackgroundColor = '' } = $$props;
	let { radius = 12 } = $$props;
	let windowWidth;

	function onwindowresize() {
		$$invalidate(9, windowWidth = window.innerWidth);
	}

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('icon' in $$props) $$invalidate(1, icon = $$props.icon);
		if ('loading' in $$props) $$invalidate(2, loading = $$props.loading);
		if ('padding' in $$props) $$invalidate(3, padding = $$props.padding);
		if ('color' in $$props) $$invalidate(4, color = $$props.color);
		if ('border' in $$props) $$invalidate(5, border = $$props.border);
		if ('background' in $$props) $$invalidate(6, background = $$props.background);
		if ('customBackgroundColor' in $$props) $$invalidate(7, customBackgroundColor = $$props.customBackgroundColor);
		if ('radius' in $$props) $$invalidate(8, radius = $$props.radius);
		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	return [
		size,
		icon,
		loading,
		padding,
		color,
		border,
		background,
		customBackgroundColor,
		radius,
		windowWidth,
		$$scope,
		slots,
		onwindowresize
	];
}

class WalletAppBadge extends SvelteComponent {
	constructor(options) {
		super();

		init$1(
			this,
			options,
			instance$c,
			create_fragment$c,
			safe_not_equal,
			{
				size: 0,
				icon: 1,
				loading: 2,
				padding: 3,
				color: 4,
				border: 5,
				background: 6,
				customBackgroundColor: 7,
				radius: 8
			},
			add_css$c
		);
	}
}

/* src/views/shared/Warning.svelte generated by Svelte v3.55.1 */

function add_css$b(target) {
	append_styles(target, "svelte-105a3pw", ".container.svelte-105a3pw{padding:var(--onboard-spacing-5, var(--spacing-5));color:var(--onboard-warning-700, var(--warning-700));font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;border:1px solid var(--onboard-warning-400, var(--warning-400));background:var(--onboard-warning-100, var(--warning-100));margin:0;border-radius:12px}.icon.svelte-105a3pw{color:var(--onboard-warning-700, var(--warning-700));width:1rem;height:1rem;margin-left:var(--onboard-spacing-5, var(--spacing-5))}p.svelte-105a3pw{margin:0;width:fit-content}");
}

function create_fragment$b(ctx) {
	let div1;
	let p;
	let t;
	let div0;
	let div1_intro;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			div1 = element("div");
			p = element("p");
			if (default_slot) default_slot.c();
			t = space();
			div0 = element("div");
			attr(p, "class", "svelte-105a3pw");
			attr(div0, "class", "icon svelte-105a3pw");
			attr(div1, "class", "container flex justify-between svelte-105a3pw");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, p);

			if (default_slot) {
				default_slot.m(p, null);
			}

			append(div1, t);
			append(div1, div0);
			div0.innerHTML = infoIcon;
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			if (!div1_intro) {
				add_render_callback(() => {
					div1_intro = create_in_transition(div1, fade, {});
					div1_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class Warning extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$b, create_fragment$b, safe_not_equal, {}, add_css$b);
	}
}

/* src/views/connect/ConnectedWallet.svelte generated by Svelte v3.55.1 */

function add_css$a(target) {
	append_styles(target, "svelte-1xbqy9g", ".container.svelte-1xbqy9g{padding:var(--onboard-spacing-4, var(--spacing-4))}.connecting-container.svelte-1xbqy9g{padding:var(--onboard-spacing-4, var(--spacing-4));border-radius:var(--onboard-border-radius-1, var(--border-radius-1));background:var(--onboard-success-100, var(--success-100));border:1px solid var(--onboard-success-600, var(--success-600));width:100%}.text.svelte-1xbqy9g{right:var(--onboard-spacing-5, var(--spacing-5))}.tick.svelte-1xbqy9g{color:var(--onboard-success-700, var(--success-700))}");
}

function create_fragment$a(ctx) {
	let div7;
	let div6;
	let div4;
	let div2;
	let walletappbadge0;
	let t0;
	let div0;
	let successstatusicon;
	let t1;
	let div1;
	let walletappbadge1;
	let t2;
	let div3;

	let t3_value = /*$_*/ ctx[1]('connect.connectedWallet.mainText', {
		default: en.connect.connectedWallet.mainText
	}) + "";

	let t3;
	let t4;
	let div5;
	let current;

	walletappbadge0 = new WalletAppBadge({
			props: {
				size: 40,
				padding: 8,
				background: /*appMetadata*/ ctx[2] && /*appMetadata*/ ctx[2].icon
				? 'lightBlue'
				: 'lightGray',
				border: "darkGreen",
				icon: /*appMetadata*/ ctx[2] && /*appMetadata*/ ctx[2].icon || questionIcon
			}
		});

	successstatusicon = new SuccessStatusIcon({ props: { size: 17 } });

	walletappbadge1 = new WalletAppBadge({
			props: {
				size: 40,
				padding: 8,
				border: "darkGreen",
				background: "white",
				icon: /*selectedWallet*/ ctx[0].icon
			}
		});

	return {
		c() {
			div7 = element("div");
			div6 = element("div");
			div4 = element("div");
			div2 = element("div");
			create_component(walletappbadge0.$$.fragment);
			t0 = space();
			div0 = element("div");
			create_component(successstatusicon.$$.fragment);
			t1 = space();
			div1 = element("div");
			create_component(walletappbadge1.$$.fragment);
			t2 = space();
			div3 = element("div");
			t3 = text(t3_value);
			t4 = space();
			div5 = element("div");
			attr(div0, "class", "relative");
			set_style(div0, "right", "1rem");
			set_style(div0, "top", "4px");
			set_style(div0, "z-index", "1");
			attr(div1, "class", "relative");
			set_style(div1, "right", "1.75rem");
			attr(div2, "class", "flex justify-center items-end relative");
			attr(div3, "class", "text relative svelte-1xbqy9g");
			attr(div4, "class", "flex items-center");
			attr(div5, "class", "tick flex items-center svelte-1xbqy9g");
			set_style(div5, "width", "24px");
			attr(div6, "class", "connecting-container flex justify-between items-center svelte-1xbqy9g");
			attr(div7, "class", "container svelte-1xbqy9g");
		},
		m(target, anchor) {
			insert(target, div7, anchor);
			append(div7, div6);
			append(div6, div4);
			append(div4, div2);
			mount_component(walletappbadge0, div2, null);
			append(div2, t0);
			append(div2, div0);
			mount_component(successstatusicon, div0, null);
			append(div2, t1);
			append(div2, div1);
			mount_component(walletappbadge1, div1, null);
			append(div4, t2);
			append(div4, div3);
			append(div3, t3);
			append(div6, t4);
			append(div6, div5);
			div5.innerHTML = successIcon;
			current = true;
		},
		p(ctx, [dirty]) {
			const walletappbadge1_changes = {};
			if (dirty & /*selectedWallet*/ 1) walletappbadge1_changes.icon = /*selectedWallet*/ ctx[0].icon;
			walletappbadge1.$set(walletappbadge1_changes);

			if ((!current || dirty & /*$_*/ 2) && t3_value !== (t3_value = /*$_*/ ctx[1]('connect.connectedWallet.mainText', {
				default: en.connect.connectedWallet.mainText
			}) + "")) set_data(t3, t3_value);
		},
		i(local) {
			if (current) return;
			transition_in(walletappbadge0.$$.fragment, local);
			transition_in(successstatusicon.$$.fragment, local);
			transition_in(walletappbadge1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(walletappbadge0.$$.fragment, local);
			transition_out(successstatusicon.$$.fragment, local);
			transition_out(walletappbadge1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div7);
			destroy_component(walletappbadge0);
			destroy_component(successstatusicon);
			destroy_component(walletappbadge1);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(1, $_ = $$value));
	let { selectedWallet } = $$props;
	const { appMetadata } = configuration;

	$$self.$$set = $$props => {
		if ('selectedWallet' in $$props) $$invalidate(0, selectedWallet = $$props.selectedWallet);
	};

	return [selectedWallet, $_, appMetadata];
}

class ConnectedWallet extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$a, create_fragment$a, safe_not_equal, { selectedWallet: 0 }, add_css$a);
	}
}

/* src/views/connect/ConnectingWallet.svelte generated by Svelte v3.55.1 */

function add_css$9(target) {
	append_styles(target, "svelte-j1ywa3", ".container.svelte-j1ywa3{padding:var(--onboard-spacing-4, var(--spacing-4))}.connecting-container.svelte-j1ywa3{width:100%;padding:var(--onboard-spacing-4, var(--spacing-4));transition:background-color 100ms ease-in-out,\n      border-color 100ms ease-in-out;border-radius:24px;background:var(--onboard-primary-100, var(--primary-100));border:1px solid;border-color:var(--onboard-primary-300, var(--primary-300));color:var(--onboard-gray-600, var(--gray-600))}.connecting-container.warning.svelte-j1ywa3{background:var(--onboard-warning-100, var(--warning-100));border-color:var(--onboard-warning-400, var(--warning-400))}.text.svelte-j1ywa3{line-height:16px;margin-bottom:var(--onboard-spacing-5, var(--spacing-5))}.text.text-rejected.svelte-j1ywa3{line-height:24px;margin-bottom:0}.subtext.svelte-j1ywa3{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px}.rejected-cta.svelte-j1ywa3{color:var(--onboard-primary-500, var(--primary-500))}.onboard-button-primary.svelte-j1ywa3{bottom:var(--onboard-spacing-3, var(--spacing-3))}.ml.svelte-j1ywa3{margin-left:var(--onboard-spacing-4, var(--spacing-4))}@media all and (max-width: 520px){.connecting-container.svelte-j1ywa3{border-radius:var(--onboard-border-radius-4, var(--border-radius-4))}.container.svelte-j1ywa3{padding-bottom:0}.wallet-badges.svelte-j1ywa3{display:none}.connecting-wallet-info.svelte-j1ywa3{margin:0}.onboard-button-primary.svelte-j1ywa3{display:none}}");
}

// (136:8) {:else}
function create_else_block$3(ctx) {
	let div;

	let t_value = /*$_*/ ctx[6](
		`connect.connectingWallet.${/*previousConnectionRequest*/ ctx[5]
		? 'previousConnection'
		: 'paragraph'}`,
		{
			default: en.connect.connectingWallet.paragraph,
			values: { wallet: /*selectedWallet*/ ctx[1].label }
		}
	) + "";

	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "subtext svelte-j1ywa3");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$_, previousConnectionRequest, selectedWallet*/ 98 && t_value !== (t_value = /*$_*/ ctx[6](
				`connect.connectingWallet.${/*previousConnectionRequest*/ ctx[5]
				? 'previousConnection'
				: 'paragraph'}`,
				{
					default: en.connect.connectingWallet.paragraph,
					values: { wallet: /*selectedWallet*/ ctx[1].label }
				}
			) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (130:8) {#if connectionRejected}
function create_if_block$7(ctx) {
	let div;

	let t_value = /*$_*/ ctx[6]('connect.connectingWallet.rejectedCTA', {
		default: en.connect.connectingWallet.rejectedCTA
	}) + "";

	let t;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "rejected-cta pointer subtext svelte-j1ywa3");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);

			if (!mounted) {
				dispose = listen(div, "click", function () {
					if (is_function(/*connectWallet*/ ctx[0])) /*connectWallet*/ ctx[0].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*$_*/ 64 && t_value !== (t_value = /*$_*/ ctx[6]('connect.connectingWallet.rejectedCTA', {
				default: en.connect.connectingWallet.rejectedCTA
			}) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$9(ctx) {
	let div6;
	let div5;
	let div4;
	let div1;
	let walletappbadge0;
	let t0;
	let div0;
	let walletappbadge1;
	let t1;
	let div3;
	let div2;

	let t2_value = /*$_*/ ctx[6](
		`connect.connectingWallet.${/*connectionRejected*/ ctx[4]
		? 'rejectedText'
		: 'mainText'}`,
		{
			default: /*connectionRejected*/ ctx[4]
			? en.connect.connectingWallet.rejectedText
			: en.connect.connectingWallet.mainText
		}
	) + "";

	let t2;
	let t3;
	let t4;
	let button;

	let t5_value = /*$_*/ ctx[6]('connect.connectingWallet.primaryButton', {
		default: en.connect.connectingWallet.primaryButton
	}) + "";

	let t5;
	let current;
	let mounted;
	let dispose;

	walletappbadge0 = new WalletAppBadge({
			props: {
				size: 40,
				padding: 8,
				icon: /*appMetadata*/ ctx[7] && /*appMetadata*/ ctx[7].icon || questionIcon,
				border: /*connectionRejected*/ ctx[4] || /*previousConnectionRequest*/ ctx[5]
				? 'yellow'
				: 'blue',
				background: "lightGray"
			}
		});

	walletappbadge1 = new WalletAppBadge({
			props: {
				size: 40,
				padding: 8,
				border: /*connectionRejected*/ ctx[4] || /*previousConnectionRequest*/ ctx[5]
				? 'yellow'
				: 'blue',
				background: "white",
				icon: /*selectedWallet*/ ctx[1].icon
			}
		});

	function select_block_type(ctx, dirty) {
		if (/*connectionRejected*/ ctx[4]) return create_if_block$7;
		return create_else_block$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div6 = element("div");
			div5 = element("div");
			div4 = element("div");
			div1 = element("div");
			create_component(walletappbadge0.$$.fragment);
			t0 = space();
			div0 = element("div");
			create_component(walletappbadge1.$$.fragment);
			t1 = space();
			div3 = element("div");
			div2 = element("div");
			t2 = text(t2_value);
			t3 = space();
			if_block.c();
			t4 = space();
			button = element("button");
			t5 = text(t5_value);
			attr(div0, "class", "relative");
			set_style(div0, "right", "0.5rem");
			attr(div1, "class", "flex justify-center relative wallet-badges svelte-j1ywa3");
			attr(div2, "class", "text svelte-j1ywa3");
			toggle_class(div2, "text-rejected", /*connectionRejected*/ ctx[4]);
			attr(div3, "class", "flex flex-column justify-center ml connecting-wallet-info svelte-j1ywa3");
			attr(div4, "class", "flex");
			attr(div5, "class", "connecting-container flex justify-between items-center svelte-j1ywa3");
			toggle_class(div5, "warning", /*connectionRejected*/ ctx[4] || /*previousConnectionRequest*/ ctx[5]);
			attr(button, "class", "onboard-button-primary absolute svelte-j1ywa3");
			attr(div6, "class", "container flex flex-column items-center svelte-j1ywa3");
		},
		m(target, anchor) {
			insert(target, div6, anchor);
			append(div6, div5);
			append(div5, div4);
			append(div4, div1);
			mount_component(walletappbadge0, div1, null);
			append(div1, t0);
			append(div1, div0);
			mount_component(walletappbadge1, div0, null);
			append(div4, t1);
			append(div4, div3);
			append(div3, div2);
			append(div2, t2);
			append(div3, t3);
			if_block.m(div3, null);
			append(div6, t4);
			append(div6, button);
			append(button, t5);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const walletappbadge0_changes = {};

			if (dirty & /*connectionRejected, previousConnectionRequest*/ 48) walletappbadge0_changes.border = /*connectionRejected*/ ctx[4] || /*previousConnectionRequest*/ ctx[5]
			? 'yellow'
			: 'blue';

			walletappbadge0.$set(walletappbadge0_changes);
			const walletappbadge1_changes = {};

			if (dirty & /*connectionRejected, previousConnectionRequest*/ 48) walletappbadge1_changes.border = /*connectionRejected*/ ctx[4] || /*previousConnectionRequest*/ ctx[5]
			? 'yellow'
			: 'blue';

			if (dirty & /*selectedWallet*/ 2) walletappbadge1_changes.icon = /*selectedWallet*/ ctx[1].icon;
			walletappbadge1.$set(walletappbadge1_changes);

			if ((!current || dirty & /*$_, connectionRejected*/ 80) && t2_value !== (t2_value = /*$_*/ ctx[6](
				`connect.connectingWallet.${/*connectionRejected*/ ctx[4]
				? 'rejectedText'
				: 'mainText'}`,
				{
					default: /*connectionRejected*/ ctx[4]
					? en.connect.connectingWallet.rejectedText
					: en.connect.connectingWallet.mainText
				}
			) + "")) set_data(t2, t2_value);

			if (!current || dirty & /*connectionRejected*/ 16) {
				toggle_class(div2, "text-rejected", /*connectionRejected*/ ctx[4]);
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div3, null);
				}
			}

			if (!current || dirty & /*connectionRejected, previousConnectionRequest*/ 48) {
				toggle_class(div5, "warning", /*connectionRejected*/ ctx[4] || /*previousConnectionRequest*/ ctx[5]);
			}

			if ((!current || dirty & /*$_*/ 64) && t5_value !== (t5_value = /*$_*/ ctx[6]('connect.connectingWallet.primaryButton', {
				default: en.connect.connectingWallet.primaryButton
			}) + "")) set_data(t5, t5_value);
		},
		i(local) {
			if (current) return;
			transition_in(walletappbadge0.$$.fragment, local);
			transition_in(walletappbadge1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(walletappbadge0.$$.fragment, local);
			transition_out(walletappbadge1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div6);
			destroy_component(walletappbadge0);
			destroy_component(walletappbadge1);
			if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(6, $_ = $$value));
	let { connectWallet } = $$props;
	let { selectedWallet } = $$props;
	let { deselectWallet } = $$props;
	let { setStep } = $$props;
	let { connectionRejected } = $$props;
	let { previousConnectionRequest } = $$props;
	const { appMetadata } = configuration;

	const click_handler = () => {
		deselectWallet(selectedWallet.label);
		setStep('selectingWallet');
	};

	$$self.$$set = $$props => {
		if ('connectWallet' in $$props) $$invalidate(0, connectWallet = $$props.connectWallet);
		if ('selectedWallet' in $$props) $$invalidate(1, selectedWallet = $$props.selectedWallet);
		if ('deselectWallet' in $$props) $$invalidate(2, deselectWallet = $$props.deselectWallet);
		if ('setStep' in $$props) $$invalidate(3, setStep = $$props.setStep);
		if ('connectionRejected' in $$props) $$invalidate(4, connectionRejected = $$props.connectionRejected);
		if ('previousConnectionRequest' in $$props) $$invalidate(5, previousConnectionRequest = $$props.previousConnectionRequest);
	};

	return [
		connectWallet,
		selectedWallet,
		deselectWallet,
		setStep,
		connectionRejected,
		previousConnectionRequest,
		$_,
		appMetadata,
		click_handler
	];
}

class ConnectingWallet extends SvelteComponent {
	constructor(options) {
		super();

		init$1(
			this,
			options,
			instance$9,
			create_fragment$9,
			safe_not_equal,
			{
				connectWallet: 0,
				selectedWallet: 1,
				deselectWallet: 2,
				setStep: 3,
				connectionRejected: 4,
				previousConnectionRequest: 5
			},
			add_css$9
		);
	}
}

/* src/views/connect/InstallWallet.svelte generated by Svelte v3.55.1 */

function add_css$8(target) {
	append_styles(target, "svelte-1uy2ffh", ".outer-container.svelte-1uy2ffh{padding:var(--onboard-spacing-4, var(--spacing-4))}.link.svelte-1uy2ffh{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;color:var(--onboard-primary-500, var(--primary-500));text-decoration:none}");
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i].name;
	child_ctx[3] = list[i].url;
	child_ctx[5] = i;
	return child_ctx;
}

// (41:4) {:else}
function create_else_block$2(ctx) {
	let t_value = /*$_*/ ctx[0]('connect.selectingWallet.installWallet', {
		default: en.connect.selectingWallet.installWallet,
		values: { app: /*name*/ ctx[2] || 'this app' }
	}) + "";

	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]('connect.selectingWallet.installWallet', {
				default: en.connect.selectingWallet.installWallet,
				values: { app: /*name*/ ctx[2] || 'this app' }
			}) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (22:4) {#if recommendedInjectedWallets}
function create_if_block$6(ctx) {
	let t0_value = /*$_*/ ctx[0]('connect.selectingWallet.recommendedWalletsPart1', {
		default: en.connect.selectingWallet.recommendedWalletsPart1,
		values: { app: /*name*/ ctx[2] || 'This app' }
	}) + "";

	let t0;
	let t1;
	let t2;

	let t3_value = /*$_*/ ctx[0]('connect.selectingWallet.recommendedWalletsPart2', {
		default: en.connect.selectingWallet.recommendedWalletsPart2
	}) + "";

	let t3;
	let each_value = /*recommendedInjectedWallets*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t2, anchor);
			insert(target, t3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]('connect.selectingWallet.recommendedWalletsPart1', {
				default: en.connect.selectingWallet.recommendedWalletsPart1,
				values: { app: /*name*/ ctx[2] || 'This app' }
			}) + "")) set_data(t0, t0_value);

			if (dirty & /*recommendedInjectedWallets*/ 2) {
				each_value = /*recommendedInjectedWallets*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(t2.parentNode, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*$_*/ 1 && t3_value !== (t3_value = /*$_*/ ctx[0]('connect.selectingWallet.recommendedWalletsPart2', {
				default: en.connect.selectingWallet.recommendedWalletsPart2
			}) + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (29:6) {#each recommendedInjectedWallets as { name, url }
function create_each_block$1(ctx) {
	let a;
	let t0_value = /*name*/ ctx[2] + "";
	let t0;

	let t1_value = (/*i*/ ctx[5] < /*recommendedInjectedWallets*/ ctx[1].length - 1
	? ', '
	: '') + "";

	let t1;

	return {
		c() {
			a = element("a");
			t0 = text(t0_value);
			t1 = text(t1_value);
			attr(a, "class", "link pointer svelte-1uy2ffh");
			attr(a, "href", /*url*/ ctx[3]);
			attr(a, "target", "_blank");
			attr(a, "rel", "noreferrer noopener");
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, t0);
			append(a, t1);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(a);
		}
	};
}

// (21:2) <Warning>
function create_default_slot$4(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*recommendedInjectedWallets*/ ctx[1]) return create_if_block$6;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$8(ctx) {
	let div;
	let warning;
	let current;

	warning = new Warning({
			props: {
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(warning.$$.fragment);
			attr(div, "class", "outer-container svelte-1uy2ffh");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(warning, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const warning_changes = {};

			if (dirty & /*$$scope, $_*/ 65) {
				warning_changes.$$scope = { dirty, ctx };
			}

			warning.$set(warning_changes);
		},
		i(local) {
			if (current) return;
			transition_in(warning.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(warning.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(warning);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(0, $_ = $$value));
	const { recommendedInjectedWallets, name } = configuration.appMetadata || {};
	return [$_, recommendedInjectedWallets, name];
}

class InstallWallet extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, {}, add_css$8);
	}
}

/* src/views/connect/WalletButton.svelte generated by Svelte v3.55.1 */

function add_css$7(target) {
	append_styles(target, "svelte-1wpiakm", "button.svelte-1wpiakm:disabled{opacity:0.5}button.wallet-button-styling.svelte-1wpiakm{position:relative;align-items:flex-start;flex:1;padding:0;background:none;color:var(\n      --onboard-wallet-button-color,\n      var(--onboard-gray-700, var(--gray-700))\n    )}button.wallet-button-styling.svelte-1wpiakm:hover{background:var(\n      --onboard-wallet-button-background-hover,\n      var(--onboard-primary-100, var(--primary-100))\n    );color:var(\n      --onboard-wallet-button-color-hover,\n      var(--onboard-gray-700, var(--gray-700))\n    )}.wallet-button-container.svelte-1wpiakm{display:flex}.wallet-button-container-inner.svelte-1wpiakm{position:relative;display:flex;flex-flow:column;align-items:center;gap:0.5rem;padding:0.75rem;width:5rem}.name.svelte-1wpiakm{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:1rem;text-overflow:ellipsis;max-width:5rem;max-height:2rem;overflow:hidden}.status-icon.svelte-1wpiakm{position:absolute;top:3.5rem;left:3.5rem}@media screen and (min-width: 768px){button.wallet-button-styling.svelte-1wpiakm{transition:background-color 250ms ease-in-out;background:var(\n        --onboard-wallet-button-background,\n        var(--onboard-white, var(--white))\n      );border-radius:var(\n        --onboard-wallet-button-border-radius,\n        var(--border-radius-1)\n      );border:1px solid\n        var(\n          --onboard-wallet-button-border-color,\n          var(--onboard-primary-200, var(--primary-200))\n        )}button.wallet-button-styling.svelte-1wpiakm:hover{background:var(\n        --onboard-wallet-button-background-hover,\n        var(--onboard-primary-100, var(--primary-100))\n      )}.wallet-button-container-inner.svelte-1wpiakm{flex:1;flex-flow:row nowrap;gap:1rem;padding:1rem}button.connected.svelte-1wpiakm{border-color:var(--onboard-success-500, var(--success-500))}button.connected.svelte-1wpiakm:hover{background:var(--onboard-success-100, var(--success-100))}.name.svelte-1wpiakm{font-size:1rem;line-height:1.25rem;text-align:initial;max-width:inherit;max-height:3rem}.status-icon.svelte-1wpiakm{top:0;bottom:0;left:auto;right:1rem;margin:auto;height:20px}}");
}

// (148:6) {#if connected}
function create_if_block$5(ctx) {
	let div;
	let successstatusicon;
	let current;
	successstatusicon = new SuccessStatusIcon({ props: { size: 20 } });

	return {
		c() {
			div = element("div");
			create_component(successstatusicon.$$.fragment);
			attr(div, "class", "status-icon svelte-1wpiakm");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(successstatusicon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(successstatusicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(successstatusicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(successstatusicon);
		}
	};
}

function create_fragment$7(ctx) {
	let div2;
	let button;
	let div1;
	let walletappbadge;
	let t0;
	let div0;
	let t1;
	let t2;
	let button_intro;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[7]);

	walletappbadge = new WalletAppBadge({
			props: {
				size: /*windowWidth*/ ctx[6] >= MOBILE_WINDOW_WIDTH ? 48 : 56,
				icon: /*icon*/ ctx[0],
				loading: /*connecting*/ ctx[4],
				border: /*connected*/ ctx[3] ? 'green' : 'blue',
				background: "transparent"
			}
		});

	let if_block = /*connected*/ ctx[3] && create_if_block$5();

	return {
		c() {
			div2 = element("div");
			button = element("button");
			div1 = element("div");
			create_component(walletappbadge.$$.fragment);
			t0 = space();
			div0 = element("div");
			t1 = text(/*label*/ ctx[1]);
			t2 = space();
			if (if_block) if_block.c();
			attr(div0, "class", "name svelte-1wpiakm");
			attr(div1, "class", "wallet-button-container-inner svelte-1wpiakm");
			attr(button, "class", "wallet-button-styling svelte-1wpiakm");
			button.disabled = /*disabled*/ ctx[5];
			toggle_class(button, "connected", /*connected*/ ctx[3]);
			attr(div2, "class", "wallet-button-container svelte-1wpiakm");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, button);
			append(button, div1);
			mount_component(walletappbadge, div1, null);
			append(div1, t0);
			append(div1, div0);
			append(div0, t1);
			append(div1, t2);
			if (if_block) if_block.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "resize", /*onwindowresize*/ ctx[7]),
					listen(button, "click", function () {
						if (is_function(/*onClick*/ ctx[2])) /*onClick*/ ctx[2].apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			const walletappbadge_changes = {};
			if (dirty & /*windowWidth*/ 64) walletappbadge_changes.size = /*windowWidth*/ ctx[6] >= MOBILE_WINDOW_WIDTH ? 48 : 56;
			if (dirty & /*icon*/ 1) walletappbadge_changes.icon = /*icon*/ ctx[0];
			if (dirty & /*connecting*/ 16) walletappbadge_changes.loading = /*connecting*/ ctx[4];
			if (dirty & /*connected*/ 8) walletappbadge_changes.border = /*connected*/ ctx[3] ? 'green' : 'blue';
			walletappbadge.$set(walletappbadge_changes);
			if (!current || dirty & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);

			if (/*connected*/ ctx[3]) {
				if (if_block) {
					if (dirty & /*connected*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$5();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*disabled*/ 32) {
				button.disabled = /*disabled*/ ctx[5];
			}

			if (!current || dirty & /*connected*/ 8) {
				toggle_class(button, "connected", /*connected*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(walletappbadge.$$.fragment, local);
			transition_in(if_block);

			if (!button_intro) {
				add_render_callback(() => {
					button_intro = create_in_transition(button, fade, {});
					button_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(walletappbadge.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(walletappbadge);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { icon } = $$props;
	let { label } = $$props;
	let { onClick } = $$props;
	let { connected } = $$props;
	let { connecting } = $$props;
	let { disabled } = $$props;
	let windowWidth;

	function onwindowresize() {
		$$invalidate(6, windowWidth = window.innerWidth);
	}

	$$self.$$set = $$props => {
		if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
		if ('connected' in $$props) $$invalidate(3, connected = $$props.connected);
		if ('connecting' in $$props) $$invalidate(4, connecting = $$props.connecting);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
	};

	return [
		icon,
		label,
		onClick,
		connected,
		connecting,
		disabled,
		windowWidth,
		onwindowresize
	];
}

class WalletButton extends SvelteComponent {
	constructor(options) {
		super();

		init$1(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				icon: 0,
				label: 1,
				onClick: 2,
				connected: 3,
				connecting: 4,
				disabled: 5
			},
			add_css$7
		);
	}
}

/* src/views/connect/SelectingWallet.svelte generated by Svelte v3.55.1 */

function add_css$6(target) {
	append_styles(target, "svelte-fyll7w", ".wallets-container.svelte-fyll7w{display:flex;gap:0.5rem;overflow-x:scroll;overflow-y:hidden;padding:0.75rem 0.5rem;border-bottom:1px solid\n      var(\n        --onboard-wallet-button-border-color,\n        var(--onboard-primary-200, var(--primary-200))\n      );-ms-overflow-style:none;scrollbar-width:none}.wallets-container.svelte-fyll7w::-webkit-scrollbar{display:none}.warning-container.svelte-fyll7w{margin:1rem 1rem 0}@media all and (min-width: 768px){.wallets-container.svelte-fyll7w{display:grid;grid-template-columns:repeat(var(--onboard-wallet-columns, 2), 1fr);padding:1rem}}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (57:2) {#if connectingErrorMessage}
function create_if_block$4(ctx) {
	let div;
	let warning;
	let current;

	warning = new Warning({
			props: {
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(warning.$$.fragment);
			attr(div, "class", "warning-container svelte-fyll7w");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(warning, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const warning_changes = {};

			if (dirty & /*$$scope, connectingErrorMessage*/ 2056) {
				warning_changes.$$scope = { dirty, ctx };
			}

			warning.$set(warning_changes);
		},
		i(local) {
			if (current) return;
			transition_in(warning.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(warning.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(warning);
		}
	};
}

// (59:6) <Warning>
function create_default_slot$3(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*connectingErrorMessage*/ ctx[3], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*connectingErrorMessage*/ 8) html_tag.p(/*connectingErrorMessage*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (64:4) {#each wallets as wallet}
function create_each_block(ctx) {
	let walletbutton;
	let current;

	function func() {
		return /*func*/ ctx[7](/*wallet*/ ctx[8]);
	}

	walletbutton = new WalletButton({
			props: {
				connected: /*checkConnected*/ ctx[5](/*wallet*/ ctx[8].label),
				connecting: /*connectingWalletLabel*/ ctx[2] === /*wallet*/ ctx[8].label,
				label: /*wallet*/ ctx[8].label,
				icon: /*wallet*/ ctx[8].icon,
				onClick: func,
				disabled: /*windowWidth*/ ctx[4] <= MOBILE_WINDOW_WIDTH && /*connectingWalletLabel*/ ctx[2] && /*connectingWalletLabel*/ ctx[2] !== /*wallet*/ ctx[8].label
			}
		});

	return {
		c() {
			create_component(walletbutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(walletbutton, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const walletbutton_changes = {};
			if (dirty & /*wallets*/ 1) walletbutton_changes.connected = /*checkConnected*/ ctx[5](/*wallet*/ ctx[8].label);
			if (dirty & /*connectingWalletLabel, wallets*/ 5) walletbutton_changes.connecting = /*connectingWalletLabel*/ ctx[2] === /*wallet*/ ctx[8].label;
			if (dirty & /*wallets*/ 1) walletbutton_changes.label = /*wallet*/ ctx[8].label;
			if (dirty & /*wallets*/ 1) walletbutton_changes.icon = /*wallet*/ ctx[8].icon;
			if (dirty & /*selectWallet, wallets*/ 3) walletbutton_changes.onClick = func;
			if (dirty & /*windowWidth, connectingWalletLabel, wallets*/ 21) walletbutton_changes.disabled = /*windowWidth*/ ctx[4] <= MOBILE_WINDOW_WIDTH && /*connectingWalletLabel*/ ctx[2] && /*connectingWalletLabel*/ ctx[2] !== /*wallet*/ ctx[8].label;
			walletbutton.$set(walletbutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in(walletbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(walletbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(walletbutton, detaching);
		}
	};
}

function create_fragment$6(ctx) {
	let div1;
	let t;
	let div0;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[6]);
	let if_block = /*connectingErrorMessage*/ ctx[3] && create_if_block$4(ctx);
	let each_value = /*wallets*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div1 = element("div");
			if (if_block) if_block.c();
			t = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "wallets-container svelte-fyll7w");
			attr(div1, "class", "outer-container");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append(div1, t);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(window, "resize", /*onwindowresize*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*connectingErrorMessage*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*connectingErrorMessage*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*checkConnected, wallets, connectingWalletLabel, selectWallet, windowWidth, MOBILE_WINDOW_WIDTH*/ 55) {
				each_value = /*wallets*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { wallets } = $$props;
	let { selectWallet } = $$props;
	let { connectingWalletLabel } = $$props;
	let { connectingErrorMessage } = $$props;
	let windowWidth;

	function checkConnected(label) {
		const { wallets } = state.get();
		return !!wallets.find(wallet => wallet.label === label);
	}

	function onwindowresize() {
		$$invalidate(4, windowWidth = window.innerWidth);
	}

	const func = wallet => selectWallet(wallet);

	$$self.$$set = $$props => {
		if ('wallets' in $$props) $$invalidate(0, wallets = $$props.wallets);
		if ('selectWallet' in $$props) $$invalidate(1, selectWallet = $$props.selectWallet);
		if ('connectingWalletLabel' in $$props) $$invalidate(2, connectingWalletLabel = $$props.connectingWalletLabel);
		if ('connectingErrorMessage' in $$props) $$invalidate(3, connectingErrorMessage = $$props.connectingErrorMessage);
	};

	return [
		wallets,
		selectWallet,
		connectingWalletLabel,
		connectingErrorMessage,
		windowWidth,
		checkConnected,
		onwindowresize,
		func
	];
}

class SelectingWallet extends SvelteComponent {
	constructor(options) {
		super();

		init$1(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				wallets: 0,
				selectWallet: 1,
				connectingWalletLabel: 2,
				connectingErrorMessage: 3
			},
			add_css$6
		);
	}
}

/* src/views/connect/Sidebar.svelte generated by Svelte v3.55.1 */

function add_css$5(target) {
	append_styles(target, "svelte-o3wrnc", ".sidebar.svelte-o3wrnc{display:flex;flex-flow:column;gap:1rem;padding:1rem;align-items:center;color:var(\n      --onboard-connect-sidebar-color,\n      var(--onboard-gray-700, var(--gray-700))\n    )}.inner-container.svelte-o3wrnc{display:flex;flex-flow:column;align-items:center;align-self:stretch;gap:0.5rem;padding:1.5rem;text-align:center;border:1px solid;border-radius:12px;border-color:var(\n      --onboard-connect-sidebar-border-color,\n      var(--onboard-primary-200, var(--primary-200))\n    );background:var(\n      --onboard-connect-sidebar-background,\n      var(--onboard-primary-100, var(--primary-100))\n    )}.icon-container.svelte-o3wrnc{display:flex}.subheading.svelte-o3wrnc{line-height:1rem}.description.svelte-o3wrnc{line-height:1.25rem;font-size:var(--onboard-font-size-6, var(--font-size-6))}img.svelte-o3wrnc{max-width:100%;height:auto}.indicators.svelte-o3wrnc{margin-top:1rem}.indicator.svelte-o3wrnc{box-sizing:content-box;width:8px;height:8px;border-radius:8px;background:var(\n      --onboard-connect-sidebar-progress-background,\n      var(--onboard-gray-700, var(--gray-700))\n    );transition:background 250ms ease-in-out}.indicator.on.svelte-o3wrnc{background:var(\n      --onboard-connect-sidebar-progress-color,\n      var(--onboard-primary-600, var(--primary-600))\n    );border:2px solid\n      var(\n        --onboard-connect-sidebar-progress-background,\n        var(--onboard-gray-700, var(--gray-700))\n      )}.join.svelte-o3wrnc{box-sizing:content-box;z-index:1;right:4px;height:2px;background:var(\n      --onboard-connect-sidebar-progress-background,\n      var(--onboard-gray-700, var(--gray-700))\n    );transition:background 250ms ease-in-out}.join.active.svelte-o3wrnc{background:var(\n      --onboard-connect-sidebar-progress-color,\n      var(--onboard-primary-600, var(--primary-600))\n    )}@media all and (min-width: 768px){.sidebar.svelte-o3wrnc{max-width:280px;border-right:1px solid;border-color:var(\n        --onboard-connect-sidebar-border-color,\n        var(--onboard-primary-200, var(--primary-200))\n      );background:var(\n        --onboard-connect-sidebar-background,\n        var(--onboard-primary-100, var(--primary-100))\n      )}.inner-container.svelte-o3wrnc{border:none;text-align:initial;flex:1;align-items:flex-start;gap:1rem}}");
}

// (145:4) {#if windowWidth >= MOBILE_WINDOW_WIDTH}
function create_if_block$3(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (/*logo*/ ctx[4] || /*icon*/ ctx[3]) return create_if_block_1$2;
		return create_else_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "icon-container svelte-o3wrnc");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

// (153:8) {:else}
function create_else_block_1$1(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(blocknative, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (147:8) {#if logo || icon}
function create_if_block_1$2(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (isSVG(/*logo*/ ctx[4] || /*icon*/ ctx[3])) return create_if_block_2$2;
		return create_else_block$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (150:10) {:else}
function create_else_block$1(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*logo*/ ctx[4] || /*icon*/ ctx[3])) attr(img, "src", img_src_value);
			attr(img, "alt", "logo");
			attr(img, "class", "svelte-o3wrnc");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (148:10) {#if isSVG(logo || icon)}
function create_if_block_2$2(ctx) {
	let html_tag;
	let raw_value = (/*logo*/ ctx[4] || /*icon*/ ctx[3]) + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

function create_fragment$5(ctx) {
	let div10;
	let div8;
	let t0;
	let div0;
	let t1_value = /*$_*/ ctx[2](`connect.${/*step*/ ctx[0]}.sidebar.subheading`, { default: /*subheading*/ ctx[6] }) + "";
	let t1;
	let t2;
	let div1;

	let t3_value = /*$_*/ ctx[2](`connect.${/*step*/ ctx[0]}.sidebar.paragraph`, {
		values: { app: /*name*/ ctx[5] },
		default: /*paragraph*/ ctx[7]
	}) + "";

	let t3;
	let t4;
	let div7;
	let div2;
	let t5;
	let div3;
	let div3_style_value;
	let t6;
	let div4;
	let t7;
	let div5;
	let div5_style_value;
	let t8;
	let div6;
	let t9;
	let div9;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[8]);
	let if_block = /*windowWidth*/ ctx[1] >= MOBILE_WINDOW_WIDTH && create_if_block$3(ctx);

	return {
		c() {
			div10 = element("div");
			div8 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div0 = element("div");
			t1 = text(t1_value);
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = space();
			div7 = element("div");
			div2 = element("div");
			t5 = space();
			div3 = element("div");
			t6 = space();
			div4 = element("div");
			t7 = space();
			div5 = element("div");
			t8 = space();
			div6 = element("div");
			t9 = space();
			div9 = element("div");
			attr(div0, "class", "subheading svelte-o3wrnc");
			attr(div1, "class", "description svelte-o3wrnc");
			attr(div2, "class", "indicator relative svelte-o3wrnc");
			toggle_class(div2, "on", true);
			attr(div3, "class", "join relative svelte-o3wrnc");

			attr(div3, "style", div3_style_value = `${/*step*/ ctx[0] !== 'selectingWallet'
			? 'right: 4px; width: 52px;'
			: 'right: 2px; width: 54px;'}`);

			toggle_class(div3, "active", /*step*/ ctx[0] !== 'selectingWallet');
			attr(div4, "class", "indicator relative svelte-o3wrnc");
			attr(div4, "style", `right: 8px;`);
			toggle_class(div4, "on", /*step*/ ctx[0] !== 'selectingWallet');
			attr(div5, "class", "join relative svelte-o3wrnc");

			attr(div5, "style", div5_style_value = `${/*step*/ ctx[0] === 'connectedWallet'
			? 'right: 12px; width: 52px;'
			: 'right: 10px; width: 54px;'}`);

			toggle_class(div5, "active", /*step*/ ctx[0] === 'connectedWallet');
			attr(div6, "style", `right: 16px;`);
			attr(div6, "class", "indicator relative svelte-o3wrnc");
			toggle_class(div6, "on", /*step*/ ctx[0] === 'connectedWallet');
			attr(div7, "class", "indicators flex items-center svelte-o3wrnc");
			attr(div8, "class", "inner-container svelte-o3wrnc");
			attr(div10, "class", "sidebar svelte-o3wrnc");
		},
		m(target, anchor) {
			insert(target, div10, anchor);
			append(div10, div8);
			if (if_block) if_block.m(div8, null);
			append(div8, t0);
			append(div8, div0);
			append(div0, t1);
			append(div8, t2);
			append(div8, div1);
			append(div1, t3);
			append(div8, t4);
			append(div8, div7);
			append(div7, div2);
			append(div7, t5);
			append(div7, div3);
			append(div7, t6);
			append(div7, div4);
			append(div7, t7);
			append(div7, div5);
			append(div7, t8);
			append(div7, div6);
			append(div10, t9);
			append(div10, div9);

			if (!mounted) {
				dispose = listen(window, "resize", /*onwindowresize*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*windowWidth*/ ctx[1] >= MOBILE_WINDOW_WIDTH) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(div8, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*$_, step*/ 5 && t1_value !== (t1_value = /*$_*/ ctx[2](`connect.${/*step*/ ctx[0]}.sidebar.subheading`, { default: /*subheading*/ ctx[6] }) + "")) set_data(t1, t1_value);

			if (dirty & /*$_, step*/ 5 && t3_value !== (t3_value = /*$_*/ ctx[2](`connect.${/*step*/ ctx[0]}.sidebar.paragraph`, {
				values: { app: /*name*/ ctx[5] },
				default: /*paragraph*/ ctx[7]
			}) + "")) set_data(t3, t3_value);

			if (dirty & /*step*/ 1 && div3_style_value !== (div3_style_value = `${/*step*/ ctx[0] !== 'selectingWallet'
			? 'right: 4px; width: 52px;'
			: 'right: 2px; width: 54px;'}`)) {
				attr(div3, "style", div3_style_value);
			}

			if (dirty & /*step*/ 1) {
				toggle_class(div3, "active", /*step*/ ctx[0] !== 'selectingWallet');
			}

			if (dirty & /*step*/ 1) {
				toggle_class(div4, "on", /*step*/ ctx[0] !== 'selectingWallet');
			}

			if (dirty & /*step*/ 1 && div5_style_value !== (div5_style_value = `${/*step*/ ctx[0] === 'connectedWallet'
			? 'right: 12px; width: 52px;'
			: 'right: 10px; width: 54px;'}`)) {
				attr(div5, "style", div5_style_value);
			}

			if (dirty & /*step*/ 1) {
				toggle_class(div5, "active", /*step*/ ctx[0] === 'connectedWallet');
			}

			if (dirty & /*step*/ 1) {
				toggle_class(div6, "on", /*step*/ ctx[0] === 'connectedWallet');
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div10);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(2, $_ = $$value));
	let { step } = $$props;
	const { appMetadata } = configuration;
	const { icon, logo, name = 'This app' } = appMetadata || {};
	const defaultContent = en.connect[step].sidebar;
	const { subheading, paragraph } = defaultContent;
	let windowWidth;

	function onwindowresize() {
		$$invalidate(1, windowWidth = window.innerWidth);
	}

	$$self.$$set = $$props => {
		if ('step' in $$props) $$invalidate(0, step = $$props.step);
	};

	return [step, windowWidth, $_, icon, logo, name, subheading, paragraph, onwindowresize];
}

class Sidebar extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, { step: 0 }, add_css$5);
	}
}

/* src/views/connect/Index.svelte generated by Svelte v3.55.1 */

function add_css$4(target) {
	append_styles(target, "svelte-7qgvqp", ".container.svelte-7qgvqp{font-family:var(--onboard-font-family-normal, var(--font-family-normal));font-size:var(--onboard-font-size-5, var(--font-size-5));color:var(--onboard-gray-700, var(--gray-700));background:var(\n      --onboard-main-scroll-container-background,\n      var(--onboard-white, var(--white))\n    );line-height:24px;margin-bottom:2rem;overflow:hidden;position:relative;display:flex;height:min-content;flex-flow:column-reverse}.content.svelte-7qgvqp{width:var(--onboard-connect-content-width, 100%)}.scroll-container.svelte-7qgvqp{overflow-y:auto;transition:opacity 250ms ease-in-out;scrollbar-width:none}.scroll-container.svelte-7qgvqp::-webkit-scrollbar{display:none}.header.svelte-7qgvqp{display:flex;padding:1rem;border-bottom:1px solid var(--onboard-primary-200, var(--primary-200));background:var(\n      --onboard-connect-header-background,\n      var(--onboard-white, var(--white))\n    );color:var(\n      --onboard-connect-header-color,\n      var(--onboard-black, var(--black))\n    )}.header-heading.svelte-7qgvqp{line-height:16px}.button-container.svelte-7qgvqp{right:var(--onboard-spacing-5, var(--spacing-5));top:var(--onboard-spacing-5, var(--spacing-5))}.disabled.svelte-7qgvqp{opacity:0.2;pointer-events:none}.mobile-header.svelte-7qgvqp{height:4.5rem;padding:1rem;display:flex;gap:0.5rem;border-bottom:1px solid\n      var(\n        --onboard-wallet-button-border-color,\n        var(--onboard-primary-200, var(--primary-200))\n      )}.mobile-subheader.svelte-7qgvqp{color:var(--onboard-gray-400, var(--gray-400));font-size:var(--onboard-font-size-6, var(--font-size-6));font-weight:400;line-height:1rem;margin-top:0.25rem}.icon-container.svelte-7qgvqp{display:flex;flex:0 0 auto;height:2.5rem;width:2.5rem;min-width:2.5rem;justify-content:center}.w-full.svelte-7qgvqp{width:100%}@media all and (min-width: 768px){.container.svelte-7qgvqp{margin:0;flex-flow:row;height:var(--onboard-connect-content-height, 440px)}.content.svelte-7qgvqp{width:var(--onboard-connect-content-width, 488px)}.mobile-subheader.svelte-7qgvqp{display:none}.icon-container.svelte-7qgvqp{display:none}}");
}

// (395:0) {#if !autoSelect.disableModals}
function create_if_block$2(ctx) {
	let modal;
	let current;

	modal = new Modal({
			props: {
				close: /*close*/ ctx[19],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(modal.$$.fragment);
		},
		m(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const modal_changes = {};

			if (dirty[0] & /*scrollContainer, selectedWallet, $modalStep$, windowWidth, connectionRejected, previousConnectionRequest, displayConnectingWallet, agreed, wallets, connectingWalletLabel, connectingErrorMessage, availableWallets, $_*/ 16382 | dirty[1] & /*$$scope*/ 4) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(modal, detaching);
		}
	};
}

// (398:6) {#if connect.showSidebar}
function create_if_block_8$1(ctx) {
	let sidebar;
	let current;
	sidebar = new Sidebar({ props: { step: /*$modalStep$*/ ctx[5] } });

	return {
		c() {
			create_component(sidebar.$$.fragment);
		},
		m(target, anchor) {
			mount_component(sidebar, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const sidebar_changes = {};
			if (dirty[0] & /*$modalStep$*/ 32) sidebar_changes.step = /*$modalStep$*/ ctx[5];
			sidebar.$set(sidebar_changes);
		},
		i(local) {
			if (current) return;
			transition_in(sidebar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(sidebar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(sidebar, detaching);
		}
	};
}

// (441:8) {:else}
function create_else_block_3(ctx) {
	let div1;
	let div0;

	let t0_value = /*$_*/ ctx[13](`connect.${/*$modalStep$*/ ctx[5]}.header`, {
		default: en.connect[/*$modalStep$*/ ctx[5]].header,
		values: {
			connectionRejected: /*connectionRejected*/ ctx[1],
			wallet: /*selectedWallet*/ ctx[3] && /*selectedWallet*/ ctx[3].label
		}
	}) + "";

	let t0;
	let t1;

	let t2_value = (/*$modalStep$*/ ctx[5] === 'selectingWallet'
	? `(${/*availableWallets*/ ctx[12]})`
	: '') + "";

	let t2;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
			attr(div0, "class", "header-heading svelte-7qgvqp");
			attr(div1, "class", "header relative flex items-center svelte-7qgvqp");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, t0);
			append(div0, t1);
			append(div0, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_, $modalStep$, connectionRejected, selectedWallet*/ 8234 && t0_value !== (t0_value = /*$_*/ ctx[13](`connect.${/*$modalStep$*/ ctx[5]}.header`, {
				default: en.connect[/*$modalStep$*/ ctx[5]].header,
				values: {
					connectionRejected: /*connectionRejected*/ ctx[1],
					wallet: /*selectedWallet*/ ctx[3] && /*selectedWallet*/ ctx[3].label
				}
			}) + "")) set_data(t0, t0_value);

			if (dirty[0] & /*$modalStep$, availableWallets*/ 4128 && t2_value !== (t2_value = (/*$modalStep$*/ ctx[5] === 'selectingWallet'
			? `(${/*availableWallets*/ ctx[12]})`
			: '') + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (403:8) {#if windowWidth <= MOBILE_WINDOW_WIDTH}
function create_if_block_5$1(ctx) {
	let div4;
	let div0;
	let t0;
	let div3;
	let div1;

	let t1_value = /*$_*/ ctx[13](
		/*$modalStep$*/ ctx[5] === 'connectingWallet' && /*selectedWallet*/ ctx[3]
		? `connect.${/*$modalStep$*/ ctx[5]}.header`
		: `connect.${/*$modalStep$*/ ctx[5]}.sidebar.subheading`,
		{
			default: /*$modalStep$*/ ctx[5] === 'connectingWallet' && /*selectedWallet*/ ctx[3]
			? en.connect[/*$modalStep$*/ ctx[5]].header
			: en.connect[/*$modalStep$*/ ctx[5]].sidebar.subheading,
			values: {
				connectionRejected: /*connectionRejected*/ ctx[1],
				wallet: /*selectedWallet*/ ctx[3] && /*selectedWallet*/ ctx[3].label
			}
		}
	) + "";

	let t1;
	let t2;
	let div2;

	let t3_value = (/*$modalStep$*/ ctx[5] === 'selectingWallet'
	? `${/*availableWallets*/ ctx[12]} available wallets`
	: '1 account selected') + "";

	let t3;

	function select_block_type_1(ctx, dirty) {
		if (/*icon*/ ctx[14]) return create_if_block_6$1;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div4 = element("div");
			div0 = element("div");
			if_block.c();
			t0 = space();
			div3 = element("div");
			div1 = element("div");
			t1 = text(t1_value);
			t2 = space();
			div2 = element("div");
			t3 = text(t3_value);
			attr(div0, "class", "icon-container svelte-7qgvqp");
			attr(div1, "class", "header-heading svelte-7qgvqp");
			attr(div2, "class", "mobile-subheader svelte-7qgvqp");
			attr(div3, "class", "flex flex-column justify-center w-full svelte-7qgvqp");
			attr(div4, "class", "mobile-header svelte-7qgvqp");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div0);
			if_block.m(div0, null);
			append(div4, t0);
			append(div4, div3);
			append(div3, div1);
			append(div1, t1);
			append(div3, t2);
			append(div3, div2);
			append(div2, t3);
		},
		p(ctx, dirty) {
			if_block.p(ctx, dirty);

			if (dirty[0] & /*$_, $modalStep$, selectedWallet, connectionRejected*/ 8234 && t1_value !== (t1_value = /*$_*/ ctx[13](
				/*$modalStep$*/ ctx[5] === 'connectingWallet' && /*selectedWallet*/ ctx[3]
				? `connect.${/*$modalStep$*/ ctx[5]}.header`
				: `connect.${/*$modalStep$*/ ctx[5]}.sidebar.subheading`,
				{
					default: /*$modalStep$*/ ctx[5] === 'connectingWallet' && /*selectedWallet*/ ctx[3]
					? en.connect[/*$modalStep$*/ ctx[5]].header
					: en.connect[/*$modalStep$*/ ctx[5]].sidebar.subheading,
					values: {
						connectionRejected: /*connectionRejected*/ ctx[1],
						wallet: /*selectedWallet*/ ctx[3] && /*selectedWallet*/ ctx[3].label
					}
				}
			) + "")) set_data(t1, t1_value);

			if (dirty[0] & /*$modalStep$, availableWallets*/ 4128 && t3_value !== (t3_value = (/*$modalStep$*/ ctx[5] === 'selectingWallet'
			? `${/*availableWallets*/ ctx[12]} available wallets`
			: '1 account selected') + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) detach(div4);
			if_block.d();
		}
	};
}

// (412:14) {:else}
function create_else_block_2(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(blocknative, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (406:14) {#if icon}
function create_if_block_6$1(ctx) {
	let if_block_anchor;

	function select_block_type_2(ctx, dirty) {
		if (isSVG(/*icon*/ ctx[14])) return create_if_block_7$1;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (409:16) {:else}
function create_else_block_1(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*icon*/ ctx[14])) attr(img, "src", img_src_value);
			attr(img, "alt", "logo");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (407:16) {#if isSVG(icon)}
function create_if_block_7$1(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*icon*/ ctx[14], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (461:10) {#if $modalStep$ === 'selectingWallet' || windowWidth <= MOBILE_WINDOW_WIDTH}
function create_if_block_3$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_4$1, create_else_block];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*wallets*/ ctx[2].length) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (473:12) {:else}
function create_else_block(ctx) {
	let installwallet;
	let current;
	installwallet = new InstallWallet({});

	return {
		c() {
			create_component(installwallet.$$.fragment);
		},
		m(target, anchor) {
			mount_component(installwallet, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(installwallet.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(installwallet.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(installwallet, detaching);
		}
	};
}

// (462:12) {#if wallets.length}
function create_if_block_4$1(ctx) {
	let agreement;
	let updating_agreed;
	let t;
	let div;
	let selectingwallet;
	let current;

	function agreement_agreed_binding(value) {
		/*agreement_agreed_binding*/ ctx[23](value);
	}

	let agreement_props = {};

	if (/*agreed*/ ctx[7] !== void 0) {
		agreement_props.agreed = /*agreed*/ ctx[7];
	}

	agreement = new Agreement({ props: agreement_props });
	binding_callbacks.push(() => bind(agreement, 'agreed', agreement_agreed_binding));

	selectingwallet = new SelectingWallet({
			props: {
				selectWallet: /*selectWallet*/ ctx[17],
				wallets: /*wallets*/ ctx[2],
				connectingWalletLabel: /*connectingWalletLabel*/ ctx[8],
				connectingErrorMessage: /*connectingErrorMessage*/ ctx[9]
			}
		});

	return {
		c() {
			create_component(agreement.$$.fragment);
			t = space();
			div = element("div");
			create_component(selectingwallet.$$.fragment);
			attr(div, "class", "svelte-7qgvqp");
			toggle_class(div, "disabled", !/*agreed*/ ctx[7]);
		},
		m(target, anchor) {
			mount_component(agreement, target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);
			mount_component(selectingwallet, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const agreement_changes = {};

			if (!updating_agreed && dirty[0] & /*agreed*/ 128) {
				updating_agreed = true;
				agreement_changes.agreed = /*agreed*/ ctx[7];
				add_flush_callback(() => updating_agreed = false);
			}

			agreement.$set(agreement_changes);
			const selectingwallet_changes = {};
			if (dirty[0] & /*wallets*/ 4) selectingwallet_changes.wallets = /*wallets*/ ctx[2];
			if (dirty[0] & /*connectingWalletLabel*/ 256) selectingwallet_changes.connectingWalletLabel = /*connectingWalletLabel*/ ctx[8];
			if (dirty[0] & /*connectingErrorMessage*/ 512) selectingwallet_changes.connectingErrorMessage = /*connectingErrorMessage*/ ctx[9];
			selectingwallet.$set(selectingwallet_changes);

			if (!current || dirty[0] & /*agreed*/ 128) {
				toggle_class(div, "disabled", !/*agreed*/ ctx[7]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(agreement.$$.fragment, local);
			transition_in(selectingwallet.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(agreement.$$.fragment, local);
			transition_out(selectingwallet.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(agreement, detaching);
			if (detaching) detach(t);
			if (detaching) detach(div);
			destroy_component(selectingwallet);
		}
	};
}

// (478:10) {#if displayConnectingWallet}
function create_if_block_2$1(ctx) {
	let connectingwallet;
	let current;

	connectingwallet = new ConnectingWallet({
			props: {
				connectWallet: /*connectWallet*/ ctx[20],
				connectionRejected: /*connectionRejected*/ ctx[1],
				previousConnectionRequest: /*previousConnectionRequest*/ ctx[6],
				setStep: /*setStep*/ ctx[21],
				deselectWallet: /*deselectWallet*/ ctx[18],
				selectedWallet: /*selectedWallet*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(connectingwallet.$$.fragment);
		},
		m(target, anchor) {
			mount_component(connectingwallet, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const connectingwallet_changes = {};
			if (dirty[0] & /*connectionRejected*/ 2) connectingwallet_changes.connectionRejected = /*connectionRejected*/ ctx[1];
			if (dirty[0] & /*previousConnectionRequest*/ 64) connectingwallet_changes.previousConnectionRequest = /*previousConnectionRequest*/ ctx[6];
			if (dirty[0] & /*selectedWallet*/ 8) connectingwallet_changes.selectedWallet = /*selectedWallet*/ ctx[3];
			connectingwallet.$set(connectingwallet_changes);
		},
		i(local) {
			if (current) return;
			transition_in(connectingwallet.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(connectingwallet.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(connectingwallet, detaching);
		}
	};
}

// (489:10) {#if $modalStep$ === 'connectedWallet' && selectedWallet && windowWidth >= MOBILE_WINDOW_WIDTH}
function create_if_block_1$1(ctx) {
	let connectedwallet;
	let current;

	connectedwallet = new ConnectedWallet({
			props: {
				selectedWallet: /*selectedWallet*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(connectedwallet.$$.fragment);
		},
		m(target, anchor) {
			mount_component(connectedwallet, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const connectedwallet_changes = {};
			if (dirty[0] & /*selectedWallet*/ 8) connectedwallet_changes.selectedWallet = /*selectedWallet*/ ctx[3];
			connectedwallet.$set(connectedwallet_changes);
		},
		i(local) {
			if (current) return;
			transition_in(connectedwallet.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(connectedwallet.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(connectedwallet, detaching);
		}
	};
}

// (396:2) <Modal {close}>
function create_default_slot$2(ctx) {
	let div3;
	let t0;
	let div2;
	let t1;
	let div0;
	let closebutton;
	let t2;
	let div1;
	let t3;
	let t4;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*connect*/ ctx[15].showSidebar && create_if_block_8$1(ctx);

	function select_block_type(ctx, dirty) {
		if (/*windowWidth*/ ctx[4] <= MOBILE_WINDOW_WIDTH) return create_if_block_5$1;
		return create_else_block_3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block1 = current_block_type(ctx);
	closebutton = new CloseButton({});
	let if_block2 = (/*$modalStep$*/ ctx[5] === 'selectingWallet' || /*windowWidth*/ ctx[4] <= MOBILE_WINDOW_WIDTH) && create_if_block_3$1(ctx);
	let if_block3 = /*displayConnectingWallet*/ ctx[11] && create_if_block_2$1(ctx);
	let if_block4 = /*$modalStep$*/ ctx[5] === 'connectedWallet' && /*selectedWallet*/ ctx[3] && /*windowWidth*/ ctx[4] >= MOBILE_WINDOW_WIDTH && create_if_block_1$1(ctx);

	return {
		c() {
			div3 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div2 = element("div");
			if_block1.c();
			t1 = space();
			div0 = element("div");
			create_component(closebutton.$$.fragment);
			t2 = space();
			div1 = element("div");
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();
			t4 = space();
			if (if_block4) if_block4.c();
			attr(div0, "class", "button-container absolute svelte-7qgvqp");
			attr(div1, "class", "scroll-container svelte-7qgvqp");
			attr(div2, "class", "content flex flex-column svelte-7qgvqp");
			attr(div3, "class", "container svelte-7qgvqp");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			if (if_block0) if_block0.m(div3, null);
			append(div3, t0);
			append(div3, div2);
			if_block1.m(div2, null);
			append(div2, t1);
			append(div2, div0);
			mount_component(closebutton, div0, null);
			append(div2, t2);
			append(div2, div1);
			if (if_block2) if_block2.m(div1, null);
			append(div1, t3);
			if (if_block3) if_block3.m(div1, null);
			append(div1, t4);
			if (if_block4) if_block4.m(div1, null);
			/*div1_binding*/ ctx[24](div1);
			current = true;

			if (!mounted) {
				dispose = listen(div0, "click", /*close*/ ctx[19]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*connect*/ ctx[15].showSidebar) if_block0.p(ctx, dirty);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div2, t1);
				}
			}

			if (/*$modalStep$*/ ctx[5] === 'selectingWallet' || /*windowWidth*/ ctx[4] <= MOBILE_WINDOW_WIDTH) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*$modalStep$, windowWidth*/ 48) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_3$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*displayConnectingWallet*/ ctx[11]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*displayConnectingWallet*/ 2048) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_2$1(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div1, t4);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*$modalStep$*/ ctx[5] === 'connectedWallet' && /*selectedWallet*/ ctx[3] && /*windowWidth*/ ctx[4] >= MOBILE_WINDOW_WIDTH) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*$modalStep$, selectedWallet, windowWidth*/ 56) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_1$1(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div1, null);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(closebutton.$$.fragment, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(closebutton.$$.fragment, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			if (if_block0) if_block0.d();
			if_block1.d();
			destroy_component(closebutton);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			/*div1_binding*/ ctx[24](null);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$4(ctx) {
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[22]);
	let if_block = !/*autoSelect*/ ctx[0].disableModals && create_if_block$2(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(window, "resize", /*onwindowresize*/ ctx[22]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!/*autoSelect*/ ctx[0].disableModals) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*autoSelect*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
			mounted = false;
			dispose();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let availableWallets;
	let displayConnectingWallet;
	let $modalStep$;
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(13, $_ = $$value));
	let { autoSelect } = $$props;
	const { appMetadata } = configuration;
	const { icon } = appMetadata || {};
	const { walletModules, connect } = state.get();
	const cancelPreviousConnect$ = new Subject();
	let connectionRejected = false;
	let previousConnectionRequest = false;
	let wallets = [];
	let selectedWallet;
	let agreed;
	let connectingWalletLabel;
	let connectingErrorMessage;
	let windowWidth;
	let scrollContainer;
	const modalStep$ = new BehaviorSubject('selectingWallet');
	component_subscribe($$self, modalStep$, value => $$invalidate(5, $modalStep$ = value));

	// handle the edge case where disableModals was set to true on first call
	// and then set to false on second call and there is still a pending call
	connectWallet$.pipe(distinctUntilChanged((prev, curr) => prev.autoSelect && curr.autoSelect && prev.autoSelect.disableModals === curr.autoSelect.disableModals), filter$1(({ autoSelect }) => autoSelect && autoSelect.disableModals === false), takeUntil$1(onDestroy$)).subscribe(() => {
		selectedWallet && connectWallet();
	});

	// ==== SELECT WALLET ==== //
	async function selectWallet({ label, icon, getInterface }) {
		$$invalidate(8, connectingWalletLabel = label);

		try {
			const existingWallet = state.get().wallets.find(wallet => wallet.label === label);

			if (existingWallet) {
				// set as first wallet
				addWallet(existingWallet);

				try {
					await selectAccounts(existingWallet.provider);

					// change step on next event loop
					setTimeout(() => setStep('connectedWallet'), 1);
				} catch(error) {
					const { code } = error;

					if (code === ProviderRpcErrorCode.UNSUPPORTED_METHOD || code === ProviderRpcErrorCode.DOES_NOT_EXIST) {
						connectWallet$.next({
							inProgress: false,
							actionRequired: existingWallet.label
						});
					}
				}

				$$invalidate(3, selectedWallet = existingWallet);
				return;
			}

			const { chains } = state.get();

			const { provider, instance } = await getInterface({
				chains,
				BigNumber: BigNumber$2,
				EventEmitter,
				appMetadata
			});

			const loadedIcon = await icon;

			$$invalidate(3, selectedWallet = {
				label,
				icon: loadedIcon,
				provider,
				instance,
				accounts: [],
				chains: [{ namespace: 'evm', id: '0x1' }]
			});

			$$invalidate(9, connectingErrorMessage = '');
			scrollToTop();

			// change step on next event loop
			setTimeout(() => setStep('connectingWallet'), 1);
		} catch(error) {
			const { message } = error;
			$$invalidate(9, connectingErrorMessage = message);
			scrollToTop();
		}
	}

	function deselectWallet() {
		$$invalidate(3, selectedWallet = null);
	}

	function updateSelectedWallet(update) {
		$$invalidate(3, selectedWallet = { ...selectedWallet, ...update });
	}

	async function autoSelectWallet(wallet) {
		const { getIcon, getInterface, label } = wallet;
		const icon = getIcon();
		selectWallet({ label, icon, getInterface });
	}

	async function loadWalletsForSelection() {
		$$invalidate(2, wallets = walletModules.map(({ getIcon, getInterface, label }) => {
			return { label, icon: getIcon(), getInterface };
		}));
	}

	function close() {
		connectWallet$.next({ inProgress: false });
	}

	// ==== CONNECT WALLET ==== //
	async function connectWallet() {
		$$invalidate(1, connectionRejected = false);
		const { provider, label } = selectedWallet;
		cancelPreviousConnect$.next();

		try {
			const [address] = await Promise.race([
				// resolved account
				requestAccounts(provider),
				// or connect wallet is called again whilst waiting for response
				firstValueFrom(cancelPreviousConnect$.pipe(mapTo([])))
			]);

			// canceled previous request
			if (!address) {
				return;
			}

			const chain = await getChainId(provider);

			if (state.get().notify.enabled) {
				const sdk = await getBNMulitChainSdk();

				if (sdk) {
					try {
						sdk.subscribe({
							id: address,
							chainId: chain,
							type: 'account'
						});
					} catch(error) {
						
					} // unsupported network for transaction events
				}
			}

			const update = {
				accounts: [
					{
						address,
						ens: null,
						uns: null,
						balance: null
					}
				],
				chains: [{ namespace: 'evm', id: chain }]
			};

			addWallet({ ...selectedWallet, ...update });
			trackWallet(provider, label);
			updateSelectedWallet(update);
			setStep('connectedWallet');
			scrollToTop();
		} catch(error) {
			const { code } = error;
			scrollToTop();

			// user rejected account access
			if (code === ProviderRpcErrorCode.ACCOUNT_ACCESS_REJECTED) {
				$$invalidate(1, connectionRejected = true);

				if (autoSelect.disableModals) {
					connectWallet$.next({ inProgress: false });
				} else if (autoSelect.label) {
					$$invalidate(0, autoSelect.label = '', autoSelect);
				}

				return;
			}

			// account access has already been requested and is awaiting approval
			if (code === ProviderRpcErrorCode.ACCOUNT_ACCESS_ALREADY_REQUESTED) {
				$$invalidate(6, previousConnectionRequest = true);

				if (autoSelect.disableModals) {
					connectWallet$.next({ inProgress: false });
					return;
				}

				listenAccountsChanged({
					provider: selectedWallet.provider,
					disconnected$: connectWallet$.pipe(filter$1(({ inProgress }) => !inProgress), mapTo(''))
				}).pipe(take$1(1)).subscribe(([account]) => {
					account && connectWallet();
				});

				return;
			}
		}
	}

	// ==== CONNECTED WALLET ==== //
	async function updateAccountDetails() {
		const { accounts, chains: selectedWalletChains } = selectedWallet;
		const appChains = state.get().chains;
		const [connectedWalletChain] = selectedWalletChains;
		const appChain = appChains.find(({ namespace, id }) => namespace === connectedWalletChain.namespace && id === connectedWalletChain.id);
		const { address } = accounts[0];
		let { balance, ens, uns } = accounts[0];

		if (balance === null) {
			getBalance(address, appChain).then(balance => {
				updateAccount(selectedWallet.label, address, { balance });
			});
		}

		if (ens === null && validEnsChain(connectedWalletChain.id)) {
			getEns(address, appChain).then(ens => {
				updateAccount(selectedWallet.label, address, { ens });
			});
		}

		if (uns === null) {
			getUns(address, appChain).then(uns => {
				updateAccount(selectedWallet.label, address, { uns });
			});
		}

		setTimeout(() => connectWallet$.next({ inProgress: false }), 1500);
	}

	modalStep$.pipe(takeUntil$1(onDestroy$)).subscribe(step => {
		switch (step) {
			case 'selectingWallet':
				{
					if (autoSelect.label) {
						const walletToAutoSelect = walletModules.find(({ label }) => label.toLowerCase() === autoSelect.label.toLowerCase());

						if (walletToAutoSelect) {
							autoSelectWallet(walletToAutoSelect);
						} else if (autoSelect.disableModals) {
							connectWallet$.next({ inProgress: false });
						}
					} else {
						$$invalidate(8, connectingWalletLabel = '');
						loadWalletsForSelection();
					}

					break;
				}
			case 'connectingWallet':
				{
					connectWallet();
					break;
				}
			case 'connectedWallet':
				{
					$$invalidate(8, connectingWalletLabel = '');
					updateAccountDetails();
					break;
				}
		}
	});

	function setStep(update) {
		cancelPreviousConnect$.next();
		modalStep$.next(update);
	}

	function scrollToTop() {
		scrollContainer && scrollContainer.scrollTo(0, 0);
	}

	function onwindowresize() {
		$$invalidate(4, windowWidth = window.innerWidth);
	}

	function agreement_agreed_binding(value) {
		agreed = value;
		$$invalidate(7, agreed);
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			scrollContainer = $$value;
			$$invalidate(10, scrollContainer);
		});
	}

	$$self.$$set = $$props => {
		if ('autoSelect' in $$props) $$invalidate(0, autoSelect = $$props.autoSelect);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*wallets*/ 4) {
			$$invalidate(12, availableWallets = wallets.length - state.get().wallets.length);
		}

		if ($$self.$$.dirty[0] & /*$modalStep$, selectedWallet, windowWidth, connectionRejected*/ 58) {
			$$invalidate(11, displayConnectingWallet = $modalStep$ === 'connectingWallet' && selectedWallet && windowWidth >= MOBILE_WINDOW_WIDTH || windowWidth <= MOBILE_WINDOW_WIDTH && connectionRejected && $modalStep$ === 'connectingWallet' && selectedWallet);
		}
	};

	return [
		autoSelect,
		connectionRejected,
		wallets,
		selectedWallet,
		windowWidth,
		$modalStep$,
		previousConnectionRequest,
		agreed,
		connectingWalletLabel,
		connectingErrorMessage,
		scrollContainer,
		displayConnectingWallet,
		availableWallets,
		$_,
		icon,
		connect,
		modalStep$,
		selectWallet,
		deselectWallet,
		close,
		connectWallet,
		setStep,
		onwindowresize,
		agreement_agreed_binding,
		div1_binding
	];
}

class Index$1 extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, { autoSelect: 0 }, add_css$4, [-1, -1]);
	}
}

/* src/views/chain/SwitchChain.svelte generated by Svelte v3.55.1 */

function add_css$3(target) {
	append_styles(target, "svelte-12yam41", ".container.svelte-12yam41{padding:var(--onboard-spacing-4, var(--spacing-4));font-family:var(--onboard-font-family-normal, var(--font-family-normal));line-height:16px;font-size:var(--onboard-font-size-5, var(--font-size-5))}.close.svelte-12yam41{top:var(--onboard-spacing-5, var(--spacing-5));right:var(--onboard-spacing-5, var(--spacing-5));padding:0.5rem}h4.svelte-12yam41{font-size:var(--onboard-font-size-3, var(--font-size-3));margin:var(--onboard-spacing-4, var(--spacing-4)) 0}p.svelte-12yam41{margin:0 0 var(--onboard-spacing-4, var(--spacing-4)) 0;max-width:488px}");
}

// (42:0) <Modal {close}>
function create_default_slot$1(ctx) {
	let div1;
	let h4;
	let t0_value = /*$_*/ ctx[0]('modals.switchChain.heading', { default: en.modals.switchChain.heading }) + "";
	let t0;
	let t1;
	let p0;

	let t2_value = /*$_*/ ctx[0]('modals.switchChain.paragraph1', {
		default: en.modals.switchChain.paragraph1,
		values: {
			app: /*appMetadata*/ ctx[1] && /*appMetadata*/ ctx[1].name || 'This app',
			nextNetworkName: /*nextNetworkName*/ ctx[2]
		}
	}) + "";

	let t2;
	let t3;
	let p1;

	let t4_value = /*$_*/ ctx[0]('modals.switchChain.paragraph2', {
		default: en.modals.switchChain.paragraph2
	}) + "";

	let t4;
	let t5;
	let div0;
	let closebutton;
	let current;
	let mounted;
	let dispose;
	closebutton = new CloseButton({});

	return {
		c() {
			div1 = element("div");
			h4 = element("h4");
			t0 = text(t0_value);
			t1 = space();
			p0 = element("p");
			t2 = text(t2_value);
			t3 = space();
			p1 = element("p");
			t4 = text(t4_value);
			t5 = space();
			div0 = element("div");
			create_component(closebutton.$$.fragment);
			attr(h4, "class", "svelte-12yam41");
			attr(p0, "class", "svelte-12yam41");
			attr(p1, "class", "svelte-12yam41");
			attr(div0, "class", "close absolute svelte-12yam41");
			attr(div1, "class", "container relative svelte-12yam41");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, h4);
			append(h4, t0);
			append(div1, t1);
			append(div1, p0);
			append(p0, t2);
			append(div1, t3);
			append(div1, p1);
			append(p1, t4);
			append(div1, t5);
			append(div1, div0);
			mount_component(closebutton, div0, null);
			current = true;

			if (!mounted) {
				dispose = listen(div0, "click", /*close*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]('modals.switchChain.heading', { default: en.modals.switchChain.heading }) + "")) set_data(t0, t0_value);

			if ((!current || dirty & /*$_*/ 1) && t2_value !== (t2_value = /*$_*/ ctx[0]('modals.switchChain.paragraph1', {
				default: en.modals.switchChain.paragraph1,
				values: {
					app: /*appMetadata*/ ctx[1] && /*appMetadata*/ ctx[1].name || 'This app',
					nextNetworkName: /*nextNetworkName*/ ctx[2]
				}
			}) + "")) set_data(t2, t2_value);

			if ((!current || dirty & /*$_*/ 1) && t4_value !== (t4_value = /*$_*/ ctx[0]('modals.switchChain.paragraph2', {
				default: en.modals.switchChain.paragraph2
			}) + "")) set_data(t4, t4_value);
		},
		i(local) {
			if (current) return;
			transition_in(closebutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(closebutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(closebutton);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$3(ctx) {
	let modal;
	let current;

	modal = new Modal({
			props: {
				close: /*close*/ ctx[3],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(modal.$$.fragment);
		},
		m(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const modal_changes = {};

			if (dirty & /*$$scope, $_*/ 33) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(modal, detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $switchChainModal$;
	let $_;
	component_subscribe($$self, switchChainModal$, $$value => $$invalidate(4, $switchChainModal$ = $$value));
	component_subscribe($$self, _, $$value => $$invalidate(0, $_ = $$value));
	const { appMetadata } = configuration;
	const nextNetworkName = $switchChainModal$.chain.label;

	function close() {
		switchChainModal$.next(null);
	}

	return [$_, appMetadata, nextNetworkName, close];
}

class SwitchChain extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {}, add_css$3);
	}
}

/* src/views/shared/InfoIcon.svelte generated by Svelte v3.55.1 */

function add_css$2(target) {
	append_styles(target, "svelte-z54y2j", ".icon.svelte-z54y2j{border-radius:50px;color:var(--onboard-primary-500, var(--primary-500))}");
}

function create_fragment$2(ctx) {
	let div;
	let div_style_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", "icon flex svelte-z54y2j");
			attr(div, "style", div_style_value = `width: ${/*size*/ ctx[0]}px; height: ${/*size*/ ctx[0]}px;`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = infoIcon;
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 1 && div_style_value !== (div_style_value = `width: ${/*size*/ ctx[0]}px; height: ${/*size*/ ctx[0]}px;`)) {
				attr(div, "style", div_style_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { size = 20 } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
	};

	return [size];
}

class InfoIcon extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, { size: 0 }, add_css$2);
	}
}

/* src/views/connect/ActionRequired.svelte generated by Svelte v3.55.1 */

function add_css$1(target) {
	append_styles(target, "svelte-1pfpbt8", ".content.svelte-1pfpbt8{padding:1rem;width:300px;font-family:var(--onboard-font-family-normal, var(--font-family-normal));font-size:var(--onboard-font-size-5, var(--font-size-5));line-height:24px;background:var(\n      --onboard-action-required-modal-background,\n      var(--onboard-white, var(--white))\n    )}.icon-container.svelte-1pfpbt8{width:3rem;height:3rem;background:var(--onboard-primary-100, var(--primary-100));border-radius:24px}h4.svelte-1pfpbt8{margin:1.5rem 0 0.5rem 0;font-weight:700}.action-required-heading.svelte-1pfpbt8,.action-required-info.svelte-1pfpbt8{color:var(\n      --onboard-action-required-text-color,\n      var(--onboard-black, inherit)\n    )}.action-required-btn.svelte-1pfpbt8{color:var(\n      --onboard-action-required-btn-text-color,\n      var(--onboard-black, inherit)\n    )}p.svelte-1pfpbt8{margin:0;font-weight:400}a.svelte-1pfpbt8{font-weight:700}button.svelte-1pfpbt8{margin-top:1.5rem;font-weight:700}");
}

// (79:6) {#if wallet === 'MetaMask'}
function create_if_block$1(ctx) {
	let a;
	let t_value = /*$_*/ ctx[1]('modals.actionRequired.linkText') + "";
	let t;

	return {
		c() {
			a = element("a");
			t = text(t_value);
			attr(a, "href", "https://metamask.zendesk.com/hc/en-us/articles/360061346311-Switching-accounts-in-MetaMask");
			attr(a, "target", "_blank");
			attr(a, "rel", "noreferrer noopener");
			attr(a, "class", "svelte-1pfpbt8");
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 2 && t_value !== (t_value = /*$_*/ ctx[1]('modals.actionRequired.linkText') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(a);
		}
	};
}

// (66:0) <Modal {close}>
function create_default_slot(ctx) {
	let div1;
	let div0;
	let infoicon;
	let t0;
	let h4;
	let t1_value = /*$_*/ ctx[1]('modals.actionRequired.heading', { values: { wallet: /*wallet*/ ctx[0] } }) + "";
	let t1;
	let t2;
	let p;
	let t3_value = /*$_*/ ctx[1]('modals.actionRequired.paragraph') + "";
	let t3;
	let t4;
	let t5;
	let button;
	let t6_value = /*$_*/ ctx[1]('modals.actionRequired.buttonText') + "";
	let t6;
	let current;
	let mounted;
	let dispose;
	infoicon = new InfoIcon({});
	let if_block = /*wallet*/ ctx[0] === 'MetaMask' && create_if_block$1(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(infoicon.$$.fragment);
			t0 = space();
			h4 = element("h4");
			t1 = text(t1_value);
			t2 = space();
			p = element("p");
			t3 = text(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			t5 = space();
			button = element("button");
			t6 = text(t6_value);
			attr(div0, "class", "icon-container flex justify-center items-center svelte-1pfpbt8");
			attr(h4, "class", "action-required-heading svelte-1pfpbt8");
			attr(p, "class", "action-required-info svelte-1pfpbt8");
			attr(button, "class", "button-neutral-solid rounded action-required-btn svelte-1pfpbt8");
			attr(div1, "class", "content svelte-1pfpbt8");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(infoicon, div0, null);
			append(div1, t0);
			append(div1, h4);
			append(h4, t1);
			append(div1, t2);
			append(div1, p);
			append(p, t3);
			append(p, t4);
			if (if_block) if_block.m(p, null);
			append(div1, t5);
			append(div1, button);
			append(button, t6);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*close*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$_, wallet*/ 3) && t1_value !== (t1_value = /*$_*/ ctx[1]('modals.actionRequired.heading', { values: { wallet: /*wallet*/ ctx[0] } }) + "")) set_data(t1, t1_value);
			if ((!current || dirty & /*$_*/ 2) && t3_value !== (t3_value = /*$_*/ ctx[1]('modals.actionRequired.paragraph') + "")) set_data(t3, t3_value);

			if (/*wallet*/ ctx[0] === 'MetaMask') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(p, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if ((!current || dirty & /*$_*/ 2) && t6_value !== (t6_value = /*$_*/ ctx[1]('modals.actionRequired.buttonText') + "")) set_data(t6, t6_value);
		},
		i(local) {
			if (current) return;
			transition_in(infoicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(infoicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(infoicon);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$1(ctx) {
	let modal;
	let current;

	modal = new Modal({
			props: {
				close: /*close*/ ctx[2],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(modal.$$.fragment);
		},
		m(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const modal_changes = {};

			if (dirty & /*$$scope, $_, wallet*/ 11) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(modal, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(1, $_ = $$value));
	let { wallet } = $$props;

	function close() {
		connectWallet$.next({ inProgress: false, actionRequired: '' });
	}

	$$self.$$set = $$props => {
		if ('wallet' in $$props) $$invalidate(0, wallet = $$props.wallet);
	};

	return [wallet, $_, close];
}

class ActionRequired extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, { wallet: 0 }, add_css$1);
	}
}

/* src/views/Index.svelte generated by Svelte v3.55.1 */

function add_css(target) {
	append_styles(target, "svelte-1mvm68y", ".flex{display:flex}.inline-flex{display:inline-flex}.flex-column{flex-direction:column}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.justify-center{justify-content:center}.justify-start{justify-content:flex-start}.justify-between{justify-content:space-between}.justify-end{justify-content:flex-end}.justify-around{justify-content:space-around}.relative{position:relative}.absolute{position:absolute}.fixed{position:fixed}.pointer{cursor:pointer}.shadow-1{box-shadow:var(--onboard-shadow-1, var(--shadow-1))}.w-100{width:100%}*{box-sizing:border-box}input{background:var(--onboard-white, var(--white))}input{width:100%;padding:0.5rem 1rem;outline:2px solid var(--onboard-gray-200, var(--gray-200));border:none;border-radius:8px;font-size:1rem;line-height:1.5;color:var(--onboard-gray-600, var(--gray-600));transition:all 200ms ease-in-out}input[type='checkbox']{-webkit-appearance:none;width:auto;background:var(--onboard-white, var(--white));outline:1px solid var(--onboard-gray-300, var(--gray-300));border:none;padding:0.5em;border-radius:3px;display:flex;justify-content:center;align-items:center;position:relative;cursor:pointer}input[type='checkbox']:hover{border-color:var(\n      --onboard-checkbox-background,\n      var(--onboard-primary-500, var(--primary-500))\n    )}input[type='checkbox']:checked{background:var(\n      --onboard-checkbox-background,\n      var(--onboard-primary-500, var(--primary-500))\n    );border-color:var(\n      --onboard-checkbox-background,\n      var(--onboard-primary-500, var(--primary-500))\n    );color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input[type='checkbox']:checked:after{content:url(\"data:image/svg+xml,%3Csvg width='0.885em' height='0.6em' viewBox='0 0 14 11' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 6L5 11L14 2L12.59 0.58L5 8.17L1.41 4.59L0 6Z' fill='white'/%3E%3C/svg%3E\");font-size:12px;position:absolute;color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input:hover{border-color:var(\n      --onboard-checkbox-color,\n      var(--onboard-white, var(--white))\n    )}input:focus{border-color:var(--onboard-primary-500, var(--primary-500));box-shadow:0 0 1px 1px\n      var(\n        --onboard-checkbox-background,\n        var(--onboard-primary-500, var(--primary-500))\n      );box-shadow:0 0 0 1px -moz-mac-focusring}input:disabled, textarea:disabled, select:disabled{background:var(--gray-100)}input::-moz-focus-inner{outline:0;padding:0;margin-top:-2px;margin-bottom:-2px}a{color:var(\n      --onboard-link-color,\n      var(--onboard-primary-500, var(--primary-500))\n    );text-decoration:none}a:hover{text-decoration:underline}button{display:flex;align-items:center;justify-content:center;padding:calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);border-radius:24px;cursor:pointer;font:inherit;border:none;transition:background-color 150ms ease-in-out, color 150ms ease-in-out}.onboard-button-primary{background:var(--onboard-white, var(--white));padding:calc(var(--onboard-spacing-5, var(--spacing-5)) - 1px)\n      calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);color:var(--onboard-gray-500, var(--gray-500));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));border:1px solid var(--onboard-gray-500, var(--gray-500));font-weight:700}.button-neutral-solid{width:100%;border-radius:8px;background:var(--onboard-gray-500, var(--gray-500));color:var(--onboard-white, var(--white));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3))}.button-neutral-solid-b{width:100%;background:var(--onboard-gray-100, var(--gray-100));color:var(--onboard-gray-500, var(--gray-500));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3))}button.rounded{border-radius:24px}.button-neutral-solid:hover{background:var(--onboard-gray-700, var(--gray-700))}.button-neutral-solid-b:hover{background:var(--onboard-gray-200, var(--gray-200))}.button-neutral-solid:active{color:var(--onboard-gray-300, var(--gray-300))}.button-neutral-solid-b:active{color:var(--onboard-gray-600, var(--gray-600));background:var(--onboard-gray-300, var(--gray-300))}.container.svelte-1mvm68y{padding:16px;font-family:var(--onboard-font-family-normal, var(--font-family-normal));width:100%;pointer-events:none;touch-action:none}.z-indexed.svelte-1mvm68y{z-index:var(--account-center-z-index)}@media all and (min-width: 428px){.container.svelte-1mvm68y{max-width:348px;}}");
}

// (360:0) {#if $connectWallet$.inProgress}
function create_if_block_20(ctx) {
	let connect;
	let current;

	connect = new Index$1({
			props: {
				autoSelect: /*$connectWallet$*/ ctx[8].autoSelect
			}
		});

	return {
		c() {
			create_component(connect.$$.fragment);
		},
		m(target, anchor) {
			mount_component(connect, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const connect_changes = {};
			if (dirty & /*$connectWallet$*/ 256) connect_changes.autoSelect = /*$connectWallet$*/ ctx[8].autoSelect;
			connect.$set(connect_changes);
		},
		i(local) {
			if (current) return;
			transition_in(connect.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(connect.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(connect, detaching);
		}
	};
}

// (364:0) {#if $connectWallet$.actionRequired}
function create_if_block_19(ctx) {
	let actionrequired;
	let current;

	actionrequired = new ActionRequired({
			props: {
				wallet: /*$connectWallet$*/ ctx[8].actionRequired
			}
		});

	return {
		c() {
			create_component(actionrequired.$$.fragment);
		},
		m(target, anchor) {
			mount_component(actionrequired, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const actionrequired_changes = {};
			if (dirty & /*$connectWallet$*/ 256) actionrequired_changes.wallet = /*$connectWallet$*/ ctx[8].actionRequired;
			actionrequired.$set(actionrequired_changes);
		},
		i(local) {
			if (current) return;
			transition_in(actionrequired.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(actionrequired.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(actionrequired, detaching);
		}
	};
}

// (368:0) {#if $switchChainModal$}
function create_if_block_18(ctx) {
	let switchchain;
	let current;
	switchchain = new SwitchChain({});

	return {
		c() {
			create_component(switchchain.$$.fragment);
		},
		m(target, anchor) {
			mount_component(switchchain, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(switchchain.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(switchchain.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(switchchain, detaching);
		}
	};
}

// (372:0) {#if !$accountCenter$.enabled && !$notify$.enabled}
function create_if_block_17(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "container flex flex-column fixed z-indexed svelte-1mvm68y");

			attr(div, "style", "top: 0; right: 0; " + (/*device*/ ctx[11].type === 'mobile'
			? 'padding-bottom: 0;'
			: '') + "");

			attr(div, "id", "transaction-preview-container");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (382:0) {#if displayAccountCenterNotifySameContainer}
function create_if_block_9(ctx) {
	let div1;
	let show_if_3 = /*$notify$*/ ctx[3].position.includes('bottom') && /*$accountCenter$*/ ctx[1].position.includes('bottom') && /*samePositionOrMobile*/ ctx[7];
	let t0;
	let show_if_2 = /*$accountCenter$*/ ctx[1].position.includes('bottom');
	let t1;
	let div0;
	let div0_style_value;
	let t2;
	let show_if_1 = /*$accountCenter$*/ ctx[1].position.includes('top');
	let t3;
	let show_if = /*$notify$*/ ctx[3].position.includes('top') && /*$accountCenter$*/ ctx[1].position.includes('top') && /*samePositionOrMobile*/ ctx[7];
	let div1_style_value;
	let current;
	let if_block0 = show_if_3 && create_if_block_15(ctx);
	let if_block1 = show_if_2 && create_if_block_14();

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block_3,
		then: create_then_block_3,
		catch: create_catch_block_3,
		value: 22,
		blocks: [,,,]
	};

	handle_promise(/*accountCenterComponent*/ ctx[16], info);
	let if_block2 = show_if_1 && create_if_block_12();
	let if_block3 = show_if && create_if_block_10(ctx);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			div0 = element("div");
			info.block.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();

			attr(div0, "style", div0_style_value = !/*$accountCenter$*/ ctx[1].expanded && /*$accountCenter$*/ ctx[1].minimal && /*$accountCenter$*/ ctx[1].position.includes('Right')
			? 'margin-left: auto'
			: !/*$accountCenter$*/ ctx[1].expanded && /*$accountCenter$*/ ctx[1].minimal && /*$accountCenter$*/ ctx[1].position.includes('Left')
				? 'margin-right: auto'
				: '');

			attr(div0, "id", "account-center-with-notify");
			attr(div1, "class", "container flex flex-column fixed z-indexed svelte-1mvm68y");

			attr(div1, "style", div1_style_value = "" + (/*setPositioningDefaults*/ ctx[15](accountCenterPositioning)[/*$accountCenter$*/ ctx[1].position] + "; " + (/*device*/ ctx[11].type === 'mobile' && /*$accountCenter$*/ ctx[1].position.includes('top')
			? 'padding-bottom: 0;'
			: /*device*/ ctx[11].type === 'mobile' && /*$accountCenter$*/ ctx[1].position.includes('bottom')
				? 'padding-top:0;'
				: '') + ""));
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			if (if_block1) if_block1.m(div1, null);
			append(div1, t1);
			append(div1, div0);
			info.block.m(div0, info.anchor = null);
			info.mount = () => div0;
			info.anchor = null;
			append(div1, t2);
			if (if_block2) if_block2.m(div1, null);
			append(div1, t3);
			if (if_block3) if_block3.m(div1, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$notify$, $accountCenter$, samePositionOrMobile*/ 138) show_if_3 = /*$notify$*/ ctx[3].position.includes('bottom') && /*$accountCenter$*/ ctx[1].position.includes('bottom') && /*samePositionOrMobile*/ ctx[7];

			if (show_if_3) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$notify$, $accountCenter$, samePositionOrMobile*/ 138) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_15(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (dirty & /*$accountCenter$*/ 2) show_if_2 = /*$accountCenter$*/ ctx[1].position.includes('bottom');

			if (show_if_2) {
				if (if_block1) ; else {
					if_block1 = create_if_block_14();
					if_block1.c();
					if_block1.m(div1, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			update_await_block_branch(info, ctx, dirty);

			if (!current || dirty & /*$accountCenter$*/ 2 && div0_style_value !== (div0_style_value = !/*$accountCenter$*/ ctx[1].expanded && /*$accountCenter$*/ ctx[1].minimal && /*$accountCenter$*/ ctx[1].position.includes('Right')
			? 'margin-left: auto'
			: !/*$accountCenter$*/ ctx[1].expanded && /*$accountCenter$*/ ctx[1].minimal && /*$accountCenter$*/ ctx[1].position.includes('Left')
				? 'margin-right: auto'
				: '')) {
				attr(div0, "style", div0_style_value);
			}

			if (dirty & /*$accountCenter$*/ 2) show_if_1 = /*$accountCenter$*/ ctx[1].position.includes('top');

			if (show_if_1) {
				if (if_block2) ; else {
					if_block2 = create_if_block_12();
					if_block2.c();
					if_block2.m(div1, t3);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*$notify$, $accountCenter$, samePositionOrMobile*/ 138) show_if = /*$notify$*/ ctx[3].position.includes('top') && /*$accountCenter$*/ ctx[1].position.includes('top') && /*samePositionOrMobile*/ ctx[7];

			if (show_if) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty & /*$notify$, $accountCenter$, samePositionOrMobile*/ 138) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_10(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div1, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*$accountCenter$*/ 2 && div1_style_value !== (div1_style_value = "" + (/*setPositioningDefaults*/ ctx[15](accountCenterPositioning)[/*$accountCenter$*/ ctx[1].position] + "; " + (/*device*/ ctx[11].type === 'mobile' && /*$accountCenter$*/ ctx[1].position.includes('top')
			? 'padding-bottom: 0;'
			: /*device*/ ctx[11].type === 'mobile' && /*$accountCenter$*/ ctx[1].position.includes('bottom')
				? 'padding-top:0;'
				: '') + ""))) {
				attr(div1, "style", div1_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(info.block);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block0);

			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			info.block.d();
			info.token = null;
			info = null;
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};
}

// (393:4) {#if $notify$.position.includes('bottom') && $accountCenter$.position.includes('bottom') && samePositionOrMobile}
function create_if_block_15(ctx) {
	let await_block_anchor;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block_4,
		then: create_then_block_4,
		catch: create_catch_block_4,
		value: 21,
		blocks: [,,,]
	};

	handle_promise(/*notifyComponent*/ ctx[17], info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			update_await_block_branch(info, ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_catch_block_4(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (394:42)          {#if Notify}
function create_then_block_4(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*Notify*/ ctx[21] && create_if_block_16(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*Notify*/ ctx[21]) if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (395:8) {#if Notify}
function create_if_block_16(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*Notify*/ ctx[21];

	function switch_props(ctx) {
		return {
			props: {
				notifications: /*$notifications$*/ ctx[10],
				position: /*$notify$*/ ctx[3].position,
				sharedContainer: /*sharedContainer*/ ctx[0]
			}
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty & /*$notifications$*/ 1024) switch_instance_changes.notifications = /*$notifications$*/ ctx[10];
			if (dirty & /*$notify$*/ 8) switch_instance_changes.position = /*$notify$*/ ctx[3].position;
			if (dirty & /*sharedContainer*/ 1) switch_instance_changes.sharedContainer = /*sharedContainer*/ ctx[0];

			if (switch_value !== (switch_value = /*Notify*/ ctx[21])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_pending_block_4(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (405:4) {#if $accountCenter$.position.includes('bottom')}
function create_if_block_14(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "id", "transaction-preview-container");
			set_style(div, "margin-bottom", "8px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_catch_block_3(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (420:56)          {#if AccountCenter}
function create_then_block_3(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*AccountCenter*/ ctx[22] && create_if_block_13(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*AccountCenter*/ ctx[22]) if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (421:8) {#if AccountCenter}
function create_if_block_13(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*AccountCenter*/ ctx[22];

	function switch_props(ctx) {
		return {};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props());
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (switch_value !== (switch_value = /*AccountCenter*/ ctx[22])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_pending_block_3(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (426:4) {#if $accountCenter$.position.includes('top')}
function create_if_block_12(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "id", "transaction-preview-container");
			set_style(div, "margin-top", "8px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (429:4) {#if $notify$.position.includes('top') && $accountCenter$.position.includes('top') && samePositionOrMobile}
function create_if_block_10(ctx) {
	let await_block_anchor;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block_2,
		then: create_then_block_2,
		catch: create_catch_block_2,
		value: 21,
		blocks: [,,,]
	};

	handle_promise(/*notifyComponent*/ ctx[17], info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			update_await_block_branch(info, ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_catch_block_2(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (430:42)          {#if Notify}
function create_then_block_2(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*Notify*/ ctx[21] && create_if_block_11(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*Notify*/ ctx[21]) if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (431:8) {#if Notify}
function create_if_block_11(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*Notify*/ ctx[21];

	function switch_props(ctx) {
		return {
			props: {
				notifications: /*$notifications$*/ ctx[10],
				position: /*$notify$*/ ctx[3].position,
				sharedContainer: /*sharedContainer*/ ctx[0]
			}
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty & /*$notifications$*/ 1024) switch_instance_changes.notifications = /*$notifications$*/ ctx[10];
			if (dirty & /*$notify$*/ 8) switch_instance_changes.position = /*$notify$*/ ctx[3].position;
			if (dirty & /*sharedContainer*/ 1) switch_instance_changes.sharedContainer = /*sharedContainer*/ ctx[0];

			if (switch_value !== (switch_value = /*Notify*/ ctx[21])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_pending_block_2(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (443:0) {#if displayAccountCenterSeparate}
function create_if_block_4(ctx) {
	let div1;
	let show_if_1 = /*$accountCenter$*/ ctx[1].position.includes('bottom');
	let t0;
	let div0;
	let div0_style_value;
	let t1;
	let show_if = /*$accountCenter$*/ ctx[1].position.includes('top');
	let div1_style_value;
	let current;
	let if_block0 = show_if_1 && create_if_block_8();
	let if_block1 = /*$accountCenter$*/ ctx[1].enabled && /*$wallets$*/ ctx[2].length && create_if_block_6(ctx);
	let if_block2 = show_if && create_if_block_5();

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();

			attr(div0, "style", div0_style_value = !/*$accountCenter$*/ ctx[1].expanded && /*$accountCenter$*/ ctx[1].minimal && /*$accountCenter$*/ ctx[1].position.includes('Right')
			? 'margin-left: auto'
			: !/*$accountCenter$*/ ctx[1].expanded && /*$accountCenter$*/ ctx[1].minimal && /*$accountCenter$*/ ctx[1].position.includes('Left')
				? 'margin-right: auto'
				: '');

			attr(div1, "class", "container flex flex-column fixed z-indexed svelte-1mvm68y");

			attr(div1, "style", div1_style_value = "" + (/*setPositioningDefaults*/ ctx[15](accountCenterPositioning)[/*$accountCenter$*/ ctx[1].position] + "; " + (/*device*/ ctx[11].type === 'mobile' && /*$accountCenter$*/ ctx[1].position.includes('top')
			? 'padding-bottom: 0;'
			: /*device*/ ctx[11].type === 'mobile' && /*$accountCenter$*/ ctx[1].position.includes('bottom')
				? 'padding-top:0;'
				: '') + ""));
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			append(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append(div1, t1);
			if (if_block2) if_block2.m(div1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*$accountCenter$*/ 2) show_if_1 = /*$accountCenter$*/ ctx[1].position.includes('bottom');

			if (show_if_1) {
				if (if_block0) ; else {
					if_block0 = create_if_block_8();
					if_block0.c();
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*$accountCenter$*/ ctx[1].enabled && /*$wallets$*/ ctx[2].length) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$accountCenter$, $wallets$*/ 6) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*$accountCenter$*/ 2 && div0_style_value !== (div0_style_value = !/*$accountCenter$*/ ctx[1].expanded && /*$accountCenter$*/ ctx[1].minimal && /*$accountCenter$*/ ctx[1].position.includes('Right')
			? 'margin-left: auto'
			: !/*$accountCenter$*/ ctx[1].expanded && /*$accountCenter$*/ ctx[1].minimal && /*$accountCenter$*/ ctx[1].position.includes('Left')
				? 'margin-right: auto'
				: '')) {
				attr(div0, "style", div0_style_value);
			}

			if (dirty & /*$accountCenter$*/ 2) show_if = /*$accountCenter$*/ ctx[1].position.includes('top');

			if (show_if) {
				if (if_block2) ; else {
					if_block2 = create_if_block_5();
					if_block2.c();
					if_block2.m(div1, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!current || dirty & /*$accountCenter$*/ 2 && div1_style_value !== (div1_style_value = "" + (/*setPositioningDefaults*/ ctx[15](accountCenterPositioning)[/*$accountCenter$*/ ctx[1].position] + "; " + (/*device*/ ctx[11].type === 'mobile' && /*$accountCenter$*/ ctx[1].position.includes('top')
			? 'padding-bottom: 0;'
			: /*device*/ ctx[11].type === 'mobile' && /*$accountCenter$*/ ctx[1].position.includes('bottom')
				? 'padding-top:0;'
				: '') + ""))) {
				attr(div1, "style", div1_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

// (454:4) {#if $accountCenter$.position.includes('bottom')}
function create_if_block_8(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "id", "transaction-preview-container");
			set_style(div, "margin-bottom", "8px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (468:6) {#if $accountCenter$.enabled && $wallets$.length}
function create_if_block_6(ctx) {
	let await_block_anchor;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block_1,
		then: create_then_block_1,
		catch: create_catch_block_1,
		value: 22,
		blocks: [,,,]
	};

	handle_promise(/*accountCenterComponent*/ ctx[16], info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			update_await_block_branch(info, ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_catch_block_1(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (469:58)            {#if AccountCenter}
function create_then_block_1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*AccountCenter*/ ctx[22] && create_if_block_7(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*AccountCenter*/ ctx[22]) if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (470:10) {#if AccountCenter}
function create_if_block_7(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*AccountCenter*/ ctx[22];

	function switch_props(ctx) {
		return {};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props());
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (switch_value !== (switch_value = /*AccountCenter*/ ctx[22])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_pending_block_1(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (476:4) {#if $accountCenter$.position.includes('top')}
function create_if_block_5(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "id", "transaction-preview-container");
			set_style(div, "margin-top", "8px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (481:0) {#if displayNotifySeparate}
function create_if_block(ctx) {
	let div;
	let show_if_1 = /*$notify$*/ ctx[3].position.includes('top');
	let t0;
	let t1;
	let show_if = /*$notify$*/ ctx[3].position.includes('bottom');
	let div_style_value;
	let current;
	let if_block0 = show_if_1 && create_if_block_3();

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 21,
		blocks: [,,,]
	};

	handle_promise(/*notifyComponent*/ ctx[17], info);
	let if_block1 = show_if && create_if_block_1();

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			info.block.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr(div, "class", "container flex flex-column fixed z-indexed svelte-1mvm68y");

			attr(div, "style", div_style_value = "" + (/*setPositioningDefaults*/ ctx[15](notifyPositioning)[/*$notify$*/ ctx[3].position] + "; " + (/*device*/ ctx[11].type === 'mobile' && /*$notify$*/ ctx[3].position.includes('top')
			? 'padding-bottom: 0;'
			: /*device*/ ctx[11].type === 'mobile' && /*$notify$*/ ctx[3].position.includes('bottom')
				? 'padding-top:0;'
				: '') + ""));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			info.block.m(div, info.anchor = null);
			info.mount = () => div;
			info.anchor = t1;
			append(div, t1);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$notify$*/ 8) show_if_1 = /*$notify$*/ ctx[3].position.includes('top');

			if (show_if_1) {
				if (if_block0) ; else {
					if_block0 = create_if_block_3();
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			update_await_block_branch(info, ctx, dirty);
			if (dirty & /*$notify$*/ 8) show_if = /*$notify$*/ ctx[3].position.includes('bottom');

			if (show_if) {
				if (if_block1) ; else {
					if_block1 = create_if_block_1();
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty & /*$notify$*/ 8 && div_style_value !== (div_style_value = "" + (/*setPositioningDefaults*/ ctx[15](notifyPositioning)[/*$notify$*/ ctx[3].position] + "; " + (/*device*/ ctx[11].type === 'mobile' && /*$notify$*/ ctx[3].position.includes('top')
			? 'padding-bottom: 0;'
			: /*device*/ ctx[11].type === 'mobile' && /*$notify$*/ ctx[3].position.includes('bottom')
				? 'padding-top:0;'
				: '') + ""))) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			info.block.d();
			info.token = null;
			info = null;
			if (if_block1) if_block1.d();
		}
	};
}

// (492:4) {#if $notify$.position.includes('top')}
function create_if_block_3(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "id", "transaction-preview-container");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_catch_block(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (495:40)        {#if Notify}
function create_then_block(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*Notify*/ ctx[21] && create_if_block_2(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*Notify*/ ctx[21]) if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (496:6) {#if Notify}
function create_if_block_2(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*Notify*/ ctx[21];

	function switch_props(ctx) {
		return {
			props: {
				notifications: /*$notifications$*/ ctx[10],
				position: /*$notify$*/ ctx[3].position,
				sharedContainer: /*sharedContainer*/ ctx[0]
			}
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty & /*$notifications$*/ 1024) switch_instance_changes.notifications = /*$notifications$*/ ctx[10];
			if (dirty & /*$notify$*/ 8) switch_instance_changes.position = /*$notify$*/ ctx[3].position;
			if (dirty & /*sharedContainer*/ 1) switch_instance_changes.sharedContainer = /*sharedContainer*/ ctx[0];

			if (switch_value !== (switch_value = /*Notify*/ ctx[21])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (1:0) <script lang="ts">import { shareReplay, startWith }
function create_pending_block(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (505:4) {#if $notify$.position.includes('bottom')}
function create_if_block_1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "id", "transaction-preview-container");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let if_block6_anchor;
	let current;
	let if_block0 = /*$connectWallet$*/ ctx[8].inProgress && create_if_block_20(ctx);
	let if_block1 = /*$connectWallet$*/ ctx[8].actionRequired && create_if_block_19(ctx);
	let if_block2 = /*$switchChainModal$*/ ctx[9] && create_if_block_18();
	let if_block3 = !/*$accountCenter$*/ ctx[1].enabled && !/*$notify$*/ ctx[3].enabled && create_if_block_17(ctx);
	let if_block4 = /*displayAccountCenterNotifySameContainer*/ ctx[4] && create_if_block_9(ctx);
	let if_block5 = /*displayAccountCenterSeparate*/ ctx[5] && create_if_block_4(ctx);
	let if_block6 = /*displayNotifySeparate*/ ctx[6] && create_if_block(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, t3, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert(target, t4, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert(target, t5, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert(target, if_block6_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*$connectWallet$*/ ctx[8].inProgress) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$connectWallet$*/ 256) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_20(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$connectWallet$*/ ctx[8].actionRequired) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$connectWallet$*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_19(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*$switchChainModal$*/ ctx[9]) {
				if (if_block2) {
					if (dirty & /*$switchChainModal$*/ 512) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_18();
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(t2.parentNode, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (!/*$accountCenter$*/ ctx[1].enabled && !/*$notify$*/ ctx[3].enabled) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_17(ctx);
					if_block3.c();
					if_block3.m(t3.parentNode, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*displayAccountCenterNotifySameContainer*/ ctx[4]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty & /*displayAccountCenterNotifySameContainer*/ 16) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_9(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t4.parentNode, t4);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*displayAccountCenterSeparate*/ ctx[5]) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty & /*displayAccountCenterSeparate*/ 32) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_4(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t5.parentNode, t5);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*displayNotifySeparate*/ ctx[6]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty & /*displayNotifySeparate*/ 64) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block4);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block4);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(t2);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t3);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(t4);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach(t5);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach(if_block6_anchor);
		}
	};
}

const accountCenterPositioning = 'account-center';
const notifyPositioning = 'notify-onboard-container';

function instance($$self, $$props, $$invalidate) {
	let sharedContainer;
	let samePositionOrMobile;
	let sharedMobileContainerCheck;
	let displayNotifySeparate;
	let displayAccountCenterSeparate;
	let displayAccountCenterNotifySameContainer;
	let $accountCenter$;
	let $wallets$;
	let $notify$;
	let $connectWallet$;
	let $switchChainModal$;
	let $notifications$;
	component_subscribe($$self, wallets$, $$value => $$invalidate(2, $wallets$ = $$value));
	component_subscribe($$self, connectWallet$, $$value => $$invalidate(8, $connectWallet$ = $$value));
	component_subscribe($$self, switchChainModal$, $$value => $$invalidate(9, $switchChainModal$ = $$value));
	const { device, containerElements } = configuration;
	const accountCenter$ = state.select('accountCenter').pipe(startWith(state.get().accountCenter), shareReplay(1));
	component_subscribe($$self, accountCenter$, value => $$invalidate(1, $accountCenter$ = value));
	const notify$ = state.select('notify').pipe(startWith(state.get().notify), shareReplay(1));
	component_subscribe($$self, notify$, value => $$invalidate(3, $notify$ = value));
	const notifications$ = state.select('notifications').pipe(startWith(state.get().notifications));
	component_subscribe($$self, notifications$, value => $$invalidate(10, $notifications$ = value));

	const setPositioningDefaults = targetComponentVariable => {
		return {
			topLeft: `
        top: var(--${targetComponentVariable}-position-top, 0); 
        left: var(--${targetComponentVariable}-position-left, 0);`,
			topRight: `
        top: var(--${targetComponentVariable}-position-top, 0); 
        right: var(--${targetComponentVariable}-position-right, 0);`,
			bottomRight: `
        bottom: var(--${targetComponentVariable}-position-bottom, 0); 
        right: var(--${targetComponentVariable}-position-right, 0);`,
			bottomLeft: `
        bottom: var(--${targetComponentVariable}-position-bottom, 0); 
        left: var(--${targetComponentVariable}-position-left, 0);`
		};
	};

	const accountCenterComponent = $accountCenter$.enabled
	? import('./Index-11ca746e.js').then(mod => mod.default)
	: Promise.resolve(null);

	const notifyComponent = $notify$.enabled
	? import('./Index-c6ffd361.js').then(mod => mod.default)
	: Promise.resolve(null);

	const accountCenterMountToElement = $accountCenter$.enabled && containerElements && containerElements.accountCenter;

	if (accountCenterMountToElement) {
		const accountCenter = document.createElement('onboard-account-center');
		const target = accountCenter.attachShadow({ mode: 'open' });
		let getW3OEl = document.querySelector('onboard-v2');
		let w3OStyleSheets = getW3OEl.shadowRoot.styleSheets;
		const accountCenterStyleSheet = new CSSStyleSheet();

		// Copy Onboard stylesheets over to AccountCenter shadow DOM
		Object.values(w3OStyleSheets).forEach(sheet => {
			const styleRules = Object.values(sheet.cssRules);
			styleRules.forEach(rule => accountCenterStyleSheet.insertRule(rule.cssText));
		});

		// eslint-disable-next-line @typescript-eslint/ban-ts-comment
		//@ts-ignore
		target.adoptedStyleSheets = [accountCenterStyleSheet];

		const containerElement = document.querySelector(accountCenterMountToElement);
		containerElement.appendChild(accountCenter);

		if (!containerElement) {
			throw new Error(`Element with query ${accountCenterMountToElement} does not exist.`);
		}

		const getACComp = async () => {
			let acComponent = await accountCenterComponent;

			if (acComponent) {
				new acComponent({
						target,
						props: {
							settings: $accountCenter$,
							mountInContainer: true
						}
					});
			}
		};

		getACComp();
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$accountCenter$, $notify$*/ 10) {
			$$invalidate(0, sharedContainer = !accountCenterMountToElement && $accountCenter$.enabled && $notify$.enabled && $notify$.position === $accountCenter$.position);
		}

		if ($$self.$$.dirty & /*$accountCenter$, $notify$*/ 10) {
			$$invalidate(7, samePositionOrMobile = device.type === 'mobile' || $accountCenter$.position === $notify$.position);
		}

		if ($$self.$$.dirty & /*$notify$, $accountCenter$*/ 10) {
			$$invalidate(18, sharedMobileContainerCheck = $notify$.position.includes('bottom') && $accountCenter$.position.includes('bottom') || $notify$.position.includes('top') && $accountCenter$.position.includes('top'));
		}

		if ($$self.$$.dirty & /*$notify$, $accountCenter$, sharedMobileContainerCheck, $wallets$*/ 262158) {
			$$invalidate(6, displayNotifySeparate = $notify$.enabled && (!$accountCenter$.enabled || accountCenterMountToElement || $notify$.position !== $accountCenter$.position && device.type !== 'mobile' || device.type === 'mobile' && !sharedMobileContainerCheck || !$wallets$.length));
		}

		if ($$self.$$.dirty & /*$accountCenter$, $notify$, sharedMobileContainerCheck, $wallets$*/ 262158) {
			$$invalidate(5, displayAccountCenterSeparate = $accountCenter$.enabled && (!$notify$.enabled || $notify$.position !== $accountCenter$.position && device.type !== 'mobile' || device.type === 'mobile' && !sharedMobileContainerCheck) && $wallets$.length);
		}

		if ($$self.$$.dirty & /*$notify$, $accountCenter$, sharedContainer, sharedMobileContainerCheck, $wallets$*/ 262159) {
			$$invalidate(4, displayAccountCenterNotifySameContainer = $notify$.enabled && $accountCenter$.enabled && (sharedContainer || device.type === 'mobile' && sharedMobileContainerCheck) && $wallets$.length);
		}
	};

	return [
		sharedContainer,
		$accountCenter$,
		$wallets$,
		$notify$,
		displayAccountCenterNotifySameContainer,
		displayAccountCenterSeparate,
		displayNotifySeparate,
		samePositionOrMobile,
		$connectWallet$,
		$switchChainModal$,
		$notifications$,
		device,
		accountCenter$,
		notify$,
		notifications$,
		setPositioningDefaults,
		accountCenterComponent,
		notifyComponent,
		sharedMobileContainerCheck
	];
}

class Index extends SvelteComponent {
	constructor(options) {
		super();
		init$1(this, options, instance, create_fragment, safe_not_equal, {}, add_css);
	}
}

let notificationsArr;
state.select('notifications').subscribe(notifications => {
    notificationsArr = notifications;
});
async function preflightNotifications(options) {
    const invalid = validatePreflightNotifications(options);
    if (invalid) {
        throw invalid;
    }
    const { sendTransaction, estimateGas, gasPrice, balance, txDetails, txApproveReminderTimeout } = options;
    // Check for reminder timeout and confirm its greater than 3 seconds
    const reminderTimeout = txApproveReminderTimeout && txApproveReminderTimeout > 3000
        ? txApproveReminderTimeout
        : 15000;
    // if `balance` or `estimateGas` or `gasPrice` is not provided,
    // then sufficient funds check is disabled
    // if `txDetails` is not provided,
    // then duplicate transaction check is disabled
    // if dev doesn't want notify to initiate the transaction
    // and `sendTransaction` is not provided, then transaction
    // rejected notification is disabled
    // to disable hints for `txAwaitingApproval`, `txConfirmReminder`
    // or any other notification, then return false from listener functions
    const [gas, price] = await gasEstimates(estimateGas, gasPrice);
    const id = createId(nanoid());
    const value = new BigNumber$1((txDetails && txDetails.value) || 0);
    // check sufficient balance if required parameters are available
    if (balance && gas && price) {
        const transactionCost = gas.times(price).plus(value);
        // if transaction cost is greater than the current balance
        if (transactionCost.gt(new BigNumber$1(balance))) {
            const eventCode = 'nsfFail';
            addNotification(buildNotification(eventCode, id));
        }
    }
    // check previous transactions awaiting approval
    const txRequested = notificationsArr.find(tx => tx.eventCode === 'txRequest');
    if (txRequested) {
        const eventCode = 'txAwaitingApproval';
        const newNotification = buildNotification(eventCode, txRequested.id);
        addNotification(newNotification);
    }
    // confirm reminder timeout defaults to 20 seconds
    setTimeout(() => {
        const awaitingApproval = notificationsArr.find(tx => tx.id === id && tx.eventCode === 'txRequest');
        if (awaitingApproval) {
            const eventCode = 'txConfirmReminder';
            const newNotification = buildNotification(eventCode, awaitingApproval.id);
            addNotification(newNotification);
        }
    }, reminderTimeout);
    const eventCode = 'txRequest';
    addNotification(buildNotification(eventCode, id));
    // if not provided with sendTransaction function,
    // resolve with transaction hash(or void) so dev can initiate transaction
    if (!sendTransaction) {
        return id;
    }
    // get result and handle errors
    let hash;
    try {
        hash = await sendTransaction();
    }
    catch (error) {
        const { eventCode, errorMsg } = extractMessageFromError(error);
        addNotification(buildNotification(eventCode, id));
        console.error(errorMsg);
        return;
    }
    // Remove preflight notification if a resolves to hash
    // and let the SDK take over
    removeNotification(id);
    if (hash) {
        return hash;
    }
    return;
}
const buildNotification = (eventCode, id) => {
    return {
        eventCode,
        type: eventToType(eventCode),
        id,
        key: createKey(id, eventCode),
        message: createMessageText(eventCode),
        startTime: Date.now(),
        network: Object.keys(networkToChainId).find(key => networkToChainId[key] === state.get().chains[0].id),
        autoDismiss: 0
    };
};
const createKey = (id, eventCode) => {
    return `${id}-${eventCode}`;
};
const createId = (id) => {
    return `${id}-preflight`;
};
const createMessageText = (eventCode) => {
    const notificationDefaultMessages = en.notify;
    notificationDefaultMessages.transaction;
    return notificationDefaultMessages.transaction[eventCode];
};
function extractMessageFromError(error) {
    if (!error.stack || !error.message) {
        return {
            eventCode: 'txError',
            errorMsg: 'An unknown error occured'
        };
    }
    const message = error.stack || error.message;
    if (message.includes('User denied transaction signature')) {
        return {
            eventCode: 'txSendFail',
            errorMsg: 'User denied transaction signature'
        };
    }
    if (message.includes('transaction underpriced')) {
        return {
            eventCode: 'txUnderpriced',
            errorMsg: 'Transaction is under priced'
        };
    }
    return {
        eventCode: 'txError',
        errorMsg: message
    };
}
const gasEstimates = async (gasFunc, gasPriceFunc) => {
    if (!gasFunc || !gasPriceFunc) {
        return Promise.resolve([]);
    }
    const gasProm = gasFunc();
    if (!gasProm.then) {
        throw new Error('The `estimateGas` function must return a Promise');
    }
    const gasPriceProm = gasPriceFunc();
    if (!gasPriceProm.then) {
        throw new Error('The `gasPrice` function must return a Promise');
    }
    return Promise.all([gasProm, gasPriceProm])
        .then(([gasResult, gasPriceResult]) => {
        if (typeof gasResult !== 'string') {
            throw new Error(`The Promise returned from calling 'estimateGas' must resolve with a value of type 'string'. Received a value of: ${gasResult} with a type: ${typeof gasResult}`);
        }
        if (typeof gasPriceResult !== 'string') {
            throw new Error(`The Promise returned from calling 'gasPrice' must resolve with a value of type 'string'. Received a value of: ${gasPriceResult} with a type: ${typeof gasPriceResult}`);
        }
        return [new BigNumber$1(gasResult), new BigNumber$1(gasPriceResult)];
    })
        .catch(error => {
        throw new Error(`There was an error getting gas estimates: ${error}`);
    });
};

const API = {
    connectWallet: connect$1,
    disconnectWallet: disconnect,
    setChain,
    state: {
        get: state.get,
        select: state.select,
        actions: {
            setWalletModules,
            setLocale,
            updateNotify,
            customNotification,
            preflightNotifications,
            updateBalances,
            updateAccountCenter,
            setPrimaryWallet
        }
    }
};
function init(options) {
    if (typeof window === 'undefined')
        return API;
    if (options) {
        const error = validateInitOptions(options);
        if (error) {
            throw error;
        }
    }
    const { wallets, chains, appMetadata = null, i18n, accountCenter, apiKey, notify, gas, connect, containerElements, transactionPreview } = options;
    updateConfiguration({ containerElements });
    const { device, svelteInstance } = configuration;
    if (svelteInstance) {
        // if already initialized, need to cleanup old instance
        console.warn('Re-initializing Onboard and resetting back to initial state');
        reset$.next();
    }
    initialize(i18n);
    addChains(chainIdToHex(chains));
    if (typeof connect !== undefined) {
        updateConnectModal(connect);
    }
    // update accountCenter
    if (typeof accountCenter !== 'undefined') {
        let accountCenterUpdate;
        if (device.type === 'mobile') {
            accountCenterUpdate = {
                ...APP_INITIAL_STATE.accountCenter,
                ...(accountCenter.mobile ? accountCenter.mobile : {})
            };
        }
        else if (accountCenter.desktop) {
            accountCenterUpdate = {
                ...APP_INITIAL_STATE.accountCenter,
                ...accountCenter.desktop
            };
        }
        updateAccountCenter(accountCenterUpdate);
    }
    // update notify
    if (typeof notify !== 'undefined') {
        if ('desktop' in notify || 'mobile' in notify) {
            const error = validateNotifyOptions(notify);
            if (error) {
                throw error;
            }
            if ((!notify.desktop || (notify.desktop && !notify.desktop.position)) &&
                accountCenter &&
                accountCenter.desktop &&
                accountCenter.desktop.position) {
                notify.desktop.position = accountCenter.desktop.position;
            }
            if ((!notify.mobile || (notify.mobile && !notify.mobile.position)) &&
                accountCenter &&
                accountCenter.mobile &&
                accountCenter.mobile.position) {
                notify.mobile.position = accountCenter.mobile.position;
            }
            let notifyUpdate;
            if (device.type === 'mobile' && notify.mobile) {
                notifyUpdate = {
                    ...APP_INITIAL_STATE.notify,
                    ...notify.mobile
                };
            }
            else if (notify.desktop) {
                notifyUpdate = {
                    ...APP_INITIAL_STATE.notify,
                    ...notify.desktop
                };
            }
            updateNotify(notifyUpdate);
        }
        else {
            const error = validateNotify(notify);
            if (error) {
                throw error;
            }
            const notifyUpdate = {
                ...APP_INITIAL_STATE.notify,
                ...notify
            };
            updateNotify(notifyUpdate);
        }
    }
    else {
        const notifyUpdate = APP_INITIAL_STATE.notify;
        updateNotify(notifyUpdate);
    }
    const app = svelteInstance || mountApp();
    updateConfiguration({
        appMetadata,
        svelteInstance: app,
        apiKey,
        initialWalletInit: wallets,
        gas,
        transactionPreview
    });
    if (transactionPreview) {
        const getBnSDK = async () => {
            transactionPreview.init({
                containerElement: '#transaction-preview-container',
                sdk: await getBlocknativeSdk(),
                apiKey
            });
            wallets$.subscribe(wallets => {
                wallets.forEach(({ provider }) => {
                    transactionPreview.patchProvider(provider);
                });
            });
        };
        getBnSDK();
    }
    return API;
}
function mountApp() {
    class Onboard extends HTMLElement {
        constructor() {
            super();
        }
    }
    if (!customElements.get('onboard-v2')) {
        customElements.define('onboard-v2', Onboard);
    }
    // Add Fonts to main page
    const styleEl = document.createElement('style');
    styleEl.innerHTML = `
    ${SofiaProRegular}
  `;
    document.body.appendChild(styleEl);
    // add to DOM
    const onboard = document.createElement('onboard-v2');
    const target = onboard.attachShadow({ mode: 'open' });
    onboard.style.all = 'initial';
    target.innerHTML = `
      <style>
        :host {  
          /* COLORS */
          --white: white;
          --black: black;
          --primary-1: #2F80ED;
          --primary-100: #eff1fc;
          --primary-200: #d0d4f7;
          --primary-300: #b1b8f2;
          --primary-400: #929bed;
          --primary-500: #6370e5;
          --primary-600: #454ea0;
          --primary-700: #323873;
          --gray-100: #ebebed;
          --gray-200: #c2c4c9;
          --gray-300: #999ca5;
          --gray-400: #707481;
          --gray-500: #33394b;
          --gray-600: #242835;
          --gray-700: #1a1d26;
          --success-100: #d1fae3;
          --success-200: #baf7d5;
          --success-300: #a4f4c6;
          --success-400: #8df2b8;
          --success-500: #5aec99;
          --success-600: #18ce66;
          --success-700: #129b4d;
          --danger-100: #ffe5e6;
          --danger-200: #ffcccc;
          --danger-300: #ffb3b3;
          --danger-400: #ff8080;
          --danger-500: #ff4f4f;
          --danger-600: #cc0000;
          --danger-700: #660000;
          --warning-100: #ffefcc;
          --warning-200: #ffe7b3;
          --warning-300: #ffd780;
          --warning-400: #ffc74c;
          --warning-500: #ffaf00;
          --warning-600: #cc8c00;
          --warning-700: #664600;
  
          /* FONTS */
          --font-family-normal: Sofia Pro;
  
          --font-size-1: 3rem;
          --font-size-2: 2.25rem;
          --font-size-3: 1.5rem;
          --font-size-4: 1.25rem;
          --font-size-5: 1rem;
          --font-size-6: .875rem;
          --font-size-7: .75rem;
  
          --font-line-height-1: 24px;
          --font-line-height-2: 20px;
          --font-line-height-3: 16px;
          --font-line-height-4: 12px;
  
          /* SPACING */
          --spacing-1: 3rem;
          --spacing-2: 2rem;
          --spacing-3: 1.5rem;
          --spacing-4: 1rem;
          --spacing-5: 0.5rem;
          --spacing-6: 0.25rem;
          --spacing-7: 0.125rem;
  
          /* BORDER RADIUS */
          --border-radius-1: 24px;  
          --border-radius-2: 20px;  
          --border-radius-3: 16px;  
          --border-radius-4: 12px;  
          --border-radius-5: 8px;  

          /* SHADOWS */
          --shadow-0: none;
          --shadow-1: 0px 4px 12px rgba(0, 0, 0, 0.1);
          --shadow-2: inset 0px -1px 0px rgba(0, 0, 0, 0.1);
          --shadow-3: 0px 4px 16px rgba(179, 179, 179, 0.2);

          /* MODAL POSITIONING */
          --modal-z-index: 10;
          --modal-top: unset;
          --modal-right: unset;
          --modal-bottom: unset;
          --modal-left: unset;
          
          /* MODAL STYLES */
          --modal-backdrop: rgba(0, 0, 0, 0.6);
        }
      </style>
    `;
    const containerElementQuery = state.get().accountCenter.containerElement || 'body';
    const containerElement = document.querySelector(containerElementQuery);
    if (!containerElement) {
        throw new Error(`Element with query ${containerElementQuery} does not exist.`);
    }
    containerElement.appendChild(onboard);
    const app = new Index({
        target
    });
    return app;
}

export { questionIcon as $, transition_out as A, destroy_each as B, en as C, shortenDomain as D, shortenAddress as E, create_component as F, space as G, toggle_class as H, mount_component as I, stop_propagation as J, destroy_component as K, run_all as L, selectAccounts as M, connectWallet$ as N, setPrimaryWallet as O, disconnect as P, copyWalletAddress as Q, SuccessStatusIcon as R, SvelteComponent as S, set_style as T, add_render_callback as U, create_in_transition as V, WalletAppBadge as W, fade as X, Modal as Y, is_function as Z, unrecognizedChainStyle as _, append_styles as a, blocknative as a0, outro_and_destroy_block as a1, quartOut as a2, fly as a3, state as a4, getDefaultChainStyles as a5, bind as a6, add_flush_callback as a7, configuration as a8, bubble as a9, connect$1 as aa, updateAccountCenter as ab, create_out_transition as ac, onDestroy as ad, cubicOut as ae, defaultNotifyEventStyles as af, networkToChainId as ag, gweiToWeiHex as ah, toHexString as ai, chainStyles as aj, transactions$ as ak, onMount as al, removeNotification as am, removeTransaction as an, addCustomNotification as ao, fix_position as ap, add_transform as aq, create_animation as ar, fix_and_outro_and_destroy_block as as, init as at, insert as b, component_subscribe as c, detach as d, empty as e, setChain as f, binding_callbacks as g, connectedToValidAppChain as h, init$1 as i, element as j, attr as k, null_to_empty as l, append as m, noop as n, select_option as o, listen as p, destroy_block as q, chainIdToLabel as r, safe_not_equal as s, text as t, update_keyed_each as u, set_data as v, wallets$ as w, transition_in as x, group_outros as y, check_outros as z };